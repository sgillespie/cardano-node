-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cardano consensus protocols
--   
--   Cardano consensus protocols.
@package ouroboros-consensus-protocol
@version 0.7.0.0


-- | Hot key
--   
--   Intended for qualified import
module Ouroboros.Consensus.Protocol.Ledger.HotKey

-- | We call the relative periods that a KES key is valid its evolution, to
--   avoid confusion with absolute periods.
type KESEvolution = Period
data KESInfo
KESInfo :: !KESPeriod -> !KESPeriod -> !KESEvolution -> KESInfo
[kesStartPeriod] :: KESInfo -> !KESPeriod

-- | Currently derived from <tt>TPraosParams</tt>: &gt; kesEndPeriod =
--   kesStartPeriod + tpraosMaxKESEvo
[kesEndPeriod] :: KESInfo -> !KESPeriod

-- | Current evolution or <i>relative period</i>.
--   
--   Invariant: &gt; kesStartPeriod + kesEvolution in [kesStartPeriod,
--   kesEndPeriod)
[kesEvolution] :: KESInfo -> !KESEvolution

-- | Return the absolute KES period
kesAbsolutePeriod :: KESInfo -> KESPeriod
data KESStatus

-- | The given period is before the start period of the KES key.
BeforeKESStart :: KESPeriod -> KESPeriod -> KESStatus

-- | The given period is in the range of the KES key.
InKESRange :: KESEvolution -> KESStatus

-- | The given period is after the end period of the KES key.
AfterKESEnd :: KESPeriod -> KESPeriod -> KESStatus

-- | Return the evolution of the given KES period, <i>when</i> it falls
--   within the range of the <a>HotKey</a> (<tt>[hkStart, hkEnd)</tt>).
--   
--   Note that the upper bound is exclusive, the spec says: &gt; c0 &lt;=
--   kesPeriod s &lt; c0 + MaxKESEvo
kesStatus :: KESInfo -> KESPeriod -> KESStatus

-- | API to interact with the key.
data HotKey c m
HotKey :: (KESPeriod -> m KESEvolutionInfo) -> m KESInfo -> m Bool -> (forall toSign. (KESignable c toSign, HasCallStack) => toSign -> m (SignedKES c toSign)) -> HotKey c m

-- | Evolve the KES signing key to the given absolute KES period.
--   
--   When the key cannot evolve anymore, we poison it.
[evolve] :: HotKey c m -> KESPeriod -> m KESEvolutionInfo

-- | Return <a>KESInfo</a> of the signing key.
[getInfo] :: HotKey c m -> m KESInfo

-- | Return <a>True</a> when the signing key is poisoned because it
--   expired.
[isPoisoned] :: HotKey c m -> m Bool

-- | Sign the given <tt>toSign</tt> with the current signing key.
--   
--   PRECONDITION: the key is not poisoned.
--   
--   POSTCONDITION: the signature is in normal form.
[sign_] :: HotKey c m -> forall toSign. (KESignable c toSign, HasCallStack) => toSign -> m (SignedKES c toSign)

-- | Failed to evolve the KES key.
data KESEvolutionError

-- | The KES key could not be evolved to the target period.
KESCouldNotEvolve :: KESInfo -> KESPeriod -> KESEvolutionError

-- | The KES key was already poisoned.
KESKeyAlreadyPoisoned :: KESInfo -> KESPeriod -> KESEvolutionError

-- | Result of evolving the KES key.
type KESEvolutionInfo = UpdateInfo KESInfo KESEvolutionError
mkHotKey :: forall m c. (Crypto c, IOLike m) => SignKeyKES c -> KESPeriod -> Word64 -> m (HotKey c m)
sign :: (KESignable c toSign, HasCallStack) => HotKey c m -> toSign -> m (SignedKES c toSign)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Protocol.Ledger.HotKey.KESInfo
instance GHC.Generics.Generic Ouroboros.Consensus.Protocol.Ledger.HotKey.KESInfo
instance GHC.Show.Show Ouroboros.Consensus.Protocol.Ledger.HotKey.KESInfo
instance GHC.Show.Show Ouroboros.Consensus.Protocol.Ledger.HotKey.KESEvolutionError
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Ledger.HotKey.KESKey c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Ledger.HotKey.KESState c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Ledger.HotKey.KESState c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Ledger.HotKey.KESKey c)


-- | Assorted utility functions for Shelley protocol integration.
--   
--   In particular, various things we need for integration with the
--   <tt>delegation</tt> package from cardano-ledger-specs.
module Ouroboros.Consensus.Protocol.Ledger.Util

-- | Return the first slot in the epoch of the given slot.
firstSlotOfEpochOfSlot :: EpochInfo Identity -> SlotNo -> SlotNo

-- | Verify whether a slot represents a change to a new epoch with regard
--   to some other slot.
--   
--   PRECONDITION: the two slots must be in the same era.
isNewEpoch :: EpochInfo Identity -> WithOrigin SlotNo -> SlotNo -> Bool


-- | Various things common to iterations of the Praos protocol.
module Ouroboros.Consensus.Protocol.Praos.Common

-- | The maximum major protocol version.
--   
--   Must be at least the current major protocol version. For Cardano
--   mainnet, the Shelley era has major protocol verison <b>2</b>.
newtype MaxMajorProtVer
MaxMajorProtVer :: Version -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Version
data PraosCanBeLeader c
PraosCanBeLeader :: !OCert c -> !VKey 'BlockIssuer c -> !SignKeyVRF c -> PraosCanBeLeader c

-- | Certificate delegating rights from the stake pool cold key (or genesis
--   stakeholder delegate cold key) to the online KES key.
[praosCanBeLeaderOpCert] :: PraosCanBeLeader c -> !OCert c

-- | Stake pool cold key or genesis stakeholder delegate cold key.
[praosCanBeLeaderColdVerKey] :: PraosCanBeLeader c -> !VKey 'BlockIssuer c
[praosCanBeLeaderSignKeyVRF] :: PraosCanBeLeader c -> !SignKeyVRF c

-- | View of the ledger tip for chain selection.
--   
--   We order between chains as follows:
--   
--   <ol>
--   <li>By chain length, with longer chains always preferred.</li>
--   <li>If the tip of each chain was issued by the same agent, then we
--   prefer the chain whose tip has the highest ocert issue number.</li>
--   <li>By a VRF value from the chain tip, with lower values preferred.
--   See <tt>pTieBreakVRFValue</tt> for which one is used.</li>
--   </ol>
data PraosChainSelectView c
PraosChainSelectView :: BlockNo -> SlotNo -> VKey 'BlockIssuer c -> Word64 -> OutputVRF (VRF c) -> PraosChainSelectView c
[csvChainLength] :: PraosChainSelectView c -> BlockNo
[csvSlotNo] :: PraosChainSelectView c -> SlotNo
[csvIssuer] :: PraosChainSelectView c -> VKey 'BlockIssuer c
[csvIssueNo] :: PraosChainSelectView c -> Word64
[csvTieBreakVRF] :: PraosChainSelectView c -> OutputVRF (VRF c)

-- | See <a>PraosProtocolSupportsNode</a>
data PraosNonces
PraosNonces :: !Nonce -> !Nonce -> !Nonce -> !Nonce -> !Nonce -> PraosNonces
[candidateNonce] :: PraosNonces -> !Nonce
[epochNonce] :: PraosNonces -> !Nonce
[evolvingNonce] :: PraosNonces -> !Nonce

-- | Nonce constructed from the hash of the Last Applied Block
[labNonce] :: PraosNonces -> !Nonce

-- | Nonce corresponding to the LAB nonce of the last block of the previous
--   epoch
[previousLabNonce] :: PraosNonces -> !Nonce

-- | The node has Praos-aware code that inspects nonces in order to support
--   some Cardano API queries that are crucial to the user exprience
--   
--   The interface being used for that has grown and needs review, but
--   we're adding to it here under time pressure. See
--   <a>https://github.com/IntersectMBO/cardano-node/issues/3864</a>
class ConsensusProtocol p => PraosProtocolSupportsNode p where {
    type PraosProtocolSupportsNodeCrypto p;
}
getPraosNonces :: PraosProtocolSupportsNode p => proxy p -> ChainDepState p -> PraosNonces
getOpCertCounters :: PraosProtocolSupportsNode p => proxy p -> ChainDepState p -> Map (KeyHash 'BlockIssuer (PraosProtocolSupportsNodeCrypto p)) Word64
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Protocol.Praos.Common.MaxMajorProtVer
instance GHC.Generics.Generic Ouroboros.Consensus.Protocol.Praos.Common.MaxMajorProtVer
instance GHC.Show.Show Ouroboros.Consensus.Protocol.Praos.Common.MaxMajorProtVer
instance GHC.Classes.Eq Ouroboros.Consensus.Protocol.Praos.Common.MaxMajorProtVer
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.Common.PraosCanBeLeader c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.Common.PraosCanBeLeader c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Ord (Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c)


-- | This module implements VRF range extension as described in
--   <a>https://iohk.io/en/research/library/papers/on-uc-secure-range-extension-and-batch-verification-for-ecvrf/</a>
module Ouroboros.Consensus.Protocol.Praos.VRF

-- | Input to the verifiable random function. Consists of the hash of the
--   slot and the epoch nonce.
data InputVRF

-- | Indicate the usage of the VRF result.
data VRFUsage

-- | The VRF value will be used to establish whether the issuing node is
--   indeed a leader for this slot.
VRFLeader :: VRFUsage

-- | The VRF value will be used to contribute to the evolving nonce.
VRFNonce :: VRFUsage

-- | Construct a unified VRF value
mkInputVRF :: SlotNo -> Nonce -> InputVRF

-- | Range-extend a VRF output to be used for leader checks from the
--   relevant hash. See section 4.1 of the linked paper for details.
vrfLeaderValue :: forall c proxy. Crypto c => proxy c -> CertifiedVRF (VRF c) InputVRF -> BoundedNatural

-- | Range-extend a VRF output to be used for the evolving nonce. See
--   section 4.1 of the linked paper for details.
vrfNonceValue :: forall c proxy. Crypto c => proxy c -> CertifiedVRF (VRF c) InputVRF -> Nonce
instance Cardano.Binary.ToCBOR.ToCBOR Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance GHC.Generics.Generic Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance GHC.Show.Show Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance GHC.Classes.Ord Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance GHC.Classes.Eq Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF
instance Cardano.Crypto.Util.SignableRepresentation Ouroboros.Consensus.Protocol.Praos.VRF.InputVRF


-- | Block header associated with Praos.
--   
--   The choice of whether to associate the header with the ledger era or
--   the protocol is a little artitrary. Functionally the header contains
--   things which are associated with both ledger and protocol, and which
--   are used by both.
--   
--   We choose to associate the header with the protocol, since it more
--   strongly binds in that direction, and to assist with the mental
--   picture that the protocol is concerned with the block header, while
--   the ledger is concerned with the block body. However, in order to more
--   cleanly illustrate which parts of the header are _strictly_ protocol
--   concerns, we also provide a view of the header (in <a>Views</a>) which
--   extracts just the fields needed for the Praos protocol. This also
--   allows us to hide the more detailed construction of the header.
module Ouroboros.Consensus.Protocol.Praos.Header

-- | Full header type, carrying its own memoised bytes.
data Header crypto
pattern Header :: Crypto crypto => HeaderBody crypto -> SignedKES crypto (HeaderBody crypto) -> Header crypto

-- | The body of the header is the part which gets hashed to form the hash
--   chain.
data HeaderBody crypto
HeaderBody :: !BlockNo -> !SlotNo -> !PrevHash crypto -> !VKey 'BlockIssuer crypto -> !VerKeyVRF crypto -> !CertifiedVRF crypto InputVRF -> !Word32 -> !Hash crypto EraIndependentBlockBody -> !OCert crypto -> !ProtVer -> HeaderBody crypto

-- | block number
[hbBlockNo] :: HeaderBody crypto -> !BlockNo

-- | block slot
[hbSlotNo] :: HeaderBody crypto -> !SlotNo

-- | Hash of the previous block header
[hbPrev] :: HeaderBody crypto -> !PrevHash crypto

-- | verification key of block issuer
[hbVk] :: HeaderBody crypto -> !VKey 'BlockIssuer crypto

-- | VRF verification key for block issuer
[hbVrfVk] :: HeaderBody crypto -> !VerKeyVRF crypto

-- | Certified VRF value
[hbVrfRes] :: HeaderBody crypto -> !CertifiedVRF crypto InputVRF

-- | Size of the block body
[hbBodySize] :: HeaderBody crypto -> !Word32

-- | Hash of block body
[hbBodyHash] :: HeaderBody crypto -> !Hash crypto EraIndependentBlockBody

-- | operational certificate
[hbOCert] :: HeaderBody crypto -> !OCert crypto

-- | protocol version
[hbProtVer] :: HeaderBody crypto -> !ProtVer

-- | Hash a header
headerHash :: Crypto crypto => Header crypto -> Hash (HASH crypto) EraIndependentBlockHeader

-- | Compute the size of the header
headerSize :: Header crypto -> Int
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.Header.Header crypto)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.Header.Header crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.Header.Header crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.Header.Header c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Protocol.Praos.Header.Header c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Protocol.Praos.Header.Header c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Ouroboros.Consensus.Protocol.Praos.Header.Header c))
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw c)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Ouroboros.Consensus.Protocol.Praos.Header.HeaderRaw crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Crypto.Util.SignableRepresentation (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Ouroboros.Consensus.Protocol.Praos.Header.HeaderBody crypto)

module Ouroboros.Consensus.Protocol.Praos.Views

-- | View of the block header required by the Praos protocol.
data HeaderView crypto
HeaderView :: !PrevHash crypto -> !VKey 'BlockIssuer crypto -> !VerKeyVRF (VRF crypto) -> !CertifiedVRF (VRF crypto) InputVRF -> !OCert crypto -> !SlotNo -> !HeaderBody crypto -> !SignedKES (KES crypto) (HeaderBody crypto) -> HeaderView crypto

-- | Hash of the previous block
[hvPrevHash] :: HeaderView crypto -> !PrevHash crypto

-- | verification key of block issuer
[hvVK] :: HeaderView crypto -> !VKey 'BlockIssuer crypto

-- | VRF verification key for block issuer
[hvVrfVK] :: HeaderView crypto -> !VerKeyVRF (VRF crypto)

-- | VRF result
[hvVrfRes] :: HeaderView crypto -> !CertifiedVRF (VRF crypto) InputVRF

-- | operational certificate
[hvOCert] :: HeaderView crypto -> !OCert crypto

-- | Slot
[hvSlotNo] :: HeaderView crypto -> !SlotNo

-- | Header which must be signed
[hvSigned] :: HeaderView crypto -> !HeaderBody crypto

-- | KES Signature of the header
[hvSignature] :: HeaderView crypto -> !SignedKES (KES crypto) (HeaderBody crypto)
data LedgerView crypto
LedgerView :: PoolDistr crypto -> !Word16 -> !Word32 -> !ProtVer -> LedgerView crypto

-- | Stake distribution
[lvPoolDistr] :: LedgerView crypto -> PoolDistr crypto

-- | Maximum header size
[lvMaxHeaderSize] :: LedgerView crypto -> !Word16

-- | Maximum block body size
[lvMaxBodySize] :: LedgerView crypto -> !Word32

-- | Current protocol version
[lvProtocolVersion] :: LedgerView crypto -> !ProtVer
instance GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.Views.LedgerView crypto)


-- | Transitional Praos.
--   
--   Transitional praos allows for the overlaying of Praos with an overlay
--   schedule determining slots to be produced by BFT
module Ouroboros.Consensus.Protocol.TPraos

-- | The maximum major protocol version.
--   
--   Must be at least the current major protocol version. For Cardano
--   mainnet, the Shelley era has major protocol verison <b>2</b>.
newtype MaxMajorProtVer
MaxMajorProtVer :: Version -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Version

-- | View of the ledger tip for chain selection.
--   
--   We order between chains as follows:
--   
--   <ol>
--   <li>By chain length, with longer chains always preferred.</li>
--   <li>If the tip of each chain was issued by the same agent, then we
--   prefer the chain whose tip has the highest ocert issue number.</li>
--   <li>By a VRF value from the chain tip, with lower values preferred.
--   See <tt>pTieBreakVRFValue</tt> for which one is used.</li>
--   </ol>
data PraosChainSelectView c
PraosChainSelectView :: BlockNo -> SlotNo -> VKey 'BlockIssuer c -> Word64 -> OutputVRF (VRF c) -> PraosChainSelectView c
[csvChainLength] :: PraosChainSelectView c -> BlockNo
[csvSlotNo] :: PraosChainSelectView c -> SlotNo
[csvIssuer] :: PraosChainSelectView c -> VKey 'BlockIssuer c
[csvIssueNo] :: PraosChainSelectView c -> Word64
[csvTieBreakVRF] :: PraosChainSelectView c -> OutputVRF (VRF c)
data TPraos c
data TPraosFields c toSign
TPraosFields :: SignedKES c toSign -> toSign -> TPraosFields c toSign
[tpraosSignature] :: TPraosFields c toSign -> SignedKES c toSign
[tpraosToSign] :: TPraosFields c toSign -> toSign

-- | Assembled proof that the issuer has the right to issue a block in the
--   selected slot.
data TPraosIsLeader c
TPraosIsLeader :: CertifiedVRF c Nonce -> CertifiedVRF c Natural -> Maybe (Hash c (VerKeyVRF c)) -> TPraosIsLeader c
[tpraosIsLeaderEta] :: TPraosIsLeader c -> CertifiedVRF c Nonce
[tpraosIsLeaderProof] :: TPraosIsLeader c -> CertifiedVRF c Natural

-- | When in the overlay schedule (otherwise <a>Nothing</a>), return the
--   hash of the VRF verification key in the overlay schedule
[tpraosIsLeaderGenVRFHash] :: TPraosIsLeader c -> Maybe (Hash c (VerKeyVRF c))

-- | TPraos parameters that are node independent
data TPraosParams
TPraosParams :: !Word64 -> !ActiveSlotCoeff -> !SecurityParam -> !Word64 -> !Word64 -> !MaxMajorProtVer -> !Word64 -> !Network -> !Nonce -> !SystemStart -> TPraosParams

-- | See <a>slotsPerKESPeriod</a>.
[tpraosSlotsPerKESPeriod] :: TPraosParams -> !Word64

-- | Active slots coefficient. This parameter represents the proportion of
--   slots in which blocks should be issued. This can be interpreted as the
--   probability that a party holding all the stake will be elected as
--   leader for a given slot.
[tpraosLeaderF] :: TPraosParams -> !ActiveSlotCoeff

-- | See <a>securityParameter</a>.
[tpraosSecurityParam] :: TPraosParams -> !SecurityParam

-- | Maximum number of KES iterations, see <a>maxKESEvo</a>.
[tpraosMaxKESEvo] :: TPraosParams -> !Word64

-- | Quorum for update system votes and MIR certificates, see
--   <a>quorum</a>.
[tpraosQuorum] :: TPraosParams -> !Word64

-- | All blocks invalid after this protocol version, see <a>maxMajorPV</a>.
[tpraosMaxMajorPV] :: TPraosParams -> !MaxMajorProtVer

-- | Maximum number of lovelace in the system, see
--   <a>maxLovelaceSupply</a>.
[tpraosMaxLovelaceSupply] :: TPraosParams -> !Word64

-- | Testnet or mainnet?
[tpraosNetworkId] :: TPraosParams -> !Network

-- | Initial nonce used for the TPraos protocol state. Typically this is
--   derived from the hash of the Shelley genesis config JSON file, but
--   different values may be used for testing purposes.
--   
--   NOTE: this is only used when translating the Byron
--   <a>ChainDepState</a> to the Shelley <a>ChainDepState</a>, at which
--   point we'll need access to the initial nonce at runtime. TODO #2326.
[tpraosInitialNonce] :: TPraosParams -> !Nonce

-- | The system start, as projected from the chain's genesis block.
[tpraosSystemStart] :: TPraosParams -> !SystemStart

-- | Transitional Praos consensus state.
--   
--   In addition to the <a>ChainDepState</a> provided by the ledger, we
--   track the slot number of the last applied header.
data TPraosState c
TPraosState :: !WithOrigin SlotNo -> !ChainDepState c -> TPraosState c
[tpraosStateLastSlot] :: TPraosState c -> !WithOrigin SlotNo
[tpraosStateChainDepState] :: TPraosState c -> !ChainDepState c

-- | Fields arising from transitional praos execution which must be
--   included in the block signature.
data TPraosToSign c
TPraosToSign :: VKey 'BlockIssuer c -> VerKeyVRF c -> CertifiedVRF c Nonce -> CertifiedVRF c Natural -> OCert c -> TPraosToSign c

-- | Verification key for the issuer of this block.
--   
--   Note that unlike in Classic/BFT where we have a key for the genesis
--   delegate on whose behalf we are issuing this block, this key
--   corresponds to the stake pool/core node actually forging the block.
[tpraosToSignIssuerVK] :: TPraosToSign c -> VKey 'BlockIssuer c
[tpraosToSignVrfVK] :: TPraosToSign c -> VerKeyVRF c

-- | Verifiable result containing the updated nonce value.
[tpraosToSignEta] :: TPraosToSign c -> CertifiedVRF c Nonce

-- | Verifiable proof of the leader value, used to determine whether the
--   node has the right to issue a block in this slot.
--   
--   We include a value here even for blocks forged under the BFT schedule.
--   It is not required that such a value be verifiable (though by default
--   it will be verifiably correct, but unused.)
[tpraosToSignLeader] :: TPraosToSign c -> CertifiedVRF c Natural

-- | Lightweight delegation certificate mapping the cold (DSIGN) key to the
--   online KES key.
[tpraosToSignOCert] :: TPraosToSign c -> OCert c

-- | Because we are using the executable spec, rather than implementing the
--   protocol directly here, we have a fixed header type rather than an
--   abstraction. So our validate view is fixed to this.
type TPraosValidateView c = BHeader c
forgeTPraosFields :: (PraosCrypto c, KESignable c toSign, Monad m) => HotKey c m -> CanBeLeader (TPraos c) -> IsLeader (TPraos c) -> (TPraosToSign c -> toSign) -> m (TPraosFields c toSign)
mkShelleyGlobals :: ConsensusConfig (TPraos c) -> Globals
mkTPraosParams :: MaxMajorProtVer -> Nonce -> ShelleyGenesis era -> TPraosParams
class (Crypto c, DSignable c OCertSignable c, KESignable c BHBody c, VRFSignable c Seed) => PraosCrypto c
data () => StandardCrypto

-- | Expresses that, whilst we believe ourselves to be a leader for this
--   slot, we are nonetheless unable to forge a block.
data TPraosCannotForge c

-- | The KES key in our operational certificate can't be used because the
--   current (wall clock) period is before the start period of the key.
--   current KES period.
--   
--   Note: the opposite case, i.e., the wall clock period being after the
--   end period of the key, is caught when trying to update the key in
--   <a>updateForgeState</a>.
TPraosCannotForgeKeyNotUsableYet :: !KESPeriod -> !KESPeriod -> TPraosCannotForge c

-- | We are a genesis delegate, but our VRF key (second argument) does not
--   match the registered key for that delegate (first argument).
TPraosCannotForgeWrongVRF :: !Hash c (VerKeyVRF c) -> !Hash c (VerKeyVRF c) -> TPraosCannotForge c
tpraosCheckCanForge :: ConsensusConfig (TPraos c) -> Hash c (VerKeyVRF c) -> SlotNo -> IsLeader (TPraos c) -> KESInfo -> Either (TPraosCannotForge c) ()
data family ConsensusConfig p
data family Ticked st
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.TPraos.TPraosFields c toSign)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.TPraos.TPraosToSign c)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Protocol.TPraos.TPraosParams
instance GHC.Generics.Generic Ouroboros.Consensus.Protocol.TPraos.TPraosParams
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Abstract.ConsensusConfig (Ouroboros.Consensus.Protocol.TPraos.TPraos c))
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.TPraos.TPraosIsLeader c)
instance GHC.Classes.Eq (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance GHC.Show.Show (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.TPraos.TPraosCannotForge c)
instance (NoThunks.Class.NoThunks toSign, Cardano.Protocol.TPraos.API.PraosCrypto c) => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.TPraos.TPraosFields c toSign)
instance (GHC.Show.Show toSign, Cardano.Protocol.TPraos.API.PraosCrypto c) => GHC.Show.Show (Ouroboros.Consensus.Protocol.TPraos.TPraosFields c toSign)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.TPraos.TPraosToSign c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.TPraos.TPraosCannotForge c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Codec.Serialise.Class.Serialise (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Protocol.Abstract.ConsensusProtocol (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Protocol.Praos.Common.PraosProtocolSupportsNode (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.TPraos.TPraosIsLeader c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Abstract.ConsensusConfig (Ouroboros.Consensus.Protocol.TPraos.TPraos c))
instance Cardano.Protocol.TPraos.API.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.TPraos.TPraosToSign c)
instance (Ouroboros.Consensus.Util.Condense.Condense toSign, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Protocol.TPraos.TPraosFields c toSign)

module Ouroboros.Consensus.Protocol.Praos
data family ConsensusConfig p
data Praos c

-- | Expresses that, whilst we believe ourselves to be a leader for this
--   slot, we are nonetheless unable to forge a block.
data PraosCannotForge c

-- | The KES key in our operational certificate can't be used because the
--   current (wall clock) period is before the start period of the key.
--   current KES period.
--   
--   Note: the opposite case, i.e., the wall clock period being after the
--   end period of the key, is caught when trying to update the key in
--   <tt>updateForgeState</tt>.
PraosCannotForgeKeyNotUsableYet :: !KESPeriod -> !KESPeriod -> PraosCannotForge c
class (Crypto c, Signable (DSIGN c) (OCertSignable c), Signable (DSIGN c) (Hash c EraIndependentTxBody), Signable (KES c) (HeaderBody c), Signable (VRF c) InputVRF) => PraosCrypto c
data PraosFields c toSign
PraosFields :: SignedKES c toSign -> toSign -> PraosFields c toSign
[praosSignature] :: PraosFields c toSign -> SignedKES c toSign
[praosToSign] :: PraosFields c toSign -> toSign

-- | Assembled proof that the issuer has the right to issue a block in the
--   selected slot.
newtype PraosIsLeader c
PraosIsLeader :: CertifiedVRF c InputVRF -> PraosIsLeader c
[praosIsLeaderVrfRes] :: PraosIsLeader c -> CertifiedVRF c InputVRF

-- | Praos parameters that are node independent
data PraosParams
PraosParams :: !Word64 -> !ActiveSlotCoeff -> !SecurityParam -> !Word64 -> !Word64 -> !MaxMajorProtVer -> !Word64 -> !Network -> !SystemStart -> PraosParams

-- | See <a>slotsPerKESPeriod</a>.
[praosSlotsPerKESPeriod] :: PraosParams -> !Word64

-- | Active slots coefficient. This parameter represents the proportion of
--   slots in which blocks should be issued. This can be interpreted as the
--   probability that a party holding all the stake will be elected as
--   leader for a given slot.
[praosLeaderF] :: PraosParams -> !ActiveSlotCoeff

-- | See <a>securityParameter</a>.
[praosSecurityParam] :: PraosParams -> !SecurityParam

-- | Maximum number of KES iterations, see <a>maxKESEvo</a>.
[praosMaxKESEvo] :: PraosParams -> !Word64

-- | Quorum for update system votes and MIR certificates, see
--   <a>quorum</a>.
[praosQuorum] :: PraosParams -> !Word64

-- | All blocks invalid after this protocol version, see <a>maxMajorPV</a>.
[praosMaxMajorPV] :: PraosParams -> !MaxMajorProtVer

-- | Maximum number of lovelace in the system, see
--   <a>maxLovelaceSupply</a>.
[praosMaxLovelaceSupply] :: PraosParams -> !Word64

-- | Testnet or mainnet?
[praosNetworkId] :: PraosParams -> !Network

-- | The system start, as projected from the chain's genesis block.
[praosSystemStart] :: PraosParams -> !SystemStart

-- | Praos consensus state.
--   
--   We track the last slot and the counters for operational certificates,
--   as well as a series of nonces which get updated in different ways over
--   the course of an epoch.
data PraosState c
PraosState :: !WithOrigin SlotNo -> !Map (KeyHash 'BlockIssuer c) Word64 -> !Nonce -> !Nonce -> !Nonce -> !Nonce -> !Nonce -> PraosState c
[praosStateLastSlot] :: PraosState c -> !WithOrigin SlotNo

-- | Operation Certificate counters
[praosStateOCertCounters] :: PraosState c -> !Map (KeyHash 'BlockIssuer c) Word64

-- | Evolving nonce
[praosStateEvolvingNonce] :: PraosState c -> !Nonce

-- | Candidate nonce
[praosStateCandidateNonce] :: PraosState c -> !Nonce

-- | Epoch nonce
[praosStateEpochNonce] :: PraosState c -> !Nonce

-- | Nonce constructed from the hash of the previous block
[praosStateLabNonce] :: PraosState c -> !Nonce

-- | Nonce corresponding to the LAB nonce of the last block of the previous
--   epoch
[praosStateLastEpochBlockNonce] :: PraosState c -> !Nonce

-- | Fields arising from praos execution which must be included in the
--   block signature.
data PraosToSign c
PraosToSign :: VKey 'BlockIssuer c -> VerKeyVRF c -> CertifiedVRF c InputVRF -> OCert c -> PraosToSign c

-- | Verification key for the issuer of this block.
[praosToSignIssuerVK] :: PraosToSign c -> VKey 'BlockIssuer c
[praosToSignVrfVK] :: PraosToSign c -> VerKeyVRF c

-- | Verifiable random value. This is used both to prove the issuer is
--   eligible to issue a block, and to contribute to the evolving nonce.
[praosToSignVrfRes] :: PraosToSign c -> CertifiedVRF c InputVRF

-- | Lightweight delegation certificate mapping the cold (DSIGN) key to the
--   online KES key.
[praosToSignOCert] :: PraosToSign c -> OCert c

-- | Errors which we might encounter
data PraosValidationErr c
VRFKeyUnknown :: !KeyHash StakePool c -> PraosValidationErr c
VRFKeyWrongVRFKey :: !KeyHash StakePool c -> !Hash c (VerKeyVRF c) -> !Hash c (VerKeyVRF c) -> PraosValidationErr c
VRFKeyBadProof :: !SlotNo -> !Nonce -> !CertifiedVRF (VRF c) InputVRF -> PraosValidationErr c
VRFLeaderValueTooBig :: Natural -> Rational -> ActiveSlotCoeff -> PraosValidationErr c
KESBeforeStartOCERT :: !KESPeriod -> !KESPeriod -> PraosValidationErr c
KESAfterEndOCERT :: !KESPeriod -> !KESPeriod -> !Word64 -> PraosValidationErr c
CounterTooSmallOCERT :: !Word64 -> !Word64 -> PraosValidationErr c

-- | The KES counter has been incremented by more than 1
CounterOverIncrementedOCERT :: !Word64 -> !Word64 -> PraosValidationErr c
InvalidSignatureOCERT :: !Word64 -> !KESPeriod -> !String -> PraosValidationErr c
InvalidKesSignatureOCERT :: !Word -> !Word -> !Word -> !String -> PraosValidationErr c
NoCounterForKeyHashOCERT :: !KeyHash 'BlockIssuer c -> PraosValidationErr c
data family Ticked st
forgePraosFields :: (PraosCrypto c, KESignable c toSign, Monad m) => HotKey c m -> CanBeLeader (Praos c) -> IsLeader (Praos c) -> (PraosToSign c -> toSign) -> m (PraosFields c toSign)
praosCheckCanForge :: ConsensusConfig (Praos c) -> SlotNo -> KESInfo -> Either (PraosCannotForge c) ()
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosFields c toSign)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosToSign c)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Protocol.Praos.PraosParams
instance GHC.Generics.Generic Ouroboros.Consensus.Protocol.Praos.PraosParams
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Abstract.ConsensusConfig (Ouroboros.Consensus.Protocol.Praos.Praos c))
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosIsLeader c)
instance GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosValidationErr c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Protocol.Praos.PraosCannotForge c)
instance (NoThunks.Class.NoThunks toSign, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.PraosFields c toSign)
instance (GHC.Show.Show toSign, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.PraosFields c toSign)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.PraosToSign c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => GHC.Classes.Eq (Ouroboros.Consensus.Protocol.Praos.PraosValidationErr c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.PraosValidationErr c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.PraosValidationErr c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => GHC.Show.Show (Ouroboros.Consensus.Protocol.Praos.PraosCannotForge c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Protocol.Abstract.ConsensusProtocol (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Codec.Serialise.Class.Serialise (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Protocol.Praos.Common.PraosProtocolSupportsNode (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.PraosIsLeader c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Praos.PraosToSign c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto Cardano.Ledger.Crypto.StandardCrypto
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Protocol.Abstract.ConsensusConfig (Ouroboros.Consensus.Protocol.Praos.Praos c))

module Ouroboros.Consensus.Protocol.Translate

-- | Translate across protocols
class TranslateProto protoFrom protoTo
translateConsensusConfig :: TranslateProto protoFrom protoTo => ConsensusConfig protoFrom -> ConsensusConfig protoTo

-- | Translate the ledger view.
translateLedgerView :: TranslateProto protoFrom protoTo => LedgerView protoFrom -> LedgerView protoTo
translateChainDepState :: TranslateProto protoFrom protoTo => ChainDepState protoFrom -> ChainDepState protoTo
instance Ouroboros.Consensus.Protocol.Translate.TranslateProto singleProto singleProto

module Ouroboros.Consensus.Protocol.Praos.Translate
instance (Cardano.Ledger.Crypto.HASH c1 GHC.Types.~ Cardano.Ledger.Crypto.HASH c2, Cardano.Ledger.Crypto.ADDRHASH c1 GHC.Types.~ Cardano.Ledger.Crypto.ADDRHASH c2, Cardano.Crypto.DSIGN.Class.VerKeyDSIGN c1 GHC.Types.~ Cardano.Crypto.DSIGN.Class.VerKeyDSIGN c2, Cardano.Crypto.VRF.Class.VerKeyVRF c1 GHC.Types.~ Cardano.Crypto.VRF.Class.VerKeyVRF c2) => Ouroboros.Consensus.Protocol.Translate.TranslateProto (Ouroboros.Consensus.Protocol.TPraos.TPraos c1) (Ouroboros.Consensus.Protocol.Praos.Praos c2)
