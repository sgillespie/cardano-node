-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Ouroboros Network Protocols
--   
--   Ouroboros Network Protocols.
@package ouroboros-network-protocols
@version 0.7.0.0

module Ouroboros.Network.Protocol.BlockFetch.Type

-- | Range of blocks, defined by a lower and upper point, inclusive.
data ChainRange point
ChainRange :: !point -> !point -> ChainRange point
data BlockFetch block point
[BFIdle] :: BlockFetch block point
[BFBusy] :: BlockFetch block point
[BFStreaming] :: BlockFetch block point
[BFDone] :: BlockFetch block point
instance GHC.Classes.Ord point => GHC.Classes.Ord (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance GHC.Classes.Eq point => GHC.Classes.Eq (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance GHC.Show.Show point => GHC.Show.Show (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance forall k1 k2 (block :: k1) (point :: k2). Ouroboros.Network.Util.ShowProxy.ShowProxy block => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point)
instance forall k1 k2 (block :: k1) (point :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point)
instance forall block point (from :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point) (to :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). (GHC.Show.Show block, GHC.Show.Show point) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point) from to)
instance forall k1 k2 (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Ouroboros.Network.Protocol.BlockFetch.Server
data BlockFetchServer block point m a
[BlockFetchServer] :: (ChainRange point -> m (BlockFetchBlockSender block point m a)) -> a -> BlockFetchServer block point m a

-- | Send batches of blocks, when a batch is sent loop using
--   <tt><a>BlockFetchServer</a></tt>.
data BlockFetchBlockSender block point m a

-- | Initiate a batch of blocks.
[SendMsgStartBatch] :: m (BlockFetchSendBlocks block point m a) -> BlockFetchBlockSender block point m a
[SendMsgNoBlocks] :: m (BlockFetchServer block point m a) -> BlockFetchBlockSender block point m a

-- | Stream batch of blocks
data BlockFetchSendBlocks block point m a

-- | Send a single block and recurse.
[SendMsgBlock] :: block -> m (BlockFetchSendBlocks block point m a) -> BlockFetchSendBlocks block point m a

-- | End of the stream of block bodies.
[SendMsgBatchDone] :: m (BlockFetchServer block point m a) -> BlockFetchSendBlocks block point m a
blockFetchServerPeer :: forall block point m a. Functor m => BlockFetchServer block point m a -> Peer (BlockFetch block point) AsServer BFIdle m a

module Ouroboros.Network.Protocol.BlockFetch.Codec

-- | Codec for chain sync that encodes/decodes blocks
--   
--   NOTE: See <tt>wrapCBORinCBOR</tt> and <tt>unwrapCBORinCBOR</tt> if you
--   want to use this with a block type that has annotations.
codecBlockFetch :: forall block point m. MonadST m => (block -> Encoding) -> (forall s. Decoder s block) -> (point -> Encoding) -> (forall s. Decoder s point) -> Codec (BlockFetch block point) DeserialiseFailure m ByteString
codecBlockFetchId :: forall block point m. Monad m => Codec (BlockFetch block point) CodecFailure m (AnyMessage (BlockFetch block point))

-- | Byte Limit.
byteLimitsBlockFetch :: forall bytes block point. (bytes -> Word) -> ProtocolSizeLimits (BlockFetch block point) bytes

-- | Time Limits
--   
--   <a>TokIdle</a> No timeout <a>TokBusy</a> <a>longWait</a> timeout
--   <a>TokStreaming</a> <a>longWait</a> timeout
timeLimitsBlockFetch :: forall block point. ProtocolTimeLimits (BlockFetch block point)

module Ouroboros.Network.Protocol.BlockFetch.Client

-- | Block fetch client type for requesting ranges of blocks and handling
--   responses.
newtype BlockFetchClient block point m a
BlockFetchClient :: m (BlockFetchRequest block point m a) -> BlockFetchClient block point m a
[runBlockFetchClient] :: BlockFetchClient block point m a -> m (BlockFetchRequest block point m a)
data BlockFetchRequest block point m a

-- | Request a chain range, supply handler for incoming blocks and a
--   continuation.
[SendMsgRequestRange] :: ChainRange point -> BlockFetchResponse block m a -> BlockFetchClient block point m a -> BlockFetchRequest block point m a

-- | Client terminating the block-fetch protocol.
[SendMsgClientDone] :: a -> BlockFetchRequest block point m a
data BlockFetchResponse block m a
BlockFetchResponse :: m (BlockFetchReceiver block m) -> m () -> BlockFetchResponse block m a
[handleStartBatch] :: BlockFetchResponse block m a -> m (BlockFetchReceiver block m)
[handleNoBlocks] :: BlockFetchResponse block m a -> m ()

-- | Blocks are streamed and block receiver will handle each one when it
--   comes, it also needs to handle errors sent back from the server.
data BlockFetchReceiver block m
BlockFetchReceiver :: (block -> m (BlockFetchReceiver block m)) -> m () -> BlockFetchReceiver block m
[handleBlock] :: BlockFetchReceiver block m -> block -> m (BlockFetchReceiver block m)
[handleBatchDone] :: BlockFetchReceiver block m -> m ()
blockFetchClientPeer :: forall block point m a. Monad m => BlockFetchClient block point m a -> Peer (BlockFetch block point) AsClient BFIdle m a

-- | A BlockFetch client designed for running the protcol in a pipelined
--   way.
data BlockFetchClientPipelined block point m a

-- | A <a>BlockFetchSender</a>, but starting with zero outstanding
--   pipelined responses, and for any internal collect type <tt>c</tt>.
[BlockFetchClientPipelined] :: BlockFetchSender Z c block point m a -> BlockFetchClientPipelined block point m a

-- | A <a>BlockFetchSender</a> with <tt>n</tt> outstanding stream of block
--   bodies.
data BlockFetchSender n c block point m a

-- | Send a <a>MsgRequestRange</a> but do not wait for response. Supply a
--   monadic action which runs on each received block and which updates the
--   internal received value <tt>c</tt>. <tt>c</tt> could be a Monoid,
--   though it's more general this way.
[SendMsgRequestRangePipelined] :: ChainRange point -> c -> (Maybe block -> c -> m c) -> BlockFetchSender (S n) c block point m a -> BlockFetchSender n c block point m a

-- | Collect the result of a previous pipelined receive action
[CollectBlocksPipelined] :: Maybe (BlockFetchSender (S n) c block point m a) -> (c -> BlockFetchSender n c block point m a) -> BlockFetchSender (S n) c block point m a

-- | Termination of the block-fetch protocol.
[SendMsgDonePipelined] :: a -> BlockFetchSender Z c block point m a
blockFetchClientPeerPipelined :: forall block point m a. Monad m => BlockFetchClientPipelined block point m a -> PeerPipelined (BlockFetch block point) AsClient BFIdle m a
blockFetchClientPeerSender :: forall n block point c m a. Monad m => BlockFetchSender n c block point m a -> PeerSender (BlockFetch block point) AsClient BFIdle n c m a

module Ouroboros.Network.Protocol.ChainSync.PipelineDecision

-- | Pipeline decision: we can do either one of these:
--   
--   <ul>
--   <li>non-pipelined request</li>
--   <li>pipeline a request</li>
--   <li>collect or pipeline, but only when there are pipelined
--   requests</li>
--   <li>collect, as above, only when there are pipelined requests</li>
--   </ul>
--   
--   There might be other useful pipelining scenarios: collect a given
--   number of requests (which also can be used to collect all outstanding
--   requests).
data PipelineDecision n
[Request] :: PipelineDecision Z
[Pipeline] :: PipelineDecision n
[CollectOrPipeline] :: PipelineDecision (S n)
[Collect] :: PipelineDecision (S n)

-- | The callback gets the following arguments:
--   
--   <ul>
--   <li>how many requests are not yet collected (in flight or already
--   queued)</li>
--   <li>block number of client's tip</li>
--   <li>block number of server's tip</li>
--   </ul>
--   
--   Client's tip block number and server's tip block number can only be
--   equal (from the client's perspective) when both the client's and the
--   server's tip headers agree. If they would not agree (server forked),
--   then the server sends <tt>MsgRollBackward</tt>, which rolls back one
--   block and causes the client's tip and the server's tip to differ.
--   
--   In this module we implement three pipelining strategies:
--   
--   <ul>
--   <li><a>pipelineDecisionMax</a></li>
--   <li><a>pipelineDecisionMin</a></li>
--   <li><a>pipelineDecisionLowHighMark</a></li>
--   </ul>
data MkPipelineDecision
[MkPipelineDecision] :: (forall n. Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)) -> MkPipelineDecision
runPipelineDecision :: MkPipelineDecision -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)
constantPipelineDecision :: (forall n. Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n) -> MkPipelineDecision

-- | Present maximal pipelining of at most <tt>omax</tt> requests. Collect
--   responses either when we are at the same block number as the server or
--   when we sent more than <tt>omax</tt> requests.
--   
--   If <tt>omax = 3</tt> this pipelining strategy will generate a
--   sequence: <tt> Pipeline Pipeline Pipeline Collect Pipeline Collect
--   .... Pipeline Collect Collect Collect </tt>
pipelineDecisionMax :: Word16 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Present minimum pipelining of at most <tt>omax</tt> requests, collect
--   responses eagerly.
pipelineDecisionMin :: Word16 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Pipelining strategy which pipelines up to <tt>highMark</tt> requests;
--   if the number of pipelined messages exceeds the high mark, it collects
--   messages until there are at most <tt>lowMark</tt> outstanding
--   requests.
pipelineDecisionLowHighMark :: Word16 -> Word16 -> MkPipelineDecision


-- | The type of the chain synchronisation protocol.
--   
--   Since we are using a typed protocol framework this is in some sense
--   <i>the</i> definition of the protocol: what is allowed and what is not
--   allowed.
module Ouroboros.Network.Protocol.ChainSync.Type

-- | A kind to identify our protocol, and the types of the states in the
--   state transition diagram of the protocol.
data ChainSync header point tip

-- | Both client and server are idle. The client can send a request and the
--   server is waiting for a request.
[StIdle] :: ChainSync header point tip

-- | The client has sent a next update request. The client is now waiting
--   for a response, and the server is busy getting ready to send a
--   response. There are two possibilities here, since the server can send
--   a reply immediately or it can send an initial await message followed
--   later by the normal reply.
[StNext] :: StNextKind -> ChainSync header point tip

-- | The client has sent an intersection request. The client is now waiting
--   for a response, and the server is busy getting ready to send a
--   response.
[StIntersect] :: ChainSync header point tip

-- | Both the client and server are in the terminal state. They're done.
[StDone] :: ChainSync header point tip

-- | Sub-cases of the <a>StNext</a> state. This is needed since the server
--   can either send one reply back, or two.
data StNextKind

-- | The server can reply or send an await msg.
[StCanAwait] :: StNextKind

-- | The server must now reply, having already sent an await message.
[StMustReply] :: StNextKind
data TokNextKind (k :: StNextKind)
[TokCanAwait] :: TokNextKind StCanAwait
[TokMustReply] :: TokNextKind StMustReply
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip)
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3) (st :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance forall k1 k2 k3 (header :: k1) (tip :: k2) (point :: k3). (Ouroboros.Network.Util.ShowProxy.ShowProxy header, Ouroboros.Network.Util.ShowProxy.ShowProxy tip) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip)
instance forall header point tip (from :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip) (to :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). (GHC.Show.Show header, GHC.Show.Show point, GHC.Show.Show tip) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip) from to)
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3) (st :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)


-- | A view of the chain synchronisation protocol from the point of view of
--   the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.ChainSync.Server

-- | A chain sync protocol server, on top of some effect <tt>m</tt>.
newtype ChainSyncServer header point tip m a
ChainSyncServer :: m (ServerStIdle header point tip m a) -> ChainSyncServer header point tip m a
[runChainSyncServer] :: ChainSyncServer header point tip m a -> m (ServerStIdle header point tip m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a next update request</li>
--   <li>a find intersection request</li>
--   <li>a termination messge</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStIdle header point tip m a
ServerStIdle :: m (Either (ServerStNext header point tip m a) (m (ServerStNext header point tip m a))) -> ([point] -> m (ServerStIntersect header point tip m a)) -> m a -> ServerStIdle header point tip m a
[recvMsgRequestNext] :: ServerStIdle header point tip m a -> m (Either (ServerStNext header point tip m a) (m (ServerStNext header point tip m a)))
[recvMsgFindIntersect] :: ServerStIdle header point tip m a -> [point] -> m (ServerStIntersect header point tip m a)
[recvMsgDoneClient] :: ServerStIdle header point tip m a -> m a

-- | In the <a>StNext</a> protocol state, the server has agency and must
--   send either:
--   
--   <ul>
--   <li>a roll forward</li>
--   <li>a roll back message</li>
--   <li>a termination message</li>
--   </ul>
data ServerStNext header point tip m a
[SendMsgRollForward] :: header -> tip -> ChainSyncServer header point tip m a -> ServerStNext header point tip m a
[SendMsgRollBackward] :: point -> tip -> ChainSyncServer header point tip m a -> ServerStNext header point tip m a

-- | In the <a>StIntersect</a> protocol state, the server has agency and
--   must send either:
--   
--   <ul>
--   <li>an intersection improved,</li>
--   <li>unchanged message,</li>
--   <li>termination message</li>
--   </ul>
data ServerStIntersect header point tip m a
[SendMsgIntersectFound] :: point -> tip -> ChainSyncServer header point tip m a -> ServerStIntersect header point tip m a
[SendMsgIntersectNotFound] :: tip -> ChainSyncServer header point tip m a -> ServerStIntersect header point tip m a

-- | Interpret a <a>ChainSyncServer</a> action sequence as a <a>Peer</a> on
--   the server side of the <tt>ChainSyncProtocol</tt>.
chainSyncServerPeer :: forall header point tip m a. Monad m => ChainSyncServer header point tip m a -> Peer (ChainSync header point tip) AsServer StIdle m a

module Ouroboros.Network.Protocol.ChainSync.Codec

-- | Codec for chain sync that encodes/decodes headers
--   
--   NOTE: See <tt>wrapCBORinCBOR</tt> and <tt>unwrapCBORinCBOR</tt> if you
--   want to use this with a header type that has annotations.
codecChainSync :: forall header point tip m. MonadST m => (header -> Encoding) -> (forall s. Decoder s header) -> (point -> Encoding) -> (forall s. Decoder s point) -> (tip -> Encoding) -> (forall s. Decoder s tip) -> Codec (ChainSync header point tip) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>ChainSync</a> protocol. It does
--   not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecChainSyncId :: forall header point tip m. Monad m => Codec (ChainSync header point tip) CodecFailure m (AnyMessage (ChainSync header point tip))

-- | Byte Limits
byteLimitsChainSync :: forall bytes header point tip. (bytes -> Word) -> ProtocolSizeLimits (ChainSync header point tip) bytes

-- | Time Limits
--   
--   <pre>
--   'TokIdle'               'waitForever' (ie never times out)
--   'TokNext TokCanAwait'   the given 'canAwaitTimeout'
--   'TokNext TokMustReply'  the given 'mustReplyTimeout'
--   'TokIntersect'          the given 'intersectTimeout'
--   </pre>
timeLimitsChainSync :: forall header point tip. ChainSyncTimeout -> ProtocolTimeLimits (ChainSync header point tip)

-- | Configurable timeouts
--   
--   These are configurable for at least the following reasons.
--   
--   o So that deployment and testing can use different values.
--   
--   o So that a net running Praos can better cope with streaks of empty
--   slots. (See <tt>intersectmbo/ouroboros-network#2245</tt>.)
data ChainSyncTimeout
ChainSyncTimeout :: Maybe DiffTime -> Maybe DiffTime -> Maybe DiffTime -> Maybe DiffTime -> ChainSyncTimeout
[canAwaitTimeout] :: ChainSyncTimeout -> Maybe DiffTime
[intersectTimeout] :: ChainSyncTimeout -> Maybe DiffTime
[mustReplyTimeout] :: ChainSyncTimeout -> Maybe DiffTime
[idleTimeout] :: ChainSyncTimeout -> Maybe DiffTime

module Ouroboros.Network.Protocol.ChainSync.ClientPipelined

-- | Pipelined chain sync client. It can only pipeline
--   <a>MsgRequestNext</a> messages, while the <a>MsgFindIntersect</a> are
--   non pipelined. This has a penalty cost of an RTT, but they are sent
--   relatively seldom and their response might impact how many messages
--   one would like to pipeline. It also simplifies the receiver callback.
newtype ChainSyncClientPipelined header point tip m a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle Z header point tip m a) -> ChainSyncClientPipelined header point tip m a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip m a -> m (ClientPipelinedStIdle Z header point tip m a)

-- | Pipelined sender which starts in <a>StIdle</a> state. It can either
--   
--   <ul>
--   <li>Send <a>MsgRequestNext</a> (no pipelining), which might be useful
--   when we are at the tip of the chain. It can only be send when there is
--   no pipelined message in flight (all responses were collected);</li>
--   <li>Pipeline <a>MsgRequestNext</a>;</li>
--   <li>Send <a>MsgFindIntersect</a> (no pipelining); It can only be send
--   when there is no pipelined message in flight (all responses were
--   collected);</li>
--   <li>Collect responses of pipelined message;</li>
--   <li>Terminate the protocol with by sending <a>MsgDone</a>.</li>
--   </ul>
data ClientPipelinedStIdle n header point tip m a
[SendMsgRequestNext] :: ClientStNext Z header point tip m a -> m (ClientStNext Z header point tip m a) -> ClientPipelinedStIdle Z header point tip m a
[SendMsgRequestNextPipelined] :: ClientPipelinedStIdle (S n) header point tip m a -> ClientPipelinedStIdle n header point tip m a
[SendMsgFindIntersect] :: [point] -> ClientPipelinedStIntersect header point tip m a -> ClientPipelinedStIdle Z header point tip m a
[CollectResponse] :: Maybe (m (ClientPipelinedStIdle (S n) header point tip m a)) -> ClientStNext n header point tip m a -> ClientPipelinedStIdle (S n) header point tip m a
[SendMsgDone] :: a -> ClientPipelinedStIdle Z header point tip m a

-- | Callback for responses received after sending <a>MsgRequestNext</a>.
--   
--   We could receive <a>MsgAwaitReply</a>. In this case we will wait for
--   the next message which must be <a>MsgRollForward</a> or
--   <a>MsgRollBackward</a>; thus we need only the two callbacks.
data ClientStNext n header point tip m a
ClientStNext :: (header -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> (point -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> ClientStNext n header point tip m a

-- | Callback for <a>MsgRollForward</a> message.
[recvMsgRollForward] :: ClientStNext n header point tip m a -> header -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callback for <a>MsgRollBackward</a> message.
[recvMsgRollBackward] :: ClientStNext n header point tip m a -> point -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callbacks for messages received after sending <a>MsgFindIntersect</a>.
--   
--   We might receive either <a>MsgIntersectFound</a> or
--   <a>MsgIntersectNotFound</a>.
data ClientPipelinedStIntersect header point tip m a
ClientPipelinedStIntersect :: (point -> tip -> m (ClientPipelinedStIdle Z header point tip m a)) -> (tip -> m (ClientPipelinedStIdle Z header point tip m a)) -> ClientPipelinedStIntersect header point tip m a
[recvMsgIntersectFound] :: ClientPipelinedStIntersect header point tip m a -> point -> tip -> m (ClientPipelinedStIdle Z header point tip m a)
[recvMsgIntersectNotFound] :: ClientPipelinedStIntersect header point tip m a -> tip -> m (ClientPipelinedStIdle Z header point tip m a)

-- | Data received through pipelining: either roll forward or roll backward
--   instruction. If the server replied with <a>MsgAwaitReply</a> the
--   pipelined receiver will await for the next message which must come
--   with an instruction how to update our chain.
--   
--   Note: internal API, not exposed by this module.
data ChainSyncInstruction header point tip
RollForward :: !header -> !tip -> ChainSyncInstruction header point tip
RollBackward :: !point -> !tip -> ChainSyncInstruction header point tip
chainSyncClientPeerPipelined :: forall header point tip m a. Monad m => ChainSyncClientPipelined header point tip m a -> PeerPipelined (ChainSync header point tip) AsClient StIdle m a
chainSyncClientPeerSender :: forall n header point tip m a. Monad m => Nat n -> ClientPipelinedStIdle n header point tip m a -> PeerSender (ChainSync header point tip) AsClient StIdle n (ChainSyncInstruction header point tip) m a

-- | Transform a <a>ChainSyncClientPipelined</a> by mapping over the tx
--   header and the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClientPipelined :: forall header header' point point' tip tip' (m :: Type -> Type) a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClientPipelined header point tip m a -> ChainSyncClientPipelined header' point' tip' m a


-- | A view of the chain synchronisation protocol from the point of view of
--   the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.ChainSync.Client

-- | A chain sync protocol client, on top of some effect <tt>m</tt>. The
--   first choice of request is within that <tt>m</tt>.
newtype ChainSyncClient header point tip m a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip m a
[runChainSyncClient] :: ChainSyncClient header point tip m a -> m (ClientStIdle header point tip m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency
--   and can choose to send a request next, or a find intersection message.
data ClientStIdle header point tip m a

-- | Send the <a>MsgRequestNext</a>, with handlers for the replies.
--   
--   The handlers for this message are more complicated than most RPCs
--   because the server can either send us a reply immediately or it can
--   send us a <a>MsgAwaitReply</a> to indicate that the server itself has
--   to block for a state change before it can send us the reply.
--   
--   In the waiting case, the client gets the chance to take a local
--   action.
[SendMsgRequestNext] :: ClientStNext header point tip m a -> m (ClientStNext header point tip m a) -> ClientStIdle header point tip m a

-- | Send the <a>MsgFindIntersect</a>, with handlers for the replies.
[SendMsgFindIntersect] :: [point] -> ClientStIntersect header point tip m a -> ClientStIdle header point tip m a

-- | The client decided to end the protocol.
[SendMsgDone] :: a -> ClientStIdle header point tip m a

-- | In the <a>StNext</a> protocol state, the client does not have agency
--   and is waiting to receive either
--   
--   <ul>
--   <li>a roll forward,</li>
--   <li>roll back message,</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStNext header point tip m a
ClientStNext :: (header -> tip -> ChainSyncClient header point tip m a) -> (point -> tip -> ChainSyncClient header point tip m a) -> ClientStNext header point tip m a
[recvMsgRollForward] :: ClientStNext header point tip m a -> header -> tip -> ChainSyncClient header point tip m a
[recvMsgRollBackward] :: ClientStNext header point tip m a -> point -> tip -> ChainSyncClient header point tip m a

-- | In the <a>StIntersect</a> protocol state, the client does not have
--   agency and is waiting to receive:
--   
--   <ul>
--   <li>an intersection improved,</li>
--   <li>unchanged message,</li>
--   <li>the termination message.</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStIntersect header point tip m a
ClientStIntersect :: (point -> tip -> ChainSyncClient header point tip m a) -> (tip -> ChainSyncClient header point tip m a) -> ClientStIntersect header point tip m a
[recvMsgIntersectFound] :: ClientStIntersect header point tip m a -> point -> tip -> ChainSyncClient header point tip m a
[recvMsgIntersectNotFound] :: ClientStIntersect header point tip m a -> tip -> ChainSyncClient header point tip m a

-- | Interpret a <a>ChainSyncClient</a> action sequence as a <a>Peer</a> on
--   the client side of the <tt>ChainSyncProtocol</tt>.
chainSyncClientPeer :: forall header point tip m a. Monad m => ChainSyncClient header point tip m a -> Peer (ChainSync header point tip) AsClient StIdle m a

-- | A chain sync client which never sends any message.

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.chainSyncPeerNull</i>
chainSyncClientNull :: MonadTimer m => ChainSyncClient header point tip m a

-- | Transform a <a>ChainSyncClient</a> by mapping over the tx header and
--   the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClient :: forall header header' point point' tip tip' m a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClient header point tip m a -> ChainSyncClient header' point' tip' m a


-- | The type of the keep alive protocol.
--   
--   The keep alive protocol is used for
--   
--   <ul>
--   <li>sending keep alive messages</li>
--   <li>making round trip measuremnets</li>
--   </ul>
--   
--   Each side will run its own version of the keep alive protocol. It
--   should be configured so that any intermediate state (such as in
--   customer premise equipment or in a carrier grade NAT) is kept alive.
--   This has to be a per-node configuration element as this is about the
--   properties of that nodes network connectivity.
--   
--   For making round trip measurements its in the interest of the other
--   side to reply promptly.
module Ouroboros.Network.Protocol.KeepAlive.Type

-- | A 16bit value used to match responses to requests.
newtype Cookie
Cookie :: Word16 -> Cookie
[unCookie] :: Cookie -> Word16
data KeepAliveProtocolFailure
KeepAliveCookieMissmatch :: Cookie -> Cookie -> KeepAliveProtocolFailure

-- | A kind to identify our protocol, and the types of the states in the
--   state transition diagram of the protocol.
data KeepAlive

-- | The client can send a request and the server is waiting for a request.
[StClient] :: KeepAlive

-- | The server is responsible for sending response back.
[StServer] :: KeepAlive

-- | Both the client and server are in the terminal state. They're done.
[StDone] :: KeepAlive
instance GHC.Show.Show Ouroboros.Network.Protocol.KeepAlive.Type.Cookie
instance GHC.Classes.Eq Ouroboros.Network.Protocol.KeepAlive.Type.Cookie
instance GHC.Show.Show Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure
instance GHC.Classes.Eq Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive
instance Network.TypedProtocol.Core.Protocol Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive
instance GHC.Show.Show (Network.TypedProtocol.Core.Message Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive from to)
instance GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance GHC.Exception.Type.Exception Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure

module Ouroboros.Network.Protocol.KeepAlive.Server
data KeepAliveServer m a
KeepAliveServer :: m (KeepAliveServer m a) -> m a -> KeepAliveServer m a
[recvMsgKeepAlive] :: KeepAliveServer m a -> m (KeepAliveServer m a)
[recvMsgDone] :: KeepAliveServer m a -> m a
keepAliveServerPeer :: Functor m => KeepAliveServer m a -> Peer KeepAlive AsServer StClient m a

module Ouroboros.Network.Protocol.KeepAlive.Codec
codecKeepAlive_v2 :: forall m. MonadST m => Codec KeepAlive DeserialiseFailure m ByteString
codecKeepAliveId :: forall m. Monad m => Codec KeepAlive CodecFailure m (AnyMessage KeepAlive)
byteLimitsKeepAlive :: (bytes -> Word) -> ProtocolSizeLimits KeepAlive bytes
timeLimitsKeepAlive :: ProtocolTimeLimits KeepAlive

module Ouroboros.Network.Protocol.KeepAlive.Client
newtype KeepAliveClient m a
KeepAliveClient :: m (KeepAliveClientSt m a) -> KeepAliveClient m a
data KeepAliveClientSt m a
[SendMsgKeepAlive] :: Cookie -> m (KeepAliveClientSt m a) -> KeepAliveClientSt m a
[SendMsgDone] :: m a -> KeepAliveClientSt m a

-- | Interpret a particular client action sequence into the client side of
--   the <a>KeepAlive</a> protocol.
keepAliveClientPeer :: forall m a. MonadThrow m => KeepAliveClient m a -> Peer KeepAlive AsClient StClient m a


-- | The type of the local ledger state query protocol.
--   
--   This is used by local clients (like wallets and CLI tools) to query
--   the ledger state of a local node.
module Ouroboros.Network.Protocol.LocalStateQuery.Type

-- | The kind of the local state query protocol, and the types of the
--   states in the protocol state machine.
--   
--   It is parametrised over the type of block (for points), the type of
--   queries and query results.
data LocalStateQuery block point (query :: Type -> Type)

-- | The client has agency. It can ask to acquire a state or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalStateQuery block point query

-- | The server has agency. it must acquire the state at the requested
--   point or report a failure.
--   
--   There is a timeout in this state.
[StAcquiring] :: LocalStateQuery block point query

-- | The client has agency. It can request queries against the current
--   state, or it can release the state.
[StAcquired] :: LocalStateQuery block point query

-- | The server has agency. It must respond with the query result.
[StQuerying] :: result -> LocalStateQuery block point query

-- | Nobody has agency. The terminal state.
[StDone] :: LocalStateQuery block point query
data Target point

-- | The tip of the volatile chain
--   
--   Cannot fail to be acquired.
VolatileTip :: Target point

-- | A specified point
--   
--   Fails to be acquired if the point is not between <a>VolatileTip</a>
--   and <a>ImmutableTip</a> (inclusive).
SpecificPoint :: point -> Target point

-- | The tip of the immutable chain
--   
--   Cannot fail to be acquired.
--   
--   Requires at least <tt>NodeToClientV_16</tt>.
ImmutableTip :: Target point
data AcquireFailure
AcquireFailurePointTooOld :: AcquireFailure
AcquireFailurePointNotOnChain :: AcquireFailure

-- | To implement <a>Show</a> for:
--   
--   <pre>
--   ('Message' ('LocalStateQuery' block query) st st')
--   </pre>
--   
--   we need a way to print the <tt>query</tt> GADT and its type index,
--   <tt>result</tt>. This class contain the method we need to provide this
--   <a>Show</a> instance.
--   
--   We use a type class for this, as this <a>Show</a> constraint
--   propagates to a lot of places.
class (forall result. Show (query result)) => ShowQuery query
showResult :: forall result. ShowQuery query => query result -> result -> String
instance Data.Traversable.Traversable Ouroboros.Network.Protocol.LocalStateQuery.Type.Target
instance GHC.Show.Show point => GHC.Show.Show (Ouroboros.Network.Protocol.LocalStateQuery.Type.Target point)
instance GHC.Classes.Ord point => GHC.Classes.Ord (Ouroboros.Network.Protocol.LocalStateQuery.Type.Target point)
instance GHC.Generics.Generic (Ouroboros.Network.Protocol.LocalStateQuery.Type.Target point)
instance GHC.Base.Functor Ouroboros.Network.Protocol.LocalStateQuery.Type.Target
instance Data.Foldable.Foldable Ouroboros.Network.Protocol.LocalStateQuery.Type.Target
instance GHC.Classes.Eq point => GHC.Classes.Eq (Ouroboros.Network.Protocol.LocalStateQuery.Type.Target point)
instance GHC.Show.Show Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance GHC.Enum.Enum Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance GHC.Classes.Eq Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance forall k (query :: * -> *) point (block :: k) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query) (st' :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). (Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery query, GHC.Show.Show point) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query) st st')
instance forall k1 k2 (block :: k1) (point :: k2) (query :: * -> *). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query)
instance forall k1 k2 (block :: k1) (query :: * -> *) (point :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy block, Ouroboros.Network.Util.ShowProxy.ShowProxy query) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query)
instance forall k1 k2 (block :: k1) (point :: k2) (query :: * -> *) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (query :: * -> *) (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). (forall result. GHC.Show.Show (query result)) => GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Ouroboros.Network.Protocol.LocalStateQuery.Server
newtype LocalStateQueryServer block point (query :: Type -> Type) m a
LocalStateQueryServer :: m (ServerStIdle block point query m a) -> LocalStateQueryServer block point (query :: Type -> Type) m a
[runLocalStateQueryServer] :: LocalStateQueryServer block point (query :: Type -> Type) m a -> m (ServerStIdle block point query m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a request to acquire a state</li>
--   <li>a termination messge</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStIdle block point query m a
ServerStIdle :: (Target point -> m (ServerStAcquiring block point query m a)) -> m a -> ServerStIdle block point query m a
[recvMsgAcquire] :: ServerStIdle block point query m a -> Target point -> m (ServerStAcquiring block point query m a)
[recvMsgDone] :: ServerStIdle block point query m a -> m a

-- | In the <a>StAcquiring</a> protocol state, the server has agency and
--   must send either:
--   
--   <ul>
--   <li>acquired</li>
--   <li>failure to acquire</li>
--   </ul>
data ServerStAcquiring block point query m a
[SendMsgAcquired] :: ServerStAcquired block point query m a -> ServerStAcquiring block point query m a
[SendMsgFailure] :: AcquireFailure -> ServerStIdle block point query m a -> ServerStAcquiring block point query m a

-- | In the <a>StAcquired</a> protocol state, the server does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>a query</li>
--   <li>a request to (re)acquire another state</li>
--   <li>a release of the current state</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStAcquired block point query m a
ServerStAcquired :: (forall result. query result -> m (ServerStQuerying block point query m a result)) -> (Target point -> m (ServerStAcquiring block point query m a)) -> m (ServerStIdle block point query m a) -> ServerStAcquired block point query m a
[recvMsgQuery] :: ServerStAcquired block point query m a -> forall result. query result -> m (ServerStQuerying block point query m a result)
[recvMsgReAcquire] :: ServerStAcquired block point query m a -> Target point -> m (ServerStAcquiring block point query m a)
[recvMsgRelease] :: ServerStAcquired block point query m a -> m (ServerStIdle block point query m a)

-- | In the <a>StQuerying</a> protocol state, the server has agency and
--   must send:
--   
--   <ul>
--   <li>a result</li>
--   </ul>
data ServerStQuerying block point query m a result
[SendMsgResult] :: result -> ServerStAcquired block point query m a -> ServerStQuerying block point query m a result

-- | Interpret a <a>LocalStateQueryServer</a> action sequence as a
--   <a>Peer</a> on the server side of the <a>LocalStateQuery</a> protocol.
localStateQueryServerPeer :: forall block point (query :: Type -> Type) m a. Monad m => LocalStateQueryServer block point query m a -> Peer (LocalStateQuery block point query) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalStateQuery.Codec
codecLocalStateQuery :: forall block point query m. (MonadST m, ShowQuery query) => NodeToClientVersion -> (point -> Encoding) -> (forall s. Decoder s point) -> (forall result. query result -> Encoding) -> (forall s. Decoder s (Some query)) -> (forall result. query result -> result -> Encoding) -> (forall result. query result -> forall s. Decoder s result) -> Codec (LocalStateQuery block point query) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>LocalStateQuery</a> protocol. It
--   does not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecLocalStateQueryId :: forall block point (query :: Type -> Type) m. Monad m => (forall result1 result2. query result1 -> query result2 -> Maybe (result1 :~: result2)) -> Codec (LocalStateQuery block point query) CodecFailure m (AnyMessage (LocalStateQuery block point query))
data Some (f :: k -> Type)
[Some] :: f a -> Some f

module Ouroboros.Network.Protocol.LocalStateQuery.Client
newtype LocalStateQueryClient block point (query :: Type -> Type) m a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) m a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) m a -> m (ClientStIdle block point query m a)

-- | In the <a>StIdle</a> protocol state, the client has agency and must
--   send:
--   
--   <ul>
--   <li>a request to acquire a state</li>
--   <li>a termination messge</li>
--   </ul>
data ClientStIdle block point query (m :: Type -> Type) a
[SendMsgAcquire] :: Target point -> ClientStAcquiring block point query m a -> ClientStIdle block point query m a
[SendMsgDone] :: a -> ClientStIdle block point query m a

-- | In the <a>StAcquiring</a> protocol state, the client does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>acquired</li>
--   <li>failure to acquire</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ClientStAcquiring block point query m a
ClientStAcquiring :: m (ClientStAcquired block point query m a) -> (AcquireFailure -> m (ClientStIdle block point query m a)) -> ClientStAcquiring block point query m a
[recvMsgAcquired] :: ClientStAcquiring block point query m a -> m (ClientStAcquired block point query m a)
[recvMsgFailure] :: ClientStAcquiring block point query m a -> AcquireFailure -> m (ClientStIdle block point query m a)

-- | In the <a>StAcquired</a> protocol state, the client has agency and
--   must send:
--   
--   <ul>
--   <li>a query</li>
--   <li>a request to (re)acquire another state</li>
--   <li>a release of the current state</li>
--   </ul>
data ClientStAcquired block point query m a
[SendMsgQuery] :: query result -> ClientStQuerying block point query m a result -> ClientStAcquired block point query m a
[SendMsgReAcquire] :: Target point -> ClientStAcquiring block point query m a -> ClientStAcquired block point query m a
[SendMsgRelease] :: m (ClientStIdle block point query m a) -> ClientStAcquired block point query m a

-- | In the <a>StQuerying</a> protocol state, the client does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>a result</li>
--   </ul>
data ClientStQuerying block point query m a result
ClientStQuerying :: (result -> m (ClientStAcquired block point query m a)) -> ClientStQuerying block point query m a result
[recvMsgResult] :: ClientStQuerying block point query m a result -> result -> m (ClientStAcquired block point query m a)

-- | Interpret a <a>LocalStateQueryClient</a> action sequence as a
--   <a>Peer</a> on the client side of the <a>LocalStateQuery</a> protocol.
localStateQueryClientPeer :: forall block point (query :: Type -> Type) m a. Monad m => LocalStateQueryClient block point query m a -> Peer (LocalStateQuery block point query) AsClient StIdle m a

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.localStateQueryPeerNull</i>
localStateQueryClientNull :: MonadTimer m => LocalStateQueryClient block point query m a

-- | Transform a <a>LocalStateQueryClient</a> by mapping over the query and
--   query result values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs.
mapLocalStateQueryClient :: forall block block' point point' query query' m a. Functor m => (point -> point') -> (forall result. query result -> Some query') -> (forall result result'. query result -> query' result' -> result' -> result) -> LocalStateQueryClient block point query m a -> LocalStateQueryClient block' point' query' m a
data Some (f :: k -> Type)
[Some] :: f a -> Some f


-- | The type of the local transaction monitoring protocol.
--   
--   This is used by local clients (like wallets, explorers and CLI tools)
--   to monitor the transactions passing through the mempool of a local
--   node.
--   
--   The protocol is stateful such that the server keeps track of the
--   transactions already sent to the client.
--   
--   <pre>
--                     START
--                       ⇓
--                     ┌───────────────┐
--             ┌──────▶│     Idle      │⇒ DONE
--             │       └───┬───────────┘
--             │           │
--             │   Acquire │
--             │           ▼
--             │       ┌───────────────┐
--     Release │       │   Acquiring   │
--             │       └───┬───────────┘
--             │           │       ▲
--             │  Acquired │       │ AwaitAcquire
--             │           ▼       │
--             │       ┌───────────┴───┐
--             └───────┤   Acquired    │
--                     └───┬───────────┘
--                         │       ▲
--   HasTx|NextTx|GetSizes │       │ Reply (HasTx|NextTx|GetSizes)
--                         ▼       │
--                     ┌───────────┴───┐
--                     │      Busy     │
--                     └───────────────┘
--   </pre>
module Ouroboros.Network.Protocol.LocalTxMonitor.Type

-- | The kind of the local transaction monitoring protocol, and the types
--   of the states in the protocol state machine.
--   
--   It is parametrised over the type of transactions.
data LocalTxMonitor txid tx slot

-- | The client has agency; it can request a transaction or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalTxMonitor txid tx slot

-- | The server has agency; it is capturing the latest mempool snapshot.
[StAcquiring] :: LocalTxMonitor txid tx slot

-- | The client has agency; The server is locked on a particular mempool
--   snapshot. The client can now perform various requests on that
--   snapshot, or acquire a new one, more recent.
[StAcquired] :: LocalTxMonitor txid tx slot

-- | The server has agency; It must respond, there's no timeout.
[StBusy] :: StBusyKind -> LocalTxMonitor txid tx slot

-- | Nobody has agency. The terminal state.
[StDone] :: LocalTxMonitor txid tx slot
data StBusyKind

-- | The server is busy fetching the next transaction from the mempool
[NextTx] :: StBusyKind

-- | The server is busy looking for the presence of a specific transaction
--   in the mempool
[HasTx] :: StBusyKind

-- | The server is busy looking for the current size and max capacity of
--   the mempool
[GetSizes] :: StBusyKind

-- | Describes the MemPool sizes and capacity for a given snapshot.
data MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity

-- | The maximum capacity of the mempool. Note that this may dynamically
--   change when the ledger state is updated.
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The summed byte size of all the transactions in the mempool.
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The number of transactions in the mempool
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
data TokBusyKind (k :: StBusyKind)
[TokNextTx] :: TokBusyKind NextTx
[TokHasTx] :: TokBusyKind HasTx
[TokGetSizes] :: TokBusyKind GetSizes
instance GHC.Show.Show Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance GHC.Classes.Eq Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance GHC.Generics.Generic Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance forall txid tx slot (from :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot) (to :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). (GHC.Show.Show txid, GHC.Show.Show tx, GHC.Show.Show slot) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot) from to)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3) (st :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3). (Ouroboros.Network.Util.ShowProxy.ShowProxy txid, Ouroboros.Network.Util.ShowProxy.ShowProxy tx, Ouroboros.Network.Util.ShowProxy.ShowProxy slot) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3) (st :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)


-- | A view of the transaction monitor protocol from the point of view of
--   the server.
--   
--   This provides simple access to the local mempool snapshots, to allow
--   building more monitoring logic from the client side after submitting
--   transactions.
--   
--   For execution, <a>localTxMonitorServerPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxMonitor.Server

-- | A local tx monitor protocol server, on top of some effect <tt>m</tt>.
newtype LocalTxMonitorServer txid tx slot m a
LocalTxMonitorServer :: m (ServerStIdle txid tx slot m a) -> LocalTxMonitorServer txid tx slot m a
[runLocalTxMonitorServer] :: LocalTxMonitorServer txid tx slot m a -> m (ServerStIdle txid tx slot m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead, it is waiting for:
--   
--   <ul>
--   <li>an acquire request,</li>
--   <li>a termination message.</li>
--   </ul>
data ServerStIdle txid tx slot m a
ServerStIdle :: m (ServerStAcquiring txid tx slot m a) -> m a -> ServerStIdle txid tx slot m a
[recvMsgAcquire] :: ServerStIdle txid tx slot m a -> m (ServerStAcquiring txid tx slot m a)
[recvMsgDone] :: ServerStIdle txid tx slot m a -> m a

-- | In the <a>StAcquiring</a> protocol state, the server has agency and
--   must acquire, and hold on to, the current / latest snapshot of its
--   mempool.
data ServerStAcquiring txid tx slot m a
[SendMsgAcquired] :: slot -> ServerStAcquired txid tx slot m a -> ServerStAcquiring txid tx slot m a

-- | In the <a>StAcquired</a> protocol state, the server does not have
--   agency and is waiting for a client to either:
--   
--   <ul>
--   <li>request the next transaction from the snapshot;</li>
--   <li>check the presence of a given transaction, by its id;</li>
--   <li>await a change in the snapshot and acquire it;</li>
--   <li>release and go back to the <a>StIdle</a> state;</li>
--   </ul>
data ServerStAcquired txid tx slot m a
ServerStAcquired :: m (ServerStBusy NextTx txid tx slot m a) -> (txid -> m (ServerStBusy HasTx txid tx slot m a)) -> m (ServerStBusy GetSizes txid tx slot m a) -> m (ServerStAcquiring txid tx slot m a) -> m (ServerStIdle txid tx slot m a) -> ServerStAcquired txid tx slot m a
[recvMsgNextTx] :: ServerStAcquired txid tx slot m a -> m (ServerStBusy NextTx txid tx slot m a)
[recvMsgHasTx] :: ServerStAcquired txid tx slot m a -> txid -> m (ServerStBusy HasTx txid tx slot m a)
[recvMsgGetSizes] :: ServerStAcquired txid tx slot m a -> m (ServerStBusy GetSizes txid tx slot m a)
[recvMsgAwaitAcquire] :: ServerStAcquired txid tx slot m a -> m (ServerStAcquiring txid tx slot m a)
[recvMsgRelease] :: ServerStAcquired txid tx slot m a -> m (ServerStIdle txid tx slot m a)
data ServerStBusy (kind :: StBusyKind) txid tx slot m a
[SendMsgReplyNextTx] :: Maybe tx -> ServerStAcquired txid tx slot m a -> ServerStBusy NextTx txid tx slot m a
[SendMsgReplyHasTx] :: Bool -> ServerStAcquired txid tx slot m a -> ServerStBusy HasTx txid tx slot m a
[SendMsgReplyGetSizes] :: MempoolSizeAndCapacity -> ServerStAcquired txid tx slot m a -> ServerStBusy GetSizes txid tx slot m a

-- | Interpret a <a>LocalTxMonitorServer</a> action sequence as a
--   <a>Peer</a> on the client-side of the <a>LocalTxMonitor</a> protocol.
localTxMonitorServerPeer :: forall txid tx slot m a. Monad m => LocalTxMonitorServer txid tx slot m a -> Peer (LocalTxMonitor txid tx slot) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalTxMonitor.Codec
codecLocalTxMonitor :: forall txid tx slot m ptcl. (MonadST m, ptcl ~ LocalTxMonitor txid tx slot) => (txid -> Encoding) -> (forall s. Decoder s txid) -> (tx -> Encoding) -> (forall s. Decoder s tx) -> (slot -> Encoding) -> (forall s. Decoder s slot) -> Codec (LocalTxMonitor txid tx slot) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>LocalTxMonitor</a> protocol. It
--   does not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecLocalTxMonitorId :: forall txid tx slot m ptcl. (Monad m, ptcl ~ LocalTxMonitor txid tx slot) => Codec ptcl CodecFailure m (AnyMessage ptcl)


-- | A view of the transaction monitor protocol from the point of view of
--   the client.
--   
--   This provides simple access to the local mempool snapshots, to allow
--   building more monitoring logic from the client side after submitting
--   transactions.
--   
--   For execution, <a>localTxMonitorClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxMonitor.Client

-- | A tx monitor client, on top of some effect <tt>m</tt>.
newtype LocalTxMonitorClient txid tx slot m a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot m a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot m a -> m (ClientStIdle txid tx slot m a)

-- | In the <a>StIdle</a> protocol state, the client has agency and can
--   proceed to acquire a mempool snapshot, or end the protocol.
data ClientStIdle txid tx slot m a

-- | Send the <a>MsgAcquire</a>, with handlers for the replies.
--   
--   This request cannot timeout and cannot fail, it'll acquire the latest
--   mempool snapshot available on the server and hang on to it. This
--   allows to run any subsequent queries against the same view of the
--   mempool.
--   
--   The snapshot is acquired for a particular slot number which
--   materializes the 'virtual block' under construction.
[SendMsgAcquire] :: (slot -> m (ClientStAcquired txid tx slot m a)) -> ClientStIdle txid tx slot m a

-- | The client decided to end the protocol
[SendMsgDone] :: a -> ClientStIdle txid tx slot m a

-- | In the <a>StAcquired</a> protocol state, the client has agency and can
--   query the server against the acquired snapshot. Alternatively, it can
--   also (re)acquire a more recent snapshot.
data ClientStAcquired txid tx slot m a

-- | The mempool is modeled as an ordered list of transactions and thus,
--   can be traversed linearly. <a>MsgNextTx</a> requests the next
--   transaction from the current list. This must be a transaction that was
--   not previously sent to the client for this particular snapshot.
[SendMsgNextTx] :: (Maybe tx -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | For some cases where clients do not wish to traverse the entire
--   mempool but look for a specific transaction, they can assess the
--   presence of such transaction directly. Note that, the absence of a
--   transaction does not imply anything about how the transaction was
--   processed: it may have been dropped, or inserted in a block.
--   <a>False</a> simply means that it is no longer in the mempool.
[SendMsgHasTx] :: txid -> (Bool -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Ask the server about the current mempool's capacity and sizes. This is
--   fixed in a given snapshot.
[SendMsgGetSizes] :: (MempoolSizeAndCapacity -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Await for a new snapshot and acquire it.
[SendMsgAwaitAcquire] :: (slot -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Release the acquired snapshot, in order to loop back to the idle
--   state.
[SendMsgRelease] :: m (ClientStIdle txid tx slot m a) -> ClientStAcquired txid tx slot m a

-- | Interpret a <a>LocalTxMonitorClient</a> action sequence as a
--   <a>Peer</a> on the client-side of the <a>LocalTxMonitor</a> protocol.
localTxMonitorClientPeer :: forall txid tx slot m a. Monad m => LocalTxMonitorClient txid tx slot m a -> Peer (LocalTxMonitor txid tx slot) AsClient StIdle m a


-- | The type of the local transaction submission protocol.
--   
--   This is used by local clients (like wallets and CLI tools) to submit
--   transactions to a local node.
module Ouroboros.Network.Protocol.LocalTxSubmission.Type

-- | The kind of the local transaction-submission protocol, and the types
--   of the states in the protocol state machine.
--   
--   It is parametrised over the type of transactions and the type of
--   reasons used when rejecting a transaction.
data LocalTxSubmission tx reject

-- | The client has agency; it can submit a transaction or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalTxSubmission tx reject

-- | The server has agency; it must process the submitted transaction and
--   either accept or reject it (with a reason).
--   
--   There is a timeout in this state. If the mempool is full and remains
--   so for a period then the transaction should be rejected with a
--   suitable temporary failure reason.
[StBusy] :: LocalTxSubmission tx reject

-- | Nobody has agency. The terminal state.
[StDone] :: LocalTxSubmission tx reject

-- | Isomorphic with Maybe but with a name that better describes its
--   purpose and usage.
data SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
instance GHC.Base.Functor Ouroboros.Network.Protocol.LocalTxSubmission.Type.SubmitResult
instance GHC.Classes.Eq reason => GHC.Classes.Eq (Ouroboros.Network.Protocol.LocalTxSubmission.Type.SubmitResult reason)
instance forall tx reject (from :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) (to :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). (GHC.Classes.Eq tx, GHC.Classes.Eq reject) => GHC.Classes.Eq (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) from to)
instance forall tx reject (from :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) (to :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). (GHC.Show.Show tx, GHC.Show.Show reject) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) from to)
instance forall k1 k2 (tx :: k1) (reject :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy tx, Ouroboros.Network.Util.ShowProxy.ShowProxy reject) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject)
instance forall k1 k2 (tx :: k1) (reject :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject)
instance forall k1 k2 (tx :: k1) (reject :: k2) (st :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (tx :: k1) (reject :: k2) (st :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)


-- | A view of the local transaction submission protocol from the point of
--   view of the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.LocalTxSubmission.Server

-- | The server side of the local transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
data LocalTxSubmissionServer tx reject m a
LocalTxSubmissionServer :: (tx -> m (SubmitResult reject, LocalTxSubmissionServer tx reject m a)) -> a -> LocalTxSubmissionServer tx reject m a

-- | The client has submited a single transaction and it expects a reply.
--   
--   The server must reply to inform the client that it has either accepted
--   the transaction or rejected it. In the rejection case a reason for the
--   rejection is included.
[recvMsgSubmitTx] :: LocalTxSubmissionServer tx reject m a -> tx -> m (SubmitResult reject, LocalTxSubmissionServer tx reject m a)

-- | The client can terminate the protocol.
[recvMsgDone] :: LocalTxSubmissionServer tx reject m a -> a

-- | A non-pipelined <a>Peer</a> representing the
--   <a>LocalTxSubmissionServer</a>.
localTxSubmissionServerPeer :: forall tx reject m a. Monad m => m (LocalTxSubmissionServer tx reject m a) -> Peer (LocalTxSubmission tx reject) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalTxSubmission.Codec
codecLocalTxSubmission :: forall tx reject m. MonadST m => (tx -> Encoding) -> (forall s. Decoder s tx) -> (reject -> Encoding) -> (forall s. Decoder s reject) -> Codec (LocalTxSubmission tx reject) DeserialiseFailure m ByteString
codecLocalTxSubmissionId :: forall tx reject m. Monad m => Codec (LocalTxSubmission tx reject) CodecFailure m (AnyMessage (LocalTxSubmission tx reject))


-- | A view of the transaction submission protocol from the point of view
--   of the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, <a>localTxSubmissionClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxSubmission.Client
newtype LocalTxSubmissionClient tx reject m a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject m a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject m a -> m (LocalTxClientStIdle tx reject m a)

-- | The client side of the local transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
data LocalTxClientStIdle tx reject m a

-- | The client submits a single transaction and waits a reply.
--   
--   The server replies to inform the client that it has either accepted
--   the transaction or rejected it. In the rejection case a reason for the
--   rejection is included.
[SendMsgSubmitTx] :: tx -> (SubmitResult reject -> m (LocalTxClientStIdle tx reject m a)) -> LocalTxClientStIdle tx reject m a

-- | The client can terminate the protocol.
[SendMsgDone] :: a -> LocalTxClientStIdle tx reject m a

-- | Isomorphic with Maybe but with a name that better describes its
--   purpose and usage.
data SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason

-- | A non-pipelined <a>Peer</a> representing the
--   <a>LocalTxSubmissionClient</a>.
localTxSubmissionClientPeer :: forall tx reject m a. Monad m => LocalTxSubmissionClient tx reject m a -> Peer (LocalTxSubmission tx reject) AsClient StIdle m a

-- | A local tx submission client which never sends any message.

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.localTxSubmissionPeerNull</i>
localTxSubmissionClientNull :: MonadTimer m => LocalTxSubmissionClient tx reject m a

-- | Transform a <a>LocalTxSubmissionClient</a> by mapping over the tx and
--   the rejection errors.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs.
mapLocalTxSubmissionClient :: forall tx tx' reject reject' m a. Functor m => (tx -> tx') -> (reject' -> reject) -> LocalTxSubmissionClient tx reject m a -> LocalTxSubmissionClient tx' reject' m a

module Ouroboros.Network.Protocol.PeerSharing.Type

-- | PeerSharing amount new type.
--   
--   We use <a>Word8</a> to be faithful to the CDDL specification.
newtype PeerSharingAmount
PeerSharingAmount :: Word8 -> PeerSharingAmount
[getAmount] :: PeerSharingAmount -> Word8

-- | PeerSharing Result type.
--   
--   We need a constructor for the case when the Governor wins the race
--   versus the Mux (when initialising the peer sharing miniprotocol). This
--   leads the Governor to lookup a peer that hasn't been registered yet.
data PeerSharingResult peerAddress
PeerSharingResult :: [peerAddress] -> PeerSharingResult peerAddress
PeerSharingNotRegisteredYet :: PeerSharingResult peerAddress

-- | A kind to identify our protocol, and the types of the states in the
--   state transition diagram of the protocol.
data PeerSharing peerAddress

-- | The client can send a request and the server is waiting for a request.
[StIdle] :: PeerSharing peerAddress

-- | The server is responsible for sending response back.
[StBusy] :: PeerSharing peerAddress

-- | Both the client and server are in the terminal state. They're done.
[StDone] :: PeerSharing peerAddress
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Real.Integral Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Real.Real Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Num.Num Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Enum.Enum Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Generics.Generic Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Classes.Ord Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Show.Show Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Classes.Eq Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingAmount
instance GHC.Show.Show peerAddress => GHC.Show.Show (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingResult peerAddress)
instance GHC.Classes.Eq peerAddress => GHC.Classes.Eq (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharingResult peerAddress)
instance GHC.Show.Show peerAddress => GHC.Show.Show (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peerAddress)
instance GHC.Classes.Eq peerAddress => GHC.Classes.Eq (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peerAddress)
instance forall k (peer :: k). Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peer)
instance forall k (peerAddress :: k). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peerAddress)
instance forall peer (from :: Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peer) (to :: Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peer). GHC.Show.Show peer => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peer) from to)
instance forall k (peerAddress :: k) (st :: Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peerAddress). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k (peerAddress :: k) (st :: Ouroboros.Network.Protocol.PeerSharing.Type.PeerSharing peerAddress). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Ouroboros.Network.Protocol.PeerSharing.Server
data PeerSharingServer peerAddress m
PeerSharingServer :: (PeerSharingAmount -> m ([peerAddress], PeerSharingServer peerAddress m)) -> PeerSharingServer peerAddress m

-- | The client sent us a <a>MsgShareRequest</a>. We have need to compute
--   the response.
[recvMsgShareRequest] :: PeerSharingServer peerAddress m -> PeerSharingAmount -> m ([peerAddress], PeerSharingServer peerAddress m)
peerSharingServerPeer :: Monad m => PeerSharingServer peerAddress m -> Peer (PeerSharing peerAddress) AsServer StIdle m ()

module Ouroboros.Network.Protocol.PeerSharing.Codec
codecPeerSharing :: forall m peerAddress. MonadST m => (peerAddress -> Encoding) -> (forall s. Decoder s peerAddress) -> Codec (PeerSharing peerAddress) DeserialiseFailure m ByteString
codecPeerSharingId :: forall peerAddress m. Monad m => Codec (PeerSharing peerAddress) CodecFailure m (AnyMessage (PeerSharing peerAddress))

-- | We assume that a TCP segment size of 1440 bytes with initial window of
--   size 4. This sets upper limit of 5760 bytes on each message of peer
--   sharing protocol, which means request and response should be done in a
--   single RTT
maxTransmissionUnit :: Word
byteLimitsPeerSharing :: (bytes -> Word) -> ProtocolSizeLimits (PeerSharing peerAddress) bytes
timeLimitsPeerSharing :: ProtocolTimeLimits (PeerSharing peerAddress)

module Ouroboros.Network.Protocol.PeerSharing.Client
data PeerSharingClient peerAddress m a
[SendMsgShareRequest] :: PeerSharingAmount -> ([peerAddress] -> m (PeerSharingClient peerAddress m a)) -> PeerSharingClient peerAddress m a
[SendMsgDone] :: m a -> PeerSharingClient peerAddress m a

-- | Interpret a particular client action sequence into the client side of
--   the <a>PeerSharing</a> protocol.
peerSharingClientPeer :: Monad m => PeerSharingClient peerAddress m a -> Peer (PeerSharing peerAddress) AsClient StIdle m a


-- | The type of the transaction submission protocol.
--   
--   This is used to relay transactions between nodes.
module Ouroboros.Network.Protocol.TxSubmission2.Type

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | The kind of the transaction-submission protocol, and the types of the
--   states in the protocol state machine.
--   
--   We describe this protocol using the label "client" for the peer that
--   is submitting transactions, and "server" for the one receiving them.
--   The protocol is however pull based, so it is typically the server that
--   has agency in this protocol. This is the opposite of the chain sync
--   and block fetch protocols, but that makes sense because the
--   information flow is also reversed: submitting transactions rather than
--   receiving headers and blocks.
--   
--   Because these client/server labels are somewhat confusing in this
--   case, we sometimes clarify by using the terms inbound and outbound.
--   This refers to whether transactions are flowing towards a peer or
--   away, and thus indicates what role the peer is playing.
data TxSubmission2 txid tx

-- | Initial protocol message.
[StInit] :: TxSubmission2 txid tx

-- | The server (inbound side) has agency; it can either terminate, ask for
--   transaction identifiers or ask for transactions.
--   
--   There is no timeout in this state.
[StIdle] :: TxSubmission2 txid tx

-- | The client (outbound side) has agency; it must reply with a list of
--   transaction identifiers that it wishes to submit.
--   
--   There are two sub-states for this, for blocking and non-blocking
--   cases.
[StTxIds] :: StBlockingStyle -> TxSubmission2 txid tx

-- | The client (outbound side) has agency; it must reply with the list of
--   transactions.
[StTxs] :: TxSubmission2 txid tx

-- | Nobody has agency; termination state.
[StDone] :: TxSubmission2 txid tx
data StBlockingStyle

-- | In this sub-state the reply need not be prompt. There is no timeout.
[StBlocking] :: StBlockingStyle

-- | In this state the peer must reply. There is a timeout.
[StNonBlocking] :: StBlockingStyle

-- | The value level equivalent of <a>StBlockingStyle</a>.
--   
--   This is also used in <a>MsgRequestTxIds</a> where it is interpreted
--   (and can be encoded) as a <a>Bool</a> with <a>True</a> for blocking,
--   and <a>False</a> for non-blocking.
data TokBlockingStyle (k :: StBlockingStyle)
[TokBlocking] :: TokBlockingStyle StBlocking
[TokNonBlocking] :: TokBlockingStyle StNonBlocking

-- | We have requests for lists of things. In the blocking case the
--   corresponding reply must be non-empty, whereas in the non-blocking
--   case and empty reply is fine.
data BlockingReplyList (blocking :: StBlockingStyle) a
[BlockingReply] :: NonEmpty a -> BlockingReplyList StBlocking a
[NonBlockingReply] :: [a] -> BlockingReplyList StNonBlocking a
instance GHC.Classes.Eq (Ouroboros.Network.Protocol.TxSubmission2.Type.TokBlockingStyle b)
instance GHC.Show.Show (Ouroboros.Network.Protocol.TxSubmission2.Type.TokBlockingStyle b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Network.Protocol.TxSubmission2.Type.BlockingReplyList blocking a)
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Protocol.TxSubmission2.Type.BlockingReplyList blocking a)
instance forall txid tx (from :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) (to :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). (GHC.Classes.Eq txid, GHC.Classes.Eq tx) => GHC.Classes.Eq (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) from to)
instance forall txid tx (from :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) (to :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). (GHC.Show.Show txid, GHC.Show.Show tx) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) from to)
instance forall k1 k2 (txid :: k1) (tx :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx)
instance forall k1 k2 (txid :: k1) (tx :: k2) (st :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (txid :: k1) (tx :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy txid, Ouroboros.Network.Util.ShowProxy.ShowProxy tx) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx)
instance forall k1 k2 (txid :: k1) (tx :: k2). Ouroboros.Network.Util.ShowProxy.ShowProxy 'Ouroboros.Network.Protocol.TxSubmission2.Type.StIdle
instance forall k1 k2 (txid :: k1) (tx :: k2) (st :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)


-- | A view of the transaction submission protocol from the point of view
--   of the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.TxSubmission2.Server
data TxSubmissionServerPipelined txid tx m a
[TxSubmissionServerPipelined] :: m (ServerStIdle Z txid tx m a) -> TxSubmissionServerPipelined txid tx m a
data ServerStIdle (n :: N) txid tx m a
[SendMsgRequestTxIdsBlocking] :: Word16 -> Word16 -> m a -> (NonEmpty (txid, TxSizeInBytes) -> m (ServerStIdle Z txid tx m a)) -> ServerStIdle Z txid tx m a
[SendMsgRequestTxIdsPipelined] :: Word16 -> Word16 -> m (ServerStIdle (S n) txid tx m a) -> ServerStIdle n txid tx m a
[SendMsgRequestTxsPipelined] :: [txid] -> m (ServerStIdle (S n) txid tx m a) -> ServerStIdle n txid tx m a

-- | Collect a pipelined result.
[CollectPipelined] :: Maybe (ServerStIdle (S n) txid tx m a) -> (Collect txid tx -> m (ServerStIdle n txid tx m a)) -> ServerStIdle (S n) txid tx m a

-- | This is the type of the pipelined results, collected by
--   <a>CollectPipelined</a>. This protocol can pipeline requests for
--   transaction ids and transactions, so we use a sum of either for
--   collecting the responses.
data Collect txid tx

-- | The result of <a>SendMsgRequestTxIdsPipelined</a>. It also carries the
--   number of txids originally requested.
CollectTxIds :: Word16 -> [(txid, TxSizeInBytes)] -> Collect txid tx

-- | The result of <a>SendMsgRequestTxsPipelined</a>. The actual reply only
--   contains the transactions sent, but this pairs them up with the
--   transactions requested. This is because the peer can determine that
--   some transactions are no longer needed.
CollectTxs :: [txid] -> [tx] -> Collect txid tx

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | Transform a <a>TxSubmissionServerPipelined</a> into a
--   <a>PeerPipelined</a>.
txSubmissionServerPeerPipelined :: forall txid tx m a. Functor m => TxSubmissionServerPipelined txid tx m a -> PeerPipelined (TxSubmission2 txid tx) AsServer StInit m a

module Ouroboros.Network.Protocol.TxSubmission2.Codec
codecTxSubmission2 :: forall txid tx m. MonadST m => (txid -> Encoding) -> (forall s. Decoder s txid) -> (tx -> Encoding) -> (forall s. Decoder s tx) -> Codec (TxSubmission2 txid tx) DeserialiseFailure m ByteString
codecTxSubmission2Id :: forall txid tx m. Monad m => Codec (TxSubmission2 txid tx) CodecFailure m (AnyMessage (TxSubmission2 txid tx))
encodeTxSubmission2 :: forall txid tx. (txid -> Encoding) -> (tx -> Encoding) -> forall (pr :: PeerRole) (st :: TxSubmission2 txid tx) (st' :: TxSubmission2 txid tx). PeerHasAgency pr st -> Message (TxSubmission2 txid tx) st st' -> Encoding
decodeTxSubmission2 :: forall txid tx. (forall s. Decoder s txid) -> (forall s. Decoder s tx) -> forall (pr :: PeerRole) (st :: TxSubmission2 txid tx) s. PeerHasAgency pr st -> Int -> Word -> Decoder s (SomeMessage st)

-- | Byte Limits.
byteLimitsTxSubmission2 :: forall bytes txid tx. (bytes -> Word) -> ProtocolSizeLimits (TxSubmission2 txid tx) bytes

-- | Time Limits.
--   
--   `TokTxIds TokBlocking` No timeout `TokTxIds TokNonBlocking`
--   <a>shortWait</a> timeout <a>TokTxs</a> <a>shortWait</a> timeout
--   <a>TokIdle</a> <a>shortWait</a> timeout
timeLimitsTxSubmission2 :: forall txid tx. ProtocolTimeLimits (TxSubmission2 txid tx)


-- | A view of the transaction submission protocol from the point of view
--   of the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, <a>txSubmissionClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.TxSubmission2.Client

-- | The client side of the transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
newtype TxSubmissionClient txid tx m a
TxSubmissionClient :: m (ClientStIdle txid tx m a) -> TxSubmissionClient txid tx m a
[runTxSubmissionClient] :: TxSubmissionClient txid tx m a -> m (ClientStIdle txid tx m a)

-- | In the <a>StIdle</a> protocol state, the client does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a request for transaction ids (blocking or non-blocking)</li>
--   <li>a request for a given list of transactions</li>
--   <li>a termination message</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStIdle txid tx m a
ClientStIdle :: (forall blocking. TokBlockingStyle blocking -> Word16 -> Word16 -> m (ClientStTxIds blocking txid tx m a)) -> ([txid] -> m (ClientStTxs txid tx m a)) -> ClientStIdle txid tx m a
[recvMsgRequestTxIds] :: ClientStIdle txid tx m a -> forall blocking. TokBlockingStyle blocking -> Word16 -> Word16 -> m (ClientStTxIds blocking txid tx m a)
[recvMsgRequestTxs] :: ClientStIdle txid tx m a -> [txid] -> m (ClientStTxs txid tx m a)
data ClientStTxIds blocking txid tx m a
[SendMsgReplyTxIds] :: BlockingReplyList blocking (txid, TxSizeInBytes) -> ClientStIdle txid tx m a -> ClientStTxIds blocking txid tx m a

-- | In the blocking case, the client can terminate the protocol. This
--   could be used when the client knows there will be no more transactions
--   to submit.
[SendMsgDone] :: a -> ClientStTxIds StBlocking txid tx m a
data ClientStTxs txid tx m a
[SendMsgReplyTxs] :: [tx] -> ClientStIdle txid tx m a -> ClientStTxs txid tx m a

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | The value level equivalent of <a>StBlockingStyle</a>.
--   
--   This is also used in <a>MsgRequestTxIds</a> where it is interpreted
--   (and can be encoded) as a <a>Bool</a> with <a>True</a> for blocking,
--   and <a>False</a> for non-blocking.
data TokBlockingStyle (k :: StBlockingStyle)
[TokBlocking] :: TokBlockingStyle StBlocking
[TokNonBlocking] :: TokBlockingStyle StNonBlocking

-- | We have requests for lists of things. In the blocking case the
--   corresponding reply must be non-empty, whereas in the non-blocking
--   case and empty reply is fine.
data BlockingReplyList (blocking :: StBlockingStyle) a
[BlockingReply] :: NonEmpty a -> BlockingReplyList StBlocking a
[NonBlockingReply] :: [a] -> BlockingReplyList StNonBlocking a

-- | A non-pipelined <a>Peer</a> representing the
--   <a>TxSubmissionClient</a>.
txSubmissionClientPeer :: forall txid tx m a. Monad m => TxSubmissionClient txid tx m a -> Peer (TxSubmission2 txid tx) AsClient StInit m a
