-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The instantation of the Ouroboros consensus layer used by Cardano
--   
--   The instantation of the Ouroboros consensus layer used by Cardano.
@package ouroboros-consensus-cardano
@version 0.13.0.0


-- | Byron digital signatures.
module Ouroboros.Consensus.Byron.Crypto.DSIGN
data ByronDSIGN
class HasSignTag a
signTag :: HasSignTag a => VerKeyDSIGN ByronDSIGN -> proxy a -> SignTag
data family SigDSIGN v
data family SignKeyDSIGN v
data family VerKeyDSIGN v
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance (Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag a, Cardano.Ledger.Binary.Decoding.Annotated.Decoded a) => Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronSignable a
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN
instance Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag Cardano.Chain.UTxO.TxWitness.TxSigData
instance Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag (Cardano.Ledger.Binary.Decoding.Annotated.Annotated Cardano.Chain.Block.Header.ToSign Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)

module Ouroboros.Consensus.Byron.EBBs
knownEBBs :: [(HeaderHash, Maybe HeaderHash)]

module Ouroboros.Consensus.Byron.Ledger.Orphans
instance NoThunks.Class.NoThunks Cardano.Chain.Block.Validation.ChainValidationError
instance Codec.Serialise.Class.Serialise Cardano.Chain.Block.Validation.ChainValidationState
instance Codec.Serialise.Class.Serialise Cardano.Chain.Common.KeyHash.KeyHash
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Block.Header.HeaderHash
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABlock Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Header.AHeader Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABoundaryBlock Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABlockOrBoundary Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Header.ABoundaryHeader Data.ByteString.Internal.Type.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.UTxO.Tx.TxId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Update.Proposal.UpId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Delegation.Certificate.CertificateId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Update.Vote.VoteId
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.MempoolPayload.AMempoolPayload a)
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Crypto.Signing.VerificationKey.VerificationKey

module Ouroboros.Consensus.Byron.Ledger.Conversions
fromByronBlockCount :: BlockCount -> SecurityParam
fromByronBlockNo :: ChainDifficulty -> BlockNo
fromByronEpochSlots :: EpochSlots -> EpochSize
fromByronSlotLength :: Natural -> SlotLength
fromByronSlotNo :: SlotNumber -> SlotNo
toByronBlockCount :: SecurityParam -> BlockCount
toByronSlotLength :: SlotLength -> Natural
toByronSlotNo :: SlotNo -> SlotNumber
genesisNumCoreNodes :: Config -> NumCoreNodes
genesisSecurityParam :: Config -> SecurityParam
genesisSlotLength :: Config -> Natural

module Ouroboros.Consensus.Byron.Ledger.Block
newtype ByronHash
ByronHash :: HeaderHash -> ByronHash
[unByronHash] :: ByronHash -> HeaderHash
mkByronHash :: ABlockOrBoundaryHdr ByteString -> ByronHash

-- | Byron block
--   
--   We cache two bits of information:
--   
--   <ul>
--   <li>We cache the slot number as this is not readily available for
--   EBBs. Having it cached allows us to e.g. give a <a>HasHeader</a>
--   instance.</li>
--   <li>We cache the hash as this is expensive to compute and we need it
--   often.</li>
--   </ul>
data ByronBlock
ByronBlock :: !ABlockOrBoundary ByteString -> !SlotNo -> !ByronHash -> ByronBlock
[byronBlockRaw] :: ByronBlock -> !ABlockOrBoundary ByteString
[byronBlockSlotNo] :: ByronBlock -> !SlotNo
[byronBlockHash] :: ByronBlock -> !ByronHash

-- | Construct Byron block from unannotated <a>Block</a>
--   
--   This should be used only when forging blocks (not when receiving
--   blocks over the wire).
annotateByronBlock :: EpochSlots -> Block -> ByronBlock
mkByronBlock :: EpochSlots -> ABlockOrBoundary ByteString -> ByronBlock
data family Header blk
mkBoundaryByronHeader :: SlotNo -> ABoundaryHeader ByteString -> SizeInBytes -> Header ByronBlock
mkByronHeader :: EpochSlots -> ABlockOrBoundaryHdr ByteString -> SizeInBytes -> Header ByronBlock
mkRegularByronHeader :: AHeader ByteString -> SizeInBytes -> Header ByronBlock
byronBlockIsEBB :: ByronBlock -> IsEBB
byronHeaderIsEBB :: Header ByronBlock -> IsEBB
knownEBBs :: Map (HeaderHash ByronBlock) (ChainHash ByronBlock)

-- | Header without a size hint
--   
--   Defined in order to support backwards compatible binary encodings.
data UnsizedHeader
UnsizedHeader :: !ABlockOrBoundaryHdr ByteString -> !SlotNo -> !ByronHash -> UnsizedHeader
[unsizedHeaderRaw] :: UnsizedHeader -> !ABlockOrBoundaryHdr ByteString
[unsizedHeaderSlotNo] :: UnsizedHeader -> !SlotNo
[unsizedHeaderHash] :: UnsizedHeader -> !ByronHash
joinSizeHint :: UnsizedHeader -> SizeInBytes -> Header ByronBlock
mkUnsizedHeader :: EpochSlots -> ABlockOrBoundaryHdr ByteString -> UnsizedHeader
splitSizeHint :: Header ByronBlock -> (UnsizedHeader, SizeInBytes)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Block.Abstract.ConvertRawHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Block.Abstract.GetHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Block.StandardHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Block.HasHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Block.Abstract.GetPrevHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion
data ByronNodeToClientVersion
ByronNodeToClientVersion1 :: ByronNodeToClientVersion
data ByronNodeToNodeVersion

-- | We send headers without a size hint
ByronNodeToNodeVersion1 :: ByronNodeToNodeVersion

-- | We send headers <i>with</i> a size hint
ByronNodeToNodeVersion2 :: ByronNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.HasNetworkProtocolVersion Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Config
data family BlockConfig blk
byronEpochSlots :: BlockConfig ByronBlock -> EpochSlots
byronGenesisHash :: BlockConfig ByronBlock -> GenesisHash
byronProtocolMagic :: BlockConfig ByronBlock -> ProtocolMagic
byronProtocolMagicId :: BlockConfig ByronBlock -> ProtocolMagicId
data family CodecConfig blk
mkByronCodecConfig :: Config -> CodecConfig ByronBlock
data family StorageConfig blk

-- | Byron's genesis config contains the AVVM balances, of which there are
--   +14k in mainnet's genesis config. These balances are only used to
--   create the initial ledger state, there is no reason to keep them in
--   memory afterwards.
--   
--   This function empties the <tt>gdAvvmDistr</tt> field in the genesis
--   config. As we keep Byron's genesis config in memory (even in later
--   eras), this can save us a bit of memory.
compactGenesisConfig :: Config -> Config
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.BlockConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.BlockConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.CodecConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.CodecConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.StorageConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.StorageConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)

module Ouroboros.Consensus.Byron.Ledger.Serialisation
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type
type RawBoundaryHeader = ABoundaryHeader ByteString
type RawHeader = AHeader ByteString

-- | The Byron block encoding overhead size in bytes.
--   
--   This encompasses the overhead in bytes for everything that is encoded
--   within a Byron block, excluding the actual generalized transactions
--   (transactions, delegation certificates, update votes, and update
--   proposals).
byronBlockEncodingOverhead :: Word32

-- | Inverse of <a>encodeByronBlock</a>
decodeByronBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Decoder for a boundary Byron block.
--   
--   PRECONDITION: the <a>ByteString</a> given as argument to the decoder
--   is the same as the one that is decoded.
--   
--   This is a wrapper for <a>decCBORABoundaryBlock</a>.
--   
--   Use <a>decodeByronBlock</a> when you can, this function is provided
--   for use by the hard-fork combinator.
decodeByronBoundaryBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Inverse of <a>encodeByronBoundaryHeader</a>
decodeByronBoundaryHeader :: Decoder s (ByteString -> RawBoundaryHeader)
decodeByronHeaderHash :: Decoder s (HeaderHash ByronBlock)

-- | Decoder for a regular (non-EBB) Byron block.
--   
--   PRECONDITION: the <a>ByteString</a> given as argument to the decoder
--   is the same as the one that is decoded.
--   
--   This is a wrapper for <a>decCBORABlock</a>.
--   
--   Use <a>decodeByronBlock</a> when you can, this function is provided
--   for use by the hard-fork combinator.
decodeByronRegularBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Inverse of <a>encodeByronRegularHeader</a>
decodeByronRegularHeader :: EpochSlots -> Decoder s (ByteString -> RawHeader)

-- | Encode a block
--   
--   Should be backwards compatible with legacy (cardano-sl) nodes.
--   
--   Implementation note: the decoder uses <a>decCBORABlockOrBoundary</a>,
--   which has inverse <a>encCBORABlockOrBoundary</a>. This encoder is
--   intended to be binary compatible with <a>encCBORABlockOrBoundary</a>,
--   but does not use it and instead takes advantage of the annotations
--   (using <tt>encodePreEncoded</tt>).
encodeByronBlock :: ByronBlock -> Encoding

-- | Encodes a raw Byron EBB header <i>without</i> a tag indicating whether
--   it's a regular header or an EBB header.
--   
--   Uses the annotation, so cheap.
encodeByronBoundaryHeader :: RawBoundaryHeader -> Encoding
encodeByronHeaderHash :: HeaderHash ByronBlock -> Encoding

-- | Encodes a raw Byron header <i>without</i> a tag indicating whether
--   it's a regular header or an EBB header.
--   
--   Uses the annotation, so cheap.
encodeByronRegularHeader :: RawHeader -> Encoding

-- | The <a>BinaryBlockInfo</a> of the given <a>ByronBlock</a>.
--   
--   NOTE: the bytestring obtained by slicing the serialised block using
--   the header offset and size will correspond to the <i>header
--   annotation</i>, but not to the serialised header, as we add an
--   envelope (<tt>encodeListLen</tt> + tag) around a header in
--   <tt>encodeByronHeader</tt>. This envelope must thus still be added to
--   the sliced bytestring before it can be deserialised using
--   <tt>decodeByronHeader</tt>.
byronBinaryBlockInfo :: ByronBlock -> BinaryBlockInfo
addV1Envelope :: (SomeSecond (NestedCtxt Header) ByronBlock, ByteString) -> ByteString

-- | Inverse of <tt>encodeSizedHeader</tt>
decodeUnsizedHeader :: EpochSlots -> Decoder s (ByteString -> UnsizedHeader)

-- | Drop the V1 EBB-or-regular-header envelope and reconstruct the
--   context. Since we don't know the block size, use
--   <a>fakeByronBlockSizeHint</a>.
dropV1Envelope :: ByteString -> Except String (SomeSecond (NestedCtxt Header) ByronBlock, ByteString)

-- | Encode an unsized header
--   
--   Does <i>not</i> have to backwards compatible with legacy (cardano-sl)
--   nodes (which never send or store these headers), but should be inverse
--   to <tt>decodeSizedHeader</tt>, and moreover uses
--   <tt>decCBORABlockOrBoundaryHdr</tt> from cardano-ledger-byron, and so
--   we don't have too much choice in this encoder.
encodeUnsizedHeader :: UnsizedHeader -> Encoding

-- | Fake size (used in compatibility mode)
fakeByronBlockSizeHint :: SizeInBytes
instance GHC.Show.Show (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock f a)
instance Codec.Serialise.Class.Serialise Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock f)
instance Ouroboros.Consensus.Block.NestedContent.HasNestedContent Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Protocol
data PBftByronCrypto

-- | Determine the <a>CoreNodeId</a> for a code node, based on the genesis
--   key it will sign blocks on behalf of.
--   
--   In PBFT, the <a>CoreNodeId</a> index is determined by the 0-based
--   position in the sort order of the genesis key hashes.
genesisKeyCoreNodeId :: Config -> VerKeyDSIGN ByronDSIGN -> Maybe CoreNodeId

-- | Inverse of <a>genesisKeyCoreNodeId</a>
nodeIdToGenesisKey :: Config -> CoreNodeId -> Maybe KeyHash
instance Ouroboros.Consensus.Protocol.PBFT.Crypto.PBftCrypto Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto


-- | Instances required to support PBFT
module Ouroboros.Consensus.Byron.Ledger.PBFT
decodeByronChainDepState :: Decoder s (ChainDepState (BlockProtocol ByronBlock))
encodeByronChainDepState :: ChainDepState (BlockProtocol ByronBlock) -> Encoding
fromPBftLedgerView :: PBftLedgerView PBftByronCrypto -> Map

-- | Construct DSIGN required for Byron crypto
mkByronContextDSIGN :: BlockConfig ByronBlock -> VerKeyDSIGN ByronDSIGN -> ContextDSIGN ByronDSIGN
toPBftLedgerView :: Map -> PBftLedgerView PBftByronCrypto
instance Ouroboros.Consensus.Block.SupportsProtocol.BlockSupportsProtocol Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Integrity

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
--   
--   This function will always return <a>True</a> for an EBB, as we cannot
--   check anything for an EBB.
verifyBlockIntegrity :: BlockConfig ByronBlock -> ByronBlock -> Bool

-- | Verify whether a header is not corrupted.
--   
--   The difference with <a>verifyHeaderSignature</a> is that this function
--   also checks the integrity of the <a>headerProtocolMagicId</a> field,
--   which is the only field of a regular header that is not signed.
--   
--   Note that we cannot check this for an EBB, as an EBB contains no
--   signature. This function will always return <a>True</a> for an EBB.
verifyHeaderIntegrity :: BlockConfig ByronBlock -> Header ByronBlock -> Bool

-- | Verify whether a header matches its signature.
--   
--   Note that we cannot check this for an EBB, as an EBB contains no
--   signature. This function will always return <a>True</a> for an EBB.
verifyHeaderSignature :: BlockConfig ByronBlock -> Header ByronBlock -> Bool

module Ouroboros.Consensus.Byron.Ledger.HeaderValidation
data ByronOtherHeaderEnvelopeError
UnexpectedEBBInSlot :: !SlotNo -> ByronOtherHeaderEnvelopeError
data () => TipInfoIsEBB blk
TipInfoIsEBB :: !HeaderHash blk -> !IsEBB -> TipInfoIsEBB blk
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance Ouroboros.Consensus.HeaderValidation.ValidateEnvelope Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HeaderValidation.HasAnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HeaderValidation.BasicEnvelopeValidation Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock


-- | Instances requires for consensus/ledger integration
module Ouroboros.Consensus.Byron.Ledger.Ledger

-- | Information required to determine the transition from Byron to Shelley
data ByronTransition

-- | Per candidate proposal, the <a>BlockNo</a> in which it became a
--   candidate
--   
--   The HFC needs to know when a candidate proposal becomes stable. We
--   cannot reliably do this using <a>SlotNo</a>: doing so would mean that
--   if we were to switch to a denser fork, something that was previously
--   deemed stable is suddenly not deemed stable anymore (although in
--   actuality it still is). We therefore must do this based on
--   <a>BlockNo</a> instead, but unfortunately the Byron ledger does not
--   record this information. Therefore, we record it here instead.
--   
--   Invariant: the domain of this map should equal the set of candidate
--   proposals.
ByronTransitionInfo :: !Map ProtocolVersion BlockNo -> ByronTransition

-- | To be used for a Byron-to-X (where X is typically Shelley) chain.
byronEraParams :: Config -> EraParams

-- | Separate variant of <a>byronEraParams</a> to be used for a Byron-only
--   chain.
byronEraParamsNeverHardForks :: Config -> EraParams
initByronLedgerState :: Config -> Maybe UTxO -> LedgerState ByronBlock
decodeByronAnnTip :: Decoder s (AnnTip ByronBlock)
decodeByronLedgerState :: Decoder s (LedgerState ByronBlock)
decodeByronQuery :: Decoder s (SomeSecond BlockQuery ByronBlock)
decodeByronResult :: BlockQuery ByronBlock result -> forall s. Decoder s result
encodeByronAnnTip :: AnnTip ByronBlock -> Encoding
encodeByronExtLedgerState :: ExtLedgerState ByronBlock -> Encoding
encodeByronHeaderState :: HeaderState ByronBlock -> Encoding
encodeByronLedgerState :: LedgerState ByronBlock -> Encoding
encodeByronQuery :: BlockQuery ByronBlock result -> Encoding
encodeByronResult :: BlockQuery ByronBlock result -> result -> Encoding
data family BlockQuery blk :: Type -> Type
data family LedgerState blk
data family Ticked st

-- | Mark computation as validation error free
--   
--   Given a <tt>BlockValidationMode</tt> of <tt>NoBlockValidation</tt>, a
--   call to <a>applyByronBlock</a> shouldn't fail since the ledger layer
--   won't be performing any block validation checks. However, because
--   <a>applyByronBlock</a> can fail in the event it is given a
--   <tt>BlockValidationMode</tt> of <tt>BlockValidation</tt>, it still
--   <i>looks</i> like it can fail (since its type doesn't change based on
--   the <tt>ValidationMode</tt>) and we must still treat it as such.
validationErrorImpossible :: forall err a. Except err a -> a
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock result)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock result)
instance Ouroboros.Consensus.Ledger.Abstract.UpdateLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Ledger.Basics.IsLedger (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.Abstract.ApplyBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.Query.QueryLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.SupportsPeerSelection.LedgerSupportsPeerSelection Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.CommonProtocolParams.CommonProtocolParams Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Abstract.HasHardForkHistory Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock


-- | Byron mempool integration
module Ouroboros.Consensus.Byron.Ledger.Mempool
data family GenTx blk
data family TxId tx
data family Validated x
byronIdDlg :: ACertificate ByteString -> CertificateId
byronIdProp :: AProposal ByteString -> UpId
byronIdTx :: ATxAux ByteString -> TxId
byronIdVote :: AVote ByteString -> VoteId
decodeByronApplyTxError :: Decoder s (ApplyTxErr ByronBlock)

-- | The <a>ByteString</a> annotation will be the canonical encoding.
--   
--   While the new implementation does not care about canonical encodings,
--   the old one does. When a generalised transaction arrives that is not
--   in its canonical encoding (only the <a>ATxAux</a> of the
--   <a>ByronTx</a> can be produced by nodes that are not under our
--   control), the old implementation will reject it. Therefore, we need to
--   reject them too. See #905.
--   
--   We use the ledger to check for canonical encodings: the ledger will
--   check whether the signed hash of the transaction (in the case of a
--   <a>ATxAux</a>, the transaction witness) matches the annotated
--   bytestring. Is therefore <b>important</b> that the annotated
--   bytestring be the <i>canonical</i> encoding, not the <i>original,
--   possibly non-canonical</i> encoding.
decodeByronGenTx :: Decoder s (GenTx ByronBlock)
decodeByronGenTxId :: Decoder s (GenTxId ByronBlock)
encodeByronApplyTxError :: ApplyTxErr ByronBlock -> Encoding
encodeByronGenTx :: GenTx ByronBlock -> Encoding
encodeByronGenTxId :: GenTxId ByronBlock -> Encoding
fromMempoolPayload :: AMempoolPayload ByteString -> GenTx ByronBlock
toMempoolPayload :: GenTx ByronBlock -> AMempoolPayload ByteString

-- | Count all (generalized) transactions in the block
countByronGenTxs :: ByronBlock -> Word64
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Ord (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Mempool.Capacity.TxLimits Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Cardano.Chain.Byron.API.Mempool.ApplyMempoolPayloadErr
instance Ouroboros.Consensus.Ledger.SupportsMempool.LedgerSupportsMempool Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Ledger.SupportsMempool.HasTxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.SupportsMempool.HasTxs Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)

module Ouroboros.Consensus.Byron.Ledger.Inspect
data ByronLedgerUpdate
ByronUpdatedProtocolUpdates :: [ProtocolUpdate] -> ByronLedgerUpdate

-- | Wrapper around a Byron protocol update with information about its
--   state
--   
--   NOTE: We don't currently record the <a>ProtocolParameters</a> here
--   because we don't really need to track them, and adding them would add
--   a lot of output to the <a>Show</a> instance. We could easily add them
--   however if that would be useful.
data ProtocolUpdate
ProtocolUpdate :: ProtocolVersion -> UpdateState -> ProtocolUpdate
[protocolUpdateVersion] :: ProtocolUpdate -> ProtocolVersion
[protocolUpdateState] :: ProtocolUpdate -> UpdateState

-- | The various states a protocol update goes through
--   
--   Listed in chronological order.
data UpdateState

-- | The update was registered, but does not yet have any votes
--   
--   We record the <a>SlotNo</a> of the slot in which the update was
--   registered. After registration, nodes must vote on it.
UpdateRegistered :: SlotNo -> UpdateState

-- | The update is accumulating votes
--   
--   We record which nodes have voted for the proposal. The proposal must
--   accumulate a sufficient number of votes before it can be confirmed.
UpdateActive :: Set KeyHash -> UpdateState

-- | The update has amassed a sufficient number of votes
--   
--   We record the <a>SlotNo</a> of the slot in which the required
--   threshold of votes was met. At this point <tt>2k</tt> slots need to
--   pass before the update can be endorsed.
UpdateConfirmed :: SlotNo -> UpdateState

-- | The votes are stable. We can start to accumulate endorsements.
--   
--   We record which nodes have endorsed the proposal. The proposal must
--   accumulate a sufficient number of endorsements before it is nominated
--   and becomes a candidate.
UpdateStablyConfirmed :: Set KeyHash -> UpdateState

-- | The update has amassed a sufficient number of endorsements
--   
--   We record the <a>SlotNo</a> of the slot in which the required
--   threshold of endorsement was met. At this point a further <tt>2k</tt>
--   slots need to pass before the update becomes a stable candidate and
--   can be adopted.
--   
--   We additionally record the <a>EpochNo</a> in which the candidate will
--   be adopted, <i>if</i> it becomes stable.
UpdateCandidate :: SlotNo -> EpochNo -> UpdateState

-- | The endorsements are stable. The update will be accepted.
--   
--   We record the <a>EpochNo</a> of the epoch in which it will become
--   active.
UpdateStableCandidate :: EpochNo -> UpdateState

-- | All proposal updates, from new to old
protocolUpdates :: LedgerConfig ByronBlock -> LedgerState ByronBlock -> [ProtocolUpdate]
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.UpdateState
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.UpdateState
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.ProtocolUpdate
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.ProtocolUpdate
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance Ouroboros.Consensus.Ledger.Inspect.InspectLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Forge
forgeByronBlock :: HasCallStack => TopLevelConfig ByronBlock -> TxOverrides ByronBlock -> BlockNo -> SlotNo -> TickedLedgerState ByronBlock -> [Validated (GenTx ByronBlock)] -> PBftIsLeader PBftByronCrypto -> ByronBlock
forgeRegularBlock :: HasCallStack => BlockConfig ByronBlock -> TxOverrides ByronBlock -> BlockNo -> SlotNo -> TickedLedgerState ByronBlock -> [Validated (GenTx ByronBlock)] -> PBftIsLeader PBftByronCrypto -> ByronBlock
forgeEBB :: BlockConfig ByronBlock -> SlotNo -> BlockNo -> ChainHash ByronBlock -> ByronBlock

module Ouroboros.Consensus.Byron.Ledger

module Ouroboros.Consensus.Byron.Node.Serialisation
instance Ouroboros.Consensus.Storage.Serialisation.HasBinaryBlockInfo Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.ChainDB.Impl.Types.SerialiseDiskConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Protocol.PBFT.State.PBftState Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Protocol.PBFT.State.PBftState Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.HeaderValidation.AnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.HeaderValidation.AnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Run.SerialiseNodeToNodeConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Network.Block.Serialised Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Storage.Serialisation.SerialisedHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Run.SerialiseNodeToClientConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Network.Block.Serialised Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Cardano.Slotting.Slot.SlotNo
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Cardano.Chain.Byron.API.Mempool.ApplyMempoolPayloadErr
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Util.SomeSecond Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseResult Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.ReconstructNestedCtxt Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Node
newtype () => PBftSignatureThreshold
PBftSignatureThreshold :: Double -> PBftSignatureThreshold
[getPBftSignatureThreshold] :: PBftSignatureThreshold -> Double
blockForgingByron :: Monad m => ProtocolParams ByronBlock -> [BlockForging m ByronBlock]
byronBlockForging :: Monad m => TxOverrides ByronBlock -> ByronLeaderCredentials -> BlockForging m ByronBlock

-- | Credentials needed to produce blocks in the Byron era.
data ByronLeaderCredentials
ByronLeaderCredentials :: SigningKey -> Certificate -> CoreNodeId -> Text -> ByronLeaderCredentials
[$sel:blcSignKey:ByronLeaderCredentials] :: ByronLeaderCredentials -> SigningKey
[$sel:blcDlgCert:ByronLeaderCredentials] :: ByronLeaderCredentials -> Certificate

-- | Only core nodes can produce blocks. The <a>CoreNodeId</a> is used to
--   determine the order (round-robin) in which core nodes produce blocks.
[$sel:blcCoreNodeId:ByronLeaderCredentials] :: ByronLeaderCredentials -> CoreNodeId

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[$sel:blcLabel:ByronLeaderCredentials] :: ByronLeaderCredentials -> Text
data ByronLeaderCredentialsError

-- | Make the <a>ByronLeaderCredentials</a>, with a couple sanity checks:
--   
--   <ul>
--   <li>That the block signing key and the delegation certificate
--   match.</li>
--   <li>That the delegation certificate does correspond to one of the
--   genesis keys from the genesis file.</li>
--   </ul>
mkByronLeaderCredentials :: Config -> SigningKey -> Certificate -> Text -> Either ByronLeaderCredentialsError ByronLeaderCredentials
mkPBftCanBeLeader :: ByronLeaderCredentials -> CanBeLeader (PBft PBftByronCrypto)
data family ProtocolParams blk

-- | See chapter 4.1 of
--   <a>https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/byronChainSpec/latest/download-by-type/doc-pdf/blockchain-spec</a>
defaultPBftSignatureThreshold :: PBftSignatureThreshold
mkByronConfig :: Config -> ProtocolVersion -> SoftwareVersion -> BlockConfig ByronBlock
protocolClientInfoByron :: EpochSlots -> ProtocolClientInfo ByronBlock
protocolInfoByron :: ProtocolParams ByronBlock -> ProtocolInfo ByronBlock
instance GHC.Show.Show Ouroboros.Consensus.Byron.Node.ByronLeaderCredentials
instance GHC.Show.Show Ouroboros.Consensus.Byron.Node.ByronLeaderCredentialsError
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Node.ByronLeaderCredentialsError
instance Ouroboros.Consensus.Config.SupportsNode.ConfigSupportsNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.InitStorage.NodeInitStorage Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Block.SupportsMetrics.BlockSupportsMetrics Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Run.RunNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock


-- | Module defining the crypto primitives used throughout Shelley based
--   eras.
module Ouroboros.Consensus.Shelley.Crypto
data () => StandardCrypto

module Ouroboros.Consensus.Shelley.Eras
data () => AllegraEra c
data () => AlonzoEra c
data () => BabbageEra c
data () => ConwayEra c
data () => MaryEra era
data () => ShelleyEra c

-- | The Allegra era with standard crypto
type StandardAllegra = AllegraEra StandardCrypto

-- | The Alonzo era with standard crypto
type StandardAlonzo = AlonzoEra StandardCrypto

-- | The Babbage era with standard crypto
type StandardBabbage = BabbageEra StandardCrypto

-- | The Conway era with standard crypto
type StandardConway = ConwayEra StandardCrypto

-- | The Mary era with standard crypto
type StandardMary = MaryEra StandardCrypto

-- | The Shelley era with standard crypto
type StandardShelley = ShelleyEra StandardCrypto
data ConwayEraGovDict era
[ConwayEraGovDict] :: ConwayEraGov era => ConwayEraGovDict era

-- | Consensus often needs some more functionality than the ledger
--   currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   If this class becomes redundant, We can move it to ledger and
--   re-export it from here.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/IntersectMBO/ouroboros-network/issues/2890</a>
class (EraSegWits era, EraGov era, ApplyTx era, ApplyBlock era, EraTransition era, GetLedgerView era, NoThunks (StashedAVVMAddresses era), EncCBOR (StashedAVVMAddresses era), DecCBOR (StashedAVVMAddresses era), Show (StashedAVVMAddresses era), Eq (StashedAVVMAddresses era), DecCBOR (PredicateFailure (EraRule "LEDGER" era)), EncCBOR (PredicateFailure (EraRule "LEDGER" era)), DecCBOR (PredicateFailure (EraRule "UTXOW" era)), EncCBOR (PredicateFailure (EraRule "UTXOW" era)), DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody), NoThunks (PredicateFailure (EraRule "BBODY" era)), NoThunks (TranslationContext era)) => ShelleyBasedEra era

-- | Return the name of the Shelley-based era, e.g.,
--   <tt><a>Shelley</a></tt>, <tt><a>Allegra</a></tt>, etc.
shelleyBasedEraName :: ShelleyBasedEra era => proxy era -> Text
applyShelleyBasedTx :: ShelleyBasedEra era => Globals -> LedgerEnv era -> LedgerState era -> WhetherToIntervene -> Tx era -> Except (ApplyTxError era) (LedgerState era, Validated (Tx era))

-- | Get the protocol version out of a <a>PParamsUpdate</a>, used to detect
--   whether we should perform a HF. This will likely be removed/changed
--   once we implement HF enactment in Conway (see
--   <a>https://github.com/IntersectMBO/ouroboros-consensus/issues/61</a>).
--   
--   For now, this always returns <a>Nothing</a> for Conway (see the
--   instance below).
getProposedProtocolVersion :: ShelleyBasedEra era => PParamsUpdate era -> Maybe ProtVer

-- | Whether the era has an instance of <a>ConwayEraGov</a>
getConwayEraGovDict :: ShelleyBasedEra era => proxy era -> Maybe (ConwayEraGovDict era)

-- | Wrapper for partially applying the <a>Tx</a> type family
--   
--   For generality, Consensus uses that type family as eg the index of
--   <a>TranslateEra</a>. We thus need to partially apply it.
--   
--   <tt>cardano-ledger-specs</tt> also declares such a newtype, but
--   currently it's only defined in the Alonzo translation module, which
--   seems somewhat inappropriate to use for previous eras. Also, we use a
--   <tt>Wrap</tt> prefix in Consensus. Hence this minor mediating
--   definition. TODO I'm not even fully persuading myself with this
--   justification.
newtype WrapTx era
WrapTx :: Tx era -> WrapTx era
[unwrapTx] :: WrapTx era -> Tx era
type family EraCrypto era
data () => StandardCrypto
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Allegra.Era.AllegraEra c) => Cardano.Ledger.Core.Translation.TranslateEra (Cardano.Ledger.Allegra.Era.AllegraEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Mary.Era.MaryEra c) => Cardano.Ledger.Core.Translation.TranslateEra (Cardano.Ledger.Mary.Era.MaryEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Alonzo.Era.AlonzoEra c) => Cardano.Ledger.Core.Translation.TranslateEra (Cardano.Ledger.Alonzo.Era.AlonzoEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Babbage.Era.BabbageEra c) => Cardano.Ledger.Core.Translation.TranslateEra (Cardano.Ledger.Babbage.Era.BabbageEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Conway.Era.ConwayEra c) => Cardano.Ledger.Core.Translation.TranslateEra (Cardano.Ledger.Conway.Era.ConwayEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.SupportsTwoPhaseValidation (Cardano.Ledger.Alonzo.Era.AlonzoEra c)
instance Ouroboros.Consensus.Shelley.Eras.SupportsTwoPhaseValidation (Cardano.Ledger.Babbage.Era.BabbageEra c)
instance Ouroboros.Consensus.Shelley.Eras.SupportsTwoPhaseValidation (Cardano.Ledger.Conway.Era.ConwayEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.Internal.DSignable c (Cardano.Ledger.Keys.Internal.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.Internal.DSignable c (Cardano.Ledger.Keys.Internal.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Allegra.Era.AllegraEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.Internal.DSignable c (Cardano.Ledger.Keys.Internal.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Mary.Era.MaryEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.Internal.DSignable c (Cardano.Ledger.Keys.Internal.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Alonzo.Era.AlonzoEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Babbage.Era.BabbageEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Conway.Era.ConwayEra c)


-- | Commonality between multiple protocols.
--   
--   Everything in this module is indexed on the protocol (or the crypto),
--   rather than on the block type. This allows it to be imported in
--   <tt>Ouroboros.Consensus.Shelley.Ledger.Block</tt>.
module Ouroboros.Consensus.Shelley.Protocol.Abstract
type family ProtoCrypto proto :: Type

-- | Indicates that the header (determined by the protocol) supports "
--   Envelope " functionality. Envelope functionality refers to the minimal
--   functionality required to construct a chain.
class (Eq (EnvelopeCheckError proto), NoThunks (EnvelopeCheckError proto), Show (EnvelopeCheckError proto)) => ProtocolHeaderSupportsEnvelope proto where {
    type EnvelopeCheckError proto :: Type;
}
pHeaderHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> ShelleyHash (ProtoCrypto proto)
pHeaderPrevHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> PrevHash (ProtoCrypto proto)
pHeaderBodyHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Hash (ProtoCrypto proto) EraIndependentBlockBody
pHeaderSlot :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> SlotNo
pHeaderBlock :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> BlockNo
pHeaderSize :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Natural
pHeaderBlockSize :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Natural

-- | Carry out any protocol-specific envelope checks. For example, this
--   might check things like maximum header size.
envelopeChecks :: ProtocolHeaderSupportsEnvelope proto => ConsensusConfig proto -> LedgerView proto -> ShelleyProtocolHeader proto -> Except (EnvelopeCheckError proto) ()

-- | <a>ProtocolHeaderSupportsKES</a> describes functionality common to
--   protocols using key evolving signature schemes. This includes
--   verifying the header integrity (e.g. validating the KES signature), as
--   well as constructing the header (made specific to KES-using protocols
--   through the need to handle the hot key).
class ProtocolHeaderSupportsKES proto

-- | Extract the "slots per KES period" value from the protocol config.
--   
--   Note that we do not require <a>ConsensusConfig</a> in
--   <a>verifyHeaderIntegrity</a> since that function is also invoked with
--   <tt>StorageConfig</tt>.
configSlotsPerKESPeriod :: ProtocolHeaderSupportsKES proto => ConsensusConfig proto -> Word64

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool
mkHeader :: forall crypto m. (ProtocolHeaderSupportsKES proto, Crypto crypto, Monad m, crypto ~ ProtoCrypto proto) => HotKey crypto m -> CanBeLeader proto -> IsLeader proto -> SlotNo -> BlockNo -> PrevHash crypto -> Hash crypto EraIndependentBlockBody -> Int -> ProtVer -> m (ShelleyProtocolHeader proto)

-- | Indicates that the protocol header supports the Shelley ledger. We may
--   need to generalise this if, in the future, the ledger requires
--   different things from the protocol.
class ProtocolHeaderSupportsLedger proto
mkHeaderView :: ProtocolHeaderSupportsLedger proto => ShelleyProtocolHeader proto -> BHeaderView (ProtoCrypto proto)

-- | ProtocolHeaderSupportsProtocol` provides support for the concrete
--   block header to support the <a>ConsensusProtocol</a> itself.
class ProtocolHeaderSupportsProtocol proto where {
    type CannotForgeError proto :: Type;
}
protocolHeaderView :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> ValidateView proto
pHeaderIssuer :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> VKey 'BlockIssuer (ProtoCrypto proto)
pHeaderIssueNo :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> Word64

-- | A VRF value in the header, used to choose between otherwise equally
--   preferable chains.
pTieBreakVRFValue :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> OutputVRF (VRF (ProtoCrypto proto))
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader
class (ConsensusProtocol proto, Typeable (ShelleyProtocolHeader proto), ProtocolHeaderSupportsEnvelope proto, ProtocolHeaderSupportsKES proto, ProtocolHeaderSupportsProtocol proto, ProtocolHeaderSupportsLedger proto, Serialise (ChainDepState proto), SignedHeader (ShelleyProtocolHeader proto)) => ShelleyProtocol proto

-- | Shelley header, determined by the associated protocol.
type family ShelleyProtocolHeader proto = (sh :: Type) | sh -> proto
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Classes.Ord (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Codec.Serialise.Class.Serialise (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)

module Ouroboros.Consensus.Shelley.Ledger.Block
class HasHeader Header blk => GetHeader blk
getHeader :: GetHeader blk => blk -> Header blk
blockMatchesHeader :: GetHeader blk => Header blk -> blk -> Bool
headerIsEBB :: GetHeader blk => Header blk -> Maybe EpochNo
data family Header blk
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type

-- | Consensus often needs some more functionality than the ledger
--   currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   If this class becomes redundant, We can move it to ledger and
--   re-export it from here.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/IntersectMBO/ouroboros-network/issues/2890</a>
class (EraSegWits era, EraGov era, ApplyTx era, ApplyBlock era, EraTransition era, GetLedgerView era, NoThunks (StashedAVVMAddresses era), EncCBOR (StashedAVVMAddresses era), DecCBOR (StashedAVVMAddresses era), Show (StashedAVVMAddresses era), Eq (StashedAVVMAddresses era), DecCBOR (PredicateFailure (EraRule "LEDGER" era)), EncCBOR (PredicateFailure (EraRule "LEDGER" era)), DecCBOR (PredicateFailure (EraRule "UTXOW" era)), EncCBOR (PredicateFailure (EraRule "UTXOW" era)), DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody), NoThunks (PredicateFailure (EraRule "BBODY" era)), NoThunks (TranslationContext era)) => ShelleyBasedEra era

-- | Shelley-based block type.
--   
--   This block is parametrised over both the (ledger) era and the
--   protocol.
data ShelleyBlock proto era
ShelleyBlock :: !Block (ShelleyProtocolHeader proto) era -> !ShelleyHash (ProtoCrypto proto) -> ShelleyBlock proto era
[shelleyBlockRaw] :: ShelleyBlock proto era -> !Block (ShelleyProtocolHeader proto) era
[shelleyBlockHeaderHash] :: ShelleyBlock proto era -> !ShelleyHash (ProtoCrypto proto)
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader
class (ShelleyBasedEra era, ShelleyProtocol proto, Eq (ShelleyProtocolHeader proto), Show (ShelleyProtocolHeader proto), NoThunks (ShelleyProtocolHeader proto), EncCBOR (ShelleyProtocolHeader proto), DecCBOR (Annotator (ShelleyProtocolHeader proto)), Show (CannotForgeError proto), SelectView proto ~ PraosChainSelectView (EraCrypto era), SignedHeader (ShelleyProtocolHeader proto), DecodeDisk (ShelleyBlock proto era) (ChainDepState proto), EncodeDisk (ShelleyBlock proto era) (ChainDepState proto), EraCrypto era ~ ProtoCrypto proto, HasPartialConsensusConfig proto, DecCBOR (PState era), FromCBOR (LegacyPParams era), ToCBOR (LegacyPParams era)) => ShelleyCompatible proto era
mkShelleyBlock :: ShelleyCompatible proto era => Block (ShelleyProtocolHeader proto) era -> ShelleyBlock proto era
mkShelleyHeader :: ShelleyCompatible proto era => ShelleyProtocolHeader proto -> Header (ShelleyBlock proto era)
decodeShelleyBlock :: forall proto era. ShelleyCompatible proto era => forall s. Decoder s (ByteString -> ShelleyBlock proto era)
decodeShelleyHeader :: forall proto era. ShelleyCompatible proto era => forall s. Decoder s (ByteString -> Header (ShelleyBlock proto era))
encodeShelleyBlock :: forall proto era. ShelleyCompatible proto era => ShelleyBlock proto era -> Encoding
encodeShelleyHeader :: forall proto era. ShelleyCompatible proto era => Header (ShelleyBlock proto era) -> Encoding
shelleyBinaryBlockInfo :: forall proto era. ShelleyCompatible proto era => ShelleyBlock proto era -> BinaryBlockInfo

-- | From <tt>cardano-ledger-specs</tt> to <tt>ouroboros-consensus</tt>
fromShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => PrevHash (EraCrypto era) -> ChainHash (ShelleyBlock proto era)

-- | From <tt>ouroboros-consensus</tt> to <tt>cardano-ledger-specs</tt>
toShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => ChainHash (Header (ShelleyBlock proto era)) -> PrevHash (EraCrypto era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Classes.Eq (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Show.Show (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f a)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.ConvertRawHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.GetHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.GetPrevHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.StandardHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.HasAnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.DepPair.TrivialDependency (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f)
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f)
instance Ouroboros.Consensus.Block.NestedContent.HasNestedContent f (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion
data ShelleyNodeToClientVersion
ShelleyNodeToClientVersion1 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion2 :: ShelleyNodeToClientVersion

-- | New query introduced
ShelleyNodeToClientVersion3 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion4 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetRewardInfoPools
ShelleyNodeToClientVersion5 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetPoolDistr, GetPoolState, GetStakeSnapshots
ShelleyNodeToClientVersion6 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetStakeDelegDeposits
ShelleyNodeToClientVersion7 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetConstitutionHash, GetFilteredVoteDelegatees
ShelleyNodeToClientVersion8 :: ShelleyNodeToClientVersion
data ShelleyNodeToNodeVersion
ShelleyNodeToNodeVersion1 :: ShelleyNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.HasNetworkProtocolVersion (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Integrity

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
verifyBlockIntegrity :: ShelleyCompatible proto era => Word64 -> ShelleyBlock proto era -> Bool

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool

module Ouroboros.Consensus.Shelley.Ledger.Config
data family BlockConfig blk
data family CodecConfig blk
data family StorageConfig blk

-- | Compacts the given <a>ShelleyGenesis</a>.
compactGenesis :: ShelleyGenesis c -> CompactGenesis c
getCompactGenesis :: CompactGenesis c -> ShelleyGenesis c
mkShelleyBlockConfig :: ShelleyBasedEra era => ProtVer -> ShelleyGenesis (EraCrypto era) -> [VKey 'BlockIssuer (EraCrypto era)] -> BlockConfig (ShelleyBlock proto era)

-- | Compact variant of <a>ShelleyGenesis</a> with some fields erased that
--   are only used on start-up and that should not be kept in memory
--   forever.
--   
--   Concretely:
--   
--   <ul>
--   <li>The <tt>sgInitialFunds</tt> field is erased. It is only used to
--   set up the initial UTxO in tests and testnets.</li>
--   <li>The <tt>sgStaking</tt> field is erased. It is only used to
--   register initial stake pools in tests and benchmarks.</li>
--   </ul>
data CompactGenesis c
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.CodecConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.CodecConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.StorageConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.StorageConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis c)

module Ouroboros.Consensus.Shelley.Ledger.Protocol
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.SupportsProtocol.BlockSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocolHeader proto) => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))

module Ouroboros.Consensus.Shelley.Ledger.Ledger
data family LedgerState blk

-- | Consensus often needs some more functionality than the ledger
--   currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   If this class becomes redundant, We can move it to ledger and
--   re-export it from here.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/IntersectMBO/ouroboros-network/issues/2890</a>
class (EraSegWits era, EraGov era, ApplyTx era, ApplyBlock era, EraTransition era, GetLedgerView era, NoThunks (StashedAVVMAddresses era), EncCBOR (StashedAVVMAddresses era), DecCBOR (StashedAVVMAddresses era), Show (StashedAVVMAddresses era), Eq (StashedAVVMAddresses era), DecCBOR (PredicateFailure (EraRule "LEDGER" era)), EncCBOR (PredicateFailure (EraRule "LEDGER" era)), DecCBOR (PredicateFailure (EraRule "UTXOW" era)), EncCBOR (PredicateFailure (EraRule "UTXOW" era)), DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody), NoThunks (PredicateFailure (EraRule "BBODY" era)), NoThunks (TranslationContext era)) => ShelleyBasedEra era
newtype ShelleyLedgerError era
BBodyError :: BlockTransitionError era -> ShelleyLedgerError era
data ShelleyTip proto era
ShelleyTip :: !SlotNo -> !BlockNo -> !HeaderHash (ShelleyBlock proto era) -> ShelleyTip proto era
[shelleyTipSlotNo] :: ShelleyTip proto era -> !SlotNo
[shelleyTipBlockNo] :: ShelleyTip proto era -> !BlockNo
[shelleyTipHash] :: ShelleyTip proto era -> !HeaderHash (ShelleyBlock proto era)

-- | Information required to determine the hard fork point from Shelley to
--   the next ledger
newtype ShelleyTransition
ShelleyTransitionInfo :: Word32 -> ShelleyTransition

-- | The number of blocks in this epoch past the voting deadline
--   
--   We record this to make sure that we can tell the HFC about hard forks
--   if and only if we are certain:
--   
--   <ol>
--   <li>Blocks that came in within an epoch after the 4k/f voting deadline
--   are not relevant (10k<i>f - 2 * 3k</i>f).</li>
--   <li>Since there are slots between blocks, we are probably only sure
--   that there will be no more relevant block when we have seen the first
--   block after the deadline.</li>
--   <li>If we count how many blocks we have seen post deadline, and we
--   have reached k of them, we know that that last pre-deadline block
--   won't be rolled back anymore.</li>
--   <li>At this point we can look at the ledger state and see which
--   proposals we accepted in the voting period, if any, and notify the HFC
--   is one of them indicates a transition.</li>
--   </ol>
[shelleyAfterVoting] :: ShelleyTransition -> Word32
data family Ticked st
castShelleyTip :: HeaderHash (ShelleyBlock proto era) ~ HeaderHash (ShelleyBlock proto' era') => ShelleyTip proto era -> ShelleyTip proto' era'
shelleyLedgerTipPoint :: LedgerState (ShelleyBlock proto era) -> Point (ShelleyBlock proto era)
shelleyTipToPoint :: WithOrigin (ShelleyTip proto era) -> Point (ShelleyBlock proto era)
data ShelleyLedgerConfig era
ShelleyLedgerConfig :: !CompactGenesis (EraCrypto era) -> !Globals -> !TranslationContext era -> ShelleyLedgerConfig era
[shelleyLedgerCompactGenesis] :: ShelleyLedgerConfig era -> !CompactGenesis (EraCrypto era)

-- | Derived from <a>shelleyLedgerGenesis</a> but we store a cached version
--   because it used very often.
[shelleyLedgerGlobals] :: ShelleyLedgerConfig era -> !Globals
[shelleyLedgerTranslationContext] :: ShelleyLedgerConfig era -> !TranslationContext era
mkShelleyLedgerConfig :: ShelleyGenesis (EraCrypto era) -> TranslationContext era -> EpochInfo (Except PastHorizonException) -> MaxMajorProtVer -> ShelleyLedgerConfig era
shelleyEraParams :: ShelleyGenesis c -> EraParams

-- | Separate variant of <a>shelleyEraParams</a> to be used for a
--   Shelley-only chain.
shelleyEraParamsNeverHardForks :: ShelleyGenesis c -> EraParams
shelleyLedgerGenesis :: ShelleyLedgerConfig era -> ShelleyGenesis (EraCrypto era)

-- | All events emitted by the Shelley ledger API
data ShelleyLedgerEvent era

-- | An event emitted when (re)applying a block
ShelleyLedgerEventBBODY :: Event (EraRule "BBODY" era) -> ShelleyLedgerEvent era

-- | An event emitted during the chain tick
ShelleyLedgerEventTICK :: Event (EraRule "TICK" era) -> ShelleyLedgerEvent era
data ShelleyReapplyException
ShelleyReapplyException :: BlockTransitionError era -> ShelleyReapplyException
getPParams :: EraGov era => NewEpochState era -> PParams era
decodeShelleyAnnTip :: ShelleyCompatible proto era => Decoder s (AnnTip (ShelleyBlock proto era))
decodeShelleyLedgerState :: forall era proto s. ShelleyCompatible proto era => Decoder s (LedgerState (ShelleyBlock proto era))
encodeShelleyAnnTip :: ShelleyCompatible proto era => AnnTip (ShelleyBlock proto era) -> Encoding
encodeShelleyHeaderState :: ShelleyCompatible proto era => HeaderState (ShelleyBlock proto era) -> Encoding
encodeShelleyLedgerState :: ShelleyCompatible proto era => LedgerState (ShelleyBlock proto era) -> Encoding
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerConfig era)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.Translation.TranslationContext era), Cardano.Ledger.Core.Era.Era era) => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerConfig era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.Abstract.ApplyBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyReapplyException
instance GHC.Exception.Type.Exception Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyReapplyException
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.Basics.IsLedger (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.Abstract.UpdateLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.HardFork.Abstract.HasHardForkHistory (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.CommonProtocolParams.CommonProtocolParams (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.BasicEnvelopeValidation (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.ValidateEnvelope (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Query
data family BlockQuery blk :: Type -> Type
newtype NonMyopicMemberRewards c
NonMyopicMemberRewards :: Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin) -> NonMyopicMemberRewards c
[unNonMyopicMemberRewards] :: NonMyopicMemberRewards c -> Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin)

-- | The stake snapshot returns information about the mark, set, go ledger
--   snapshots for a pool, plus the total active stake for each snapshot
--   that can be used in a <tt>sigma</tt> calculation.
--   
--   Each snapshot is taken at the end of a different era. The go snapshot
--   is the current one and was taken two epochs earlier, set was taken one
--   epoch ago, and mark was taken immediately before the start of the
--   current epoch.
data StakeSnapshot crypto
StakeSnapshot :: !Coin -> !Coin -> !Coin -> StakeSnapshot crypto
[ssMarkPool] :: StakeSnapshot crypto -> !Coin
[ssSetPool] :: StakeSnapshot crypto -> !Coin
[ssGoPool] :: StakeSnapshot crypto -> !Coin
data StakeSnapshots crypto
StakeSnapshots :: !Map (KeyHash 'StakePool crypto) (StakeSnapshot crypto) -> !Coin -> !Coin -> !Coin -> StakeSnapshots crypto
[ssStakeSnapshots] :: StakeSnapshots crypto -> !Map (KeyHash 'StakePool crypto) (StakeSnapshot crypto)
[ssMarkTotal] :: StakeSnapshots crypto -> !Coin
[ssSetTotal] :: StakeSnapshots crypto -> !Coin
[ssGoTotal] :: StakeSnapshots crypto -> !Coin

-- | Is the given query supported by the given
--   <a>ShelleyNodeToClientVersion</a>?
querySupportedVersion :: BlockQuery (ShelleyBlock proto era) result -> ShelleyNodeToClientVersion -> Bool
decodeShelleyQuery :: forall era proto. ShelleyBasedEra era => forall s. Decoder s (SomeSecond BlockQuery (ShelleyBlock proto era))
decodeShelleyResult :: forall proto era result. ShelleyCompatible proto era => ShelleyNodeToClientVersion -> BlockQuery (ShelleyBlock proto era) result -> forall s. Decoder s result
encodeShelleyQuery :: forall era proto result. ShelleyBasedEra era => BlockQuery (ShelleyBlock proto era) result -> Encoding
encodeShelleyResult :: forall proto era result. ShelleyCompatible proto era => ShelleyNodeToClientVersion -> BlockQuery (ShelleyBlock proto era) result -> result -> Encoding
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) result)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) result)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtoCrypto proto GHC.Types.~ crypto) => Ouroboros.Consensus.Ledger.Query.QueryLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Control.DeepSeq.NFData (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshots crypto)
instance Control.DeepSeq.NFData (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Ledger.Query.StakeSnapshot crypto)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))

module Ouroboros.Consensus.Shelley.Ledger.PeerSelection
instance (c GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era) => Ouroboros.Consensus.Ledger.SupportsPeerSelection.LedgerSupportsPeerSelection (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)


-- | Shelley mempool integration
module Ouroboros.Consensus.Shelley.Ledger.Mempool
data family GenTx blk
newtype () => ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era
data family TxId tx
data family Validated x

-- | Add a unique top element to a lattice.
--   
--   TODO This should be relocated to `cardano-base:Data.Measure'.
data WithTop a
NotTop :: a -> WithTop a
Top :: WithTop a

-- | <a>txInBlockSize</a> is used to estimate how many transactions we can
--   grab from the Mempool to put into the block we are going to forge
--   without exceeding the maximum block body size according to the ledger.
--   If we exceed that limit, we will have forged a block that is invalid
--   according to the ledger. We ourselves won't even adopt it, causing us
--   to lose our slot, something we must try to avoid.
--   
--   For this reason it is better to overestimate the size of a transaction
--   than to underestimate. The only downside is that we maybe could have
--   put one (or more?) transactions extra in that block.
--   
--   As the sum of the serialised transaction sizes is not equal to the
--   size of the serialised block body (<a>TxSeq</a>) consisting of those
--   transactions (see cardano-node#1545 for an example), we account for
--   some extra overhead per transaction as a safety margin.
--   
--   Also see <a>perTxOverhead</a>.
fixedBlockBodyOverhead :: Num a => a
mkShelleyTx :: forall era proto. ShelleyBasedEra era => Tx era -> GenTx (ShelleyBlock proto era)
mkShelleyValidatedTx :: forall era proto. ShelleyBasedEra era => Validated (Tx era) -> Validated (GenTx (ShelleyBlock proto era))

-- | See <a>fixedBlockBodyOverhead</a>.
perTxOverhead :: Num a => a
data AlonzoMeasure
AlonzoMeasure :: !ByteSize -> !ExUnits' (WithTop Natural) -> AlonzoMeasure
[byteSize] :: AlonzoMeasure -> !ByteSize
[exUnits] :: AlonzoMeasure -> !ExUnits' (WithTop Natural)
fromExUnits :: ExUnits -> ExUnits' (WithTop Natural)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Classes.Ord (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance Data.Measure.Class.BoundedMeasure Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era), Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era), Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Alonzo.Era.AlonzoEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Alonzo.Era.AlonzoEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Babbage.Era.BabbageEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Babbage.Era.BabbageEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Conway.Era.ConwayEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Conway.Era.ConwayEra c))
instance GHC.Classes.Ord a => GHC.Classes.Ord (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.Measure (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.BoundedMeasure (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Data.Typeable.Internal.Typeable era => Ouroboros.Network.Util.ShowProxy.ShowProxy (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.SupportsMempool.LedgerSupportsMempool (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.SupportsMempool.HasTxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.SupportsMempool.HasTxs (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Shelley.Era.ShelleyEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Allegra.Era.AllegraEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Allegra.Era.AllegraEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Mary.Era.MaryEra c) => Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Mary.Era.MaryEra c))

module Ouroboros.Consensus.Shelley.Ledger.Inspect
data ProtocolUpdate era
ProtocolUpdate :: UpdateProposal era -> UpdateState (EraCrypto era) -> ProtocolUpdate era
[protocolUpdateProposal] :: ProtocolUpdate era -> UpdateProposal era
[protocolUpdateState] :: ProtocolUpdate era -> UpdateState (EraCrypto era)
data ShelleyLedgerUpdate era
ShelleyUpdatedProtocolUpdates :: [ProtocolUpdate era] -> ShelleyLedgerUpdate era

-- | Update proposal
--   
--   As in Byron, a proposal is a partial map from parameters to their
--   values.
data UpdateProposal era
UpdateProposal :: PParamsUpdate era -> Maybe ProtVer -> EpochNo -> UpdateProposal era

-- | The protocol parameters changed by this update proposal
--   
--   An update is <i>identified</i> by how it updates the protocol
--   parameters.
[proposalParams] :: UpdateProposal era -> PParamsUpdate era

-- | New version (if changed by this proposal)
--   
--   The protocol version itself is also considered to be just another
--   parameter, and parameters can change <i>without</i> changing the
--   protocol version, although a convention <i>could</i> be established
--   that the protocol version must change if any of the parameters do; but
--   the specification itself does not mandate this.
--   
--   We record the version separately for the convenience of the HFC.
[proposalVersion] :: UpdateProposal era -> Maybe ProtVer

-- | The <a>EpochNo</a> the proposal becomes active in, if it is adopted
[proposalEpoch] :: UpdateProposal era -> EpochNo

-- | Proposal state
--   
--   The update mechanism in Shelley is simpler than it is in Byron. There
--   is no distinction between votes and proposals: to "vote" for a
--   proposal one merely submits the exact same proposal. There is also no
--   separate endorsement step. The procedure is as follows:
--   
--   <ol>
--   <li>During each epoch, a genesis key can submit (via its delegates)
--   zero, one, or many proposals; each submission overrides the previous
--   one.</li>
--   <li>"Voting" (submitting of proposals) ends <tt>2 *
--   stabilityWindow</tt> slots (i.e. <tt>6k/f</tt>) before the end of the
--   epoch. In other words, proposals for the upcoming epoch must be
--   submitted within the first <tt>4k/f</tt> slots of this one.</li>
--   <li>At the end of an epoch, if the majority of nodes (as determined by
--   the <tt>Quorum</tt> specification constant, which must be greater than
--   half the nodes) have most recently submitted the same exact proposal,
--   then it is adopted.</li>
--   <li>The next epoch is always started with a clean slate, proposals
--   from the previous epoch that didn't make it are discarded (except for
--   "future proposals" that are explicitly marked for future epochs).</li>
--   </ol>
data UpdateState c
UpdateState :: [KeyHash 'Genesis c] -> Bool -> UpdateState c

-- | The genesis delegates that voted for this proposal
[proposalVotes] :: UpdateState c -> [KeyHash 'Genesis c]

-- | Has this proposal reached sufficient votes to be adopted?
[proposalReachedQuorum] :: UpdateState c -> Bool
protocolUpdates :: forall era proto. ShelleyBasedEra era => ShelleyGenesis (EraCrypto era) -> LedgerState (ShelleyBlock proto era) -> [ProtocolUpdate era]
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateState c)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateState c)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.ProtocolUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.ProtocolUpdate era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateProposal era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateProposal era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.Inspect.InspectLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Forge
forgeShelleyBlock :: forall m era proto. (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), Monad m) => HotKey (EraCrypto era) m -> CanBeLeader proto -> TopLevelConfig (ShelleyBlock proto era) -> TxOverrides (ShelleyBlock proto era) -> BlockNo -> SlotNo -> TickedLedgerState (ShelleyBlock proto era) -> [Validated (GenTx (ShelleyBlock proto era))] -> IsLeader proto -> m (ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger
data family Header blk
data family BlockConfig blk
data family CodecConfig blk
data family StorageConfig blk
data family BlockQuery blk :: Type -> Type
data family LedgerState blk
data family Ticked st
data family GenTx blk
data family TxId tx
data family Validated x
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type

-- | Shelley-based block type.
--   
--   This block is parametrised over both the (ledger) era and the
--   protocol.
data ShelleyBlock proto era
ShelleyBlock :: !Block (ShelleyProtocolHeader proto) era -> !ShelleyHash (ProtoCrypto proto) -> ShelleyBlock proto era
[shelleyBlockRaw] :: ShelleyBlock proto era -> !Block (ShelleyProtocolHeader proto) era
[shelleyBlockHeaderHash] :: ShelleyBlock proto era -> !ShelleyHash (ProtoCrypto proto)
class (ShelleyBasedEra era, ShelleyProtocol proto, Eq (ShelleyProtocolHeader proto), Show (ShelleyProtocolHeader proto), NoThunks (ShelleyProtocolHeader proto), EncCBOR (ShelleyProtocolHeader proto), DecCBOR (Annotator (ShelleyProtocolHeader proto)), Show (CannotForgeError proto), SelectView proto ~ PraosChainSelectView (EraCrypto era), SignedHeader (ShelleyProtocolHeader proto), DecodeDisk (ShelleyBlock proto era) (ChainDepState proto), EncodeDisk (ShelleyBlock proto era) (ChainDepState proto), EraCrypto era ~ ProtoCrypto proto, HasPartialConsensusConfig proto, DecCBOR (PState era), FromCBOR (LegacyPParams era), ToCBOR (LegacyPParams era)) => ShelleyCompatible proto era

-- | Consensus often needs some more functionality than the ledger
--   currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   If this class becomes redundant, We can move it to ledger and
--   re-export it from here.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/IntersectMBO/ouroboros-network/issues/2890</a>
class (EraSegWits era, EraGov era, ApplyTx era, ApplyBlock era, EraTransition era, GetLedgerView era, NoThunks (StashedAVVMAddresses era), EncCBOR (StashedAVVMAddresses era), DecCBOR (StashedAVVMAddresses era), Show (StashedAVVMAddresses era), Eq (StashedAVVMAddresses era), DecCBOR (PredicateFailure (EraRule "LEDGER" era)), EncCBOR (PredicateFailure (EraRule "LEDGER" era)), DecCBOR (PredicateFailure (EraRule "UTXOW" era)), EncCBOR (PredicateFailure (EraRule "UTXOW" era)), DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody), NoThunks (PredicateFailure (EraRule "BBODY" era)), NoThunks (TranslationContext era)) => ShelleyBasedEra era
class HasHeader Header blk => GetHeader blk
getHeader :: GetHeader blk => blk -> Header blk
blockMatchesHeader :: GetHeader blk => Header blk -> blk -> Bool
headerIsEBB :: GetHeader blk => Header blk -> Maybe EpochNo
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader

-- | Compact variant of <a>ShelleyGenesis</a> with some fields erased that
--   are only used on start-up and that should not be kept in memory
--   forever.
--   
--   Concretely:
--   
--   <ul>
--   <li>The <tt>sgInitialFunds</tt> field is erased. It is only used to
--   set up the initial UTxO in tests and testnets.</li>
--   <li>The <tt>sgStaking</tt> field is erased. It is only used to
--   register initial stake pools in tests and benchmarks.</li>
--   </ul>
data CompactGenesis c
newtype ShelleyLedgerError era
BBodyError :: BlockTransitionError era -> ShelleyLedgerError era
data ShelleyTip proto era
ShelleyTip :: !SlotNo -> !BlockNo -> !HeaderHash (ShelleyBlock proto era) -> ShelleyTip proto era
[shelleyTipSlotNo] :: ShelleyTip proto era -> !SlotNo
[shelleyTipBlockNo] :: ShelleyTip proto era -> !BlockNo
[shelleyTipHash] :: ShelleyTip proto era -> !HeaderHash (ShelleyBlock proto era)

-- | Information required to determine the hard fork point from Shelley to
--   the next ledger
newtype ShelleyTransition
ShelleyTransitionInfo :: Word32 -> ShelleyTransition

-- | The number of blocks in this epoch past the voting deadline
--   
--   We record this to make sure that we can tell the HFC about hard forks
--   if and only if we are certain:
--   
--   <ol>
--   <li>Blocks that came in within an epoch after the 4k/f voting deadline
--   are not relevant (10k<i>f - 2 * 3k</i>f).</li>
--   <li>Since there are slots between blocks, we are probably only sure
--   that there will be no more relevant block when we have seen the first
--   block after the deadline.</li>
--   <li>If we count how many blocks we have seen post deadline, and we
--   have reached k of them, we know that that last pre-deadline block
--   won't be rolled back anymore.</li>
--   <li>At this point we can look at the ledger state and see which
--   proposals we accepted in the voting period, if any, and notify the HFC
--   is one of them indicates a transition.</li>
--   </ol>
[shelleyAfterVoting] :: ShelleyTransition -> Word32
data ShelleyLedgerConfig era
ShelleyLedgerConfig :: !CompactGenesis (EraCrypto era) -> !Globals -> !TranslationContext era -> ShelleyLedgerConfig era
[shelleyLedgerCompactGenesis] :: ShelleyLedgerConfig era -> !CompactGenesis (EraCrypto era)

-- | Derived from <a>shelleyLedgerGenesis</a> but we store a cached version
--   because it used very often.
[shelleyLedgerGlobals] :: ShelleyLedgerConfig era -> !Globals
[shelleyLedgerTranslationContext] :: ShelleyLedgerConfig era -> !TranslationContext era

-- | All events emitted by the Shelley ledger API
data ShelleyLedgerEvent era

-- | An event emitted when (re)applying a block
ShelleyLedgerEventBBODY :: Event (EraRule "BBODY" era) -> ShelleyLedgerEvent era

-- | An event emitted during the chain tick
ShelleyLedgerEventTICK :: Event (EraRule "TICK" era) -> ShelleyLedgerEvent era
data ShelleyReapplyException
ShelleyReapplyException :: BlockTransitionError era -> ShelleyReapplyException
newtype () => ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era

-- | Add a unique top element to a lattice.
--   
--   TODO This should be relocated to `cardano-base:Data.Measure'.
data WithTop a
NotTop :: a -> WithTop a
Top :: WithTop a
data AlonzoMeasure
AlonzoMeasure :: !ByteSize -> !ExUnits' (WithTop Natural) -> AlonzoMeasure
[byteSize] :: AlonzoMeasure -> !ByteSize
[exUnits] :: AlonzoMeasure -> !ExUnits' (WithTop Natural)
data ShelleyNodeToClientVersion
ShelleyNodeToClientVersion1 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion2 :: ShelleyNodeToClientVersion

-- | New query introduced
ShelleyNodeToClientVersion3 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion4 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetRewardInfoPools
ShelleyNodeToClientVersion5 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetPoolDistr, GetPoolState, GetStakeSnapshots
ShelleyNodeToClientVersion6 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetStakeDelegDeposits
ShelleyNodeToClientVersion7 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetConstitutionHash, GetFilteredVoteDelegatees
ShelleyNodeToClientVersion8 :: ShelleyNodeToClientVersion
data ShelleyNodeToNodeVersion
ShelleyNodeToNodeVersion1 :: ShelleyNodeToNodeVersion
newtype NonMyopicMemberRewards c
NonMyopicMemberRewards :: Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin) -> NonMyopicMemberRewards c
[unNonMyopicMemberRewards] :: NonMyopicMemberRewards c -> Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin)

-- | The stake snapshot returns information about the mark, set, go ledger
--   snapshots for a pool, plus the total active stake for each snapshot
--   that can be used in a <tt>sigma</tt> calculation.
--   
--   Each snapshot is taken at the end of a different era. The go snapshot
--   is the current one and was taken two epochs earlier, set was taken one
--   epoch ago, and mark was taken immediately before the start of the
--   current epoch.
data StakeSnapshot crypto
StakeSnapshot :: !Coin -> !Coin -> !Coin -> StakeSnapshot crypto
[ssMarkPool] :: StakeSnapshot crypto -> !Coin
[ssSetPool] :: StakeSnapshot crypto -> !Coin
[ssGoPool] :: StakeSnapshot crypto -> !Coin
data StakeSnapshots crypto
StakeSnapshots :: !Map (KeyHash 'StakePool crypto) (StakeSnapshot crypto) -> !Coin -> !Coin -> !Coin -> StakeSnapshots crypto
[ssStakeSnapshots] :: StakeSnapshots crypto -> !Map (KeyHash 'StakePool crypto) (StakeSnapshot crypto)
[ssMarkTotal] :: StakeSnapshots crypto -> !Coin
[ssSetTotal] :: StakeSnapshots crypto -> !Coin
[ssGoTotal] :: StakeSnapshots crypto -> !Coin

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
verifyBlockIntegrity :: ShelleyCompatible proto era => Word64 -> ShelleyBlock proto era -> Bool

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool
mkShelleyBlock :: ShelleyCompatible proto era => Block (ShelleyProtocolHeader proto) era -> ShelleyBlock proto era
mkShelleyHeader :: ShelleyCompatible proto era => ShelleyProtocolHeader proto -> Header (ShelleyBlock proto era)
decodeShelleyBlock :: forall proto era. ShelleyCompatible proto era => forall s. Decoder s (ByteString -> ShelleyBlock proto era)
decodeShelleyHeader :: forall proto era. ShelleyCompatible proto era => forall s. Decoder s (ByteString -> Header (ShelleyBlock proto era))
encodeShelleyBlock :: forall proto era. ShelleyCompatible proto era => ShelleyBlock proto era -> Encoding
encodeShelleyHeader :: forall proto era. ShelleyCompatible proto era => Header (ShelleyBlock proto era) -> Encoding
shelleyBinaryBlockInfo :: forall proto era. ShelleyCompatible proto era => ShelleyBlock proto era -> BinaryBlockInfo

-- | From <tt>cardano-ledger-specs</tt> to <tt>ouroboros-consensus</tt>
fromShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => PrevHash (EraCrypto era) -> ChainHash (ShelleyBlock proto era)

-- | From <tt>ouroboros-consensus</tt> to <tt>cardano-ledger-specs</tt>
toShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => ChainHash (Header (ShelleyBlock proto era)) -> PrevHash (EraCrypto era)

-- | Compacts the given <a>ShelleyGenesis</a>.
compactGenesis :: ShelleyGenesis c -> CompactGenesis c
mkShelleyBlockConfig :: ShelleyBasedEra era => ProtVer -> ShelleyGenesis (EraCrypto era) -> [VKey 'BlockIssuer (EraCrypto era)] -> BlockConfig (ShelleyBlock proto era)
forgeShelleyBlock :: forall m era proto. (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), Monad m) => HotKey (EraCrypto era) m -> CanBeLeader proto -> TopLevelConfig (ShelleyBlock proto era) -> TxOverrides (ShelleyBlock proto era) -> BlockNo -> SlotNo -> TickedLedgerState (ShelleyBlock proto era) -> [Validated (GenTx (ShelleyBlock proto era))] -> IsLeader proto -> m (ShelleyBlock proto era)
castShelleyTip :: HeaderHash (ShelleyBlock proto era) ~ HeaderHash (ShelleyBlock proto' era') => ShelleyTip proto era -> ShelleyTip proto' era'
shelleyLedgerTipPoint :: LedgerState (ShelleyBlock proto era) -> Point (ShelleyBlock proto era)
shelleyTipToPoint :: WithOrigin (ShelleyTip proto era) -> Point (ShelleyBlock proto era)
mkShelleyLedgerConfig :: ShelleyGenesis (EraCrypto era) -> TranslationContext era -> EpochInfo (Except PastHorizonException) -> MaxMajorProtVer -> ShelleyLedgerConfig era
shelleyEraParams :: ShelleyGenesis c -> EraParams

-- | Separate variant of <a>shelleyEraParams</a> to be used for a
--   Shelley-only chain.
shelleyEraParamsNeverHardForks :: ShelleyGenesis c -> EraParams
shelleyLedgerGenesis :: ShelleyLedgerConfig era -> ShelleyGenesis (EraCrypto era)
getPParams :: EraGov era => NewEpochState era -> PParams era
decodeShelleyAnnTip :: ShelleyCompatible proto era => Decoder s (AnnTip (ShelleyBlock proto era))
decodeShelleyLedgerState :: forall era proto s. ShelleyCompatible proto era => Decoder s (LedgerState (ShelleyBlock proto era))
encodeShelleyAnnTip :: ShelleyCompatible proto era => AnnTip (ShelleyBlock proto era) -> Encoding
encodeShelleyHeaderState :: ShelleyCompatible proto era => HeaderState (ShelleyBlock proto era) -> Encoding
encodeShelleyLedgerState :: ShelleyCompatible proto era => LedgerState (ShelleyBlock proto era) -> Encoding

-- | <a>txInBlockSize</a> is used to estimate how many transactions we can
--   grab from the Mempool to put into the block we are going to forge
--   without exceeding the maximum block body size according to the ledger.
--   If we exceed that limit, we will have forged a block that is invalid
--   according to the ledger. We ourselves won't even adopt it, causing us
--   to lose our slot, something we must try to avoid.
--   
--   For this reason it is better to overestimate the size of a transaction
--   than to underestimate. The only downside is that we maybe could have
--   put one (or more?) transactions extra in that block.
--   
--   As the sum of the serialised transaction sizes is not equal to the
--   size of the serialised block body (<a>TxSeq</a>) consisting of those
--   transactions (see cardano-node#1545 for an example), we account for
--   some extra overhead per transaction as a safety margin.
--   
--   Also see <a>perTxOverhead</a>.
fixedBlockBodyOverhead :: Num a => a
mkShelleyTx :: forall era proto. ShelleyBasedEra era => Tx era -> GenTx (ShelleyBlock proto era)
mkShelleyValidatedTx :: forall era proto. ShelleyBasedEra era => Validated (Tx era) -> Validated (GenTx (ShelleyBlock proto era))

-- | See <a>fixedBlockBodyOverhead</a>.
perTxOverhead :: Num a => a
fromExUnits :: ExUnits -> ExUnits' (WithTop Natural)

-- | Is the given query supported by the given
--   <a>ShelleyNodeToClientVersion</a>?
querySupportedVersion :: BlockQuery (ShelleyBlock proto era) result -> ShelleyNodeToClientVersion -> Bool
decodeShelleyQuery :: forall era proto. ShelleyBasedEra era => forall s. Decoder s (SomeSecond BlockQuery (ShelleyBlock proto era))
decodeShelleyResult :: forall proto era result. ShelleyCompatible proto era => ShelleyNodeToClientVersion -> BlockQuery (ShelleyBlock proto era) result -> forall s. Decoder s result
encodeShelleyQuery :: forall era proto result. ShelleyBasedEra era => BlockQuery (ShelleyBlock proto era) result -> Encoding
encodeShelleyResult :: forall proto era result. ShelleyCompatible proto era => ShelleyNodeToClientVersion -> BlockQuery (ShelleyBlock proto era) result -> result -> Encoding

module Ouroboros.Consensus.Shelley.Node.Serialisation
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Node.Serialisation.ShelleyEncoderException era proto)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => GHC.Exception.Type.Exception (Ouroboros.Consensus.Shelley.Node.Serialisation.ShelleyEncoderException era proto)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Util.SomeSecond Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.HasBinaryBlockInfo (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.ChainDB.Impl.Types.SerialiseDiskConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.HeaderValidation.AnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.HeaderValidation.AnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Run.SerialiseNodeToNodeConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Network.Block.Serialised (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Storage.Serialisation.SerialisedHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Run.SerialiseNodeToClientConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Network.Block.Serialised (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseResult (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) Cardano.Slotting.Slot.SlotNo
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.ReconstructNestedCtxt Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)


-- | Node configuration common to all (era, protocol) combinations deriving
--   from Shelley.
module Ouroboros.Consensus.Shelley.Node.Common

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
data ProtocolParamsShelleyBased c
ProtocolParamsShelleyBased :: Nonce -> [ShelleyLeaderCredentials c] -> ProtocolParamsShelleyBased c

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased c -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased c -> [ShelleyLeaderCredentials c]

-- | Needed in '*SharedBlockForging' because we can't partially apply
--   equality constraints.
class (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), EraCrypto era ~ c) => ShelleyEraWithCrypto c proto era
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
shelleyBlockIssuerVKey :: ShelleyLeaderCredentials c -> VKey 'BlockIssuer c
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Mempool.Capacity.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era), Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c) => Ouroboros.Consensus.Shelley.Node.Common.ShelleyEraWithCrypto c proto era
instance Ouroboros.Consensus.Config.SupportsNode.ConfigSupportsNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.InitStorage.NodeInitStorage (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Cardano.Block

-- | The eras in the Cardano blockchain.
--   
--   We parameterise over the crypto used in the post-Byron eras:
--   <tt>c</tt>.
--   
--   TODO: parameterise ByronBlock over crypto too
type CardanoEras c = ByronBlock ': CardanoShelleyEras c
type CardanoShelleyEras c = '[ShelleyBlock (TPraos c) (ShelleyEra c), ShelleyBlock (TPraos c) (AllegraEra c), ShelleyBlock (TPraos c) (MaryEra c), ShelleyBlock (TPraos c) (AlonzoEra c), ShelleyBlock (Praos c) (BabbageEra c), ShelleyBlock (Praos c) (ConwayEra c)]

-- | <i>The</i> Cardano block.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>BlockByron</a> and <a>BlockShelley</a>.
--   
--   <pre>
--   f :: CardanoBlock c -&gt; _
--   f (BlockByron   b) = _
--   f (BlockShelley s) = _
--   f (BlockAllegra a) = _
--   f (BlockMary    m) = _
--   f (BlockAlonzo  m) = _
--   </pre>
type CardanoBlock c = HardForkBlock (CardanoEras c)
data () => HardForkBlock (xs :: [Type])
pattern BlockAllegra :: ShelleyBlock (TPraos c) (AllegraEra c) -> CardanoBlock c
pattern BlockAlonzo :: ShelleyBlock (TPraos c) (AlonzoEra c) -> CardanoBlock c
pattern BlockByron :: ByronBlock -> CardanoBlock c
pattern BlockMary :: ShelleyBlock (TPraos c) (MaryEra c) -> CardanoBlock c
pattern BlockShelley :: ShelleyBlock (TPraos c) (ShelleyEra c) -> CardanoBlock c
pattern BlockBabbage :: ShelleyBlock (Praos c) (BabbageEra c) -> CardanoBlock c
pattern BlockConway :: ShelleyBlock (Praos c) (ConwayEra c) -> CardanoBlock c

-- | The Cardano header.
type CardanoHeader c = Header (CardanoBlock c)
data family Header blk
pattern HeaderAllegra :: Header (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoHeader c
pattern HeaderAlonzo :: Header (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoHeader c
pattern HeaderByron :: Header ByronBlock -> CardanoHeader c
pattern HeaderMary :: Header (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoHeader c
pattern HeaderShelley :: Header (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoHeader c
pattern HeaderBabbage :: Header (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoHeader c
pattern HeaderConway :: Header (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoHeader c

-- | An error resulting from applying a <a>CardanoGenTx</a> to the ledger.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <tt>ApplyTxByronErr</tt>, <a>ApplyTxErrShelley</a>, and
--   <a>ApplyTxErrWrongEra</a>.
--   
--   <pre>
--   toText :: CardanoApplyTxErr c -&gt; Text
--   toText (ApplyTxErrByron b) = byronApplyTxErrToText b
--   toText (ApplyTxErrShelley s) = shelleyApplyTxErrToText s
--   toText (ApplyTxErrAllegra a) = allegraApplyTxErrToText a
--   toText (ApplyTxErrMary m) = maryApplyTxErrToText m
--   toText (ApplyTxErrWrongEra eraMismatch) =
--     "Transaction from the " &lt;&gt; otherEraName eraMismatch &lt;&gt;
--     " era applied to a ledger from the " &lt;&gt;
--     ledgerEraName eraMismatch &lt;&gt; " era"
--   </pre>
type CardanoApplyTxErr c = HardForkApplyTxErr (CardanoEras c)

-- | The Cardano transaction.
type CardanoGenTx c = GenTx (CardanoBlock c)

-- | The ID of a Cardano transaction.
type CardanoGenTxId c = GenTxId (CardanoBlock c)
data family GenTx blk
pattern GenTxAllegra :: GenTx (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoGenTx c
pattern GenTxAlonzo :: GenTx (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoGenTx c
pattern GenTxByron :: GenTx ByronBlock -> CardanoGenTx c
pattern GenTxMary :: GenTx (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoGenTx c
pattern GenTxShelley :: GenTx (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoGenTx c
pattern GenTxBabbage :: GenTx (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoGenTx c
pattern GenTxConway :: GenTx (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoGenTx c
data () => HardForkApplyTxErr (xs :: [Type])
pattern ApplyTxErrAllegra :: ApplyTxErr (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrAlonzo :: ApplyTxErr (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrByron :: ApplyTxErr ByronBlock -> CardanoApplyTxErr c
pattern ApplyTxErrMary :: ApplyTxErr (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrShelley :: ApplyTxErr (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrWrongEra :: EraMismatch -> CardanoApplyTxErr c
pattern ApplyTxErrBabbage :: ApplyTxErr (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrConway :: ApplyTxErr (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoApplyTxErr c
data family TxId tx
pattern GenTxIdAllegra :: GenTxId (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoGenTxId c
pattern GenTxIdAlonzo :: GenTxId (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoGenTxId c
pattern GenTxIdByron :: GenTxId ByronBlock -> CardanoGenTxId c
pattern GenTxIdMary :: GenTxId (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoGenTxId c
pattern GenTxIdShelley :: GenTxId (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoGenTxId c
pattern GenTxIdBabbage :: GenTxId (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoGenTxId c
pattern GenTxIdConway :: GenTxId (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoGenTxId c

-- | An error resulting from applying a <a>CardanoBlock</a> to the ledger.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>LedgerErrorByron</a>, <a>LedgerErrorShelley</a>, and
--   <a>LedgerErrorWrongEra</a>.
--   
--   <pre>
--   toText :: CardanoLedgerError c -&gt; Text
--   toText (LedgerErrorByron b) = byronLedgerErrorToText b
--   toText (LedgerErrorShelley s) = shelleyLedgerErrorToText s
--   toText (LedgerErrorAllegra a) = allegraLedgerErrorToText a
--   toText (LedgerErrorMary m) = maryLedgerErrorToText m
--   toText (LedgerErrorWrongEra eraMismatch) =
--     "Block from the " &lt;&gt; otherEraName eraMismatch &lt;&gt;
--     " era applied to a ledger from the " &lt;&gt;
--     ledgerEraName eraMismatch &lt;&gt; " era"
--   </pre>
type CardanoLedgerError c = HardForkLedgerError (CardanoEras c)
data () => HardForkLedgerError (xs :: [Type])
pattern LedgerErrorAllegra :: LedgerError (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoLedgerError c
pattern LedgerErrorAlonzo :: LedgerError (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoLedgerError c
pattern LedgerErrorByron :: LedgerError ByronBlock -> CardanoLedgerError c
pattern LedgerErrorMary :: LedgerError (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoLedgerError c
pattern LedgerErrorShelley :: LedgerError (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoLedgerError c
pattern LedgerErrorWrongEra :: EraMismatch -> CardanoLedgerError c
pattern LedgerErrorBabbage :: LedgerError (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoLedgerError c
pattern LedgerErrorConway :: LedgerError (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoLedgerError c

-- | An error resulting from validating a <a>CardanoHeader</a>.
type CardanoOtherHeaderEnvelopeError c = HardForkEnvelopeErr (CardanoEras c)
data () => HardForkEnvelopeErr (xs :: [Type])
pattern OtherHeaderEnvelopeErrorAllegra :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorBabbage :: OtherHeaderEnvelopeError (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorConway :: OtherHeaderEnvelopeError (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorAlonzo :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorByron :: OtherHeaderEnvelopeError ByronBlock -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorMary :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorShelley :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorWrongEra :: EraMismatch -> CardanoOtherHeaderEnvelopeError c

-- | The <a>TipInfo</a> of the Cardano chain.
type CardanoTipInfo c = OneEraTipInfo (CardanoEras c)
data () => OneEraTipInfo (xs :: [Type])
pattern TipInfoAllegra :: TipInfo (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoTipInfo c
pattern TipInfoAlonzo :: TipInfo (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoTipInfo c
pattern TipInfoByron :: TipInfo ByronBlock -> CardanoTipInfo c
pattern TipInfoBabbage :: TipInfo (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoTipInfo c
pattern TipInfoConway :: TipInfo (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoTipInfo c
pattern TipInfoMary :: TipInfo (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoTipInfo c
pattern TipInfoShelley :: TipInfo (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoTipInfo c
data family BlockQuery blk :: Type -> Type

-- | Query about the Allegra era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Allegra era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeAllegra EraStart
--   </pre>
pattern QueryAnytimeAllegra :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Alonzo era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Alonzo era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeAlonzo EraStart
--   </pre>
pattern QueryAnytimeAlonzo :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Babbage era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Babbage era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeBabbage EraStart
--   </pre>
pattern QueryAnytimeBabbage :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Conway era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Conway era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeConway EraStart
--   </pre>
pattern QueryAnytimeConway :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Byron era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Byron era (whether the tip of
--   the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeByron EraStart
--   </pre>
pattern QueryAnytimeByron :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Mary era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Mary era (whether the tip of
--   the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeMary EraStart
--   </pre>
pattern QueryAnytimeMary :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Shelley era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Shelley era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeShelley EraStart
--   </pre>
pattern QueryAnytimeShelley :: QueryAnytime result -> CardanoQuery c result

-- | Allegra-specific query that can only be answered when the ledger is in
--   the Allegra era.
pattern QueryIfCurrentAllegra :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (AllegraEra c)) result -> CardanoQuery c a

-- | Alonzo-specific query that can only be answered when the ledger is in
--   the Alonzo era.
pattern QueryIfCurrentAlonzo :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (AlonzoEra c)) result -> CardanoQuery c a

-- | Babbage-specific query that can only be answered when the ledger is in
--   the Babbage era.
pattern QueryIfCurrentBabbage :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (Praos c) (BabbageEra c)) result -> CardanoQuery c a

-- | Conway-specific query that can only be answered when the ledger is in
--   the Conway era.
pattern QueryIfCurrentConway :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (Praos c) (ConwayEra c)) result -> CardanoQuery c a

-- | Byron-specific query that can only be answered when the ledger is in
--   the Byron era.
pattern QueryIfCurrentByron :: () => CardanoQueryResult c result ~ a => BlockQuery ByronBlock result -> CardanoQuery c a

-- | Mary-specific query that can only be answered when the ledger is in
--   the Mary era.
pattern QueryIfCurrentMary :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (MaryEra c)) result -> CardanoQuery c a

-- | Shelley-specific query that can only be answered when the ledger is in
--   the Shelley era.
pattern QueryIfCurrentShelley :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (ShelleyEra c)) result -> CardanoQuery c a

-- | The <tt>Query</tt> of Cardano chain.
type CardanoQuery c = BlockQuery (CardanoBlock c)

-- | The result of a <a>CardanoQuery</a>
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>QueryResultSuccess</a> and
--   <a>QueryResultEraMismatch</a>.
type CardanoQueryResult c = HardForkQueryResult (CardanoEras c)

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
pattern QueryResultSuccess :: result -> CardanoQueryResult c result

-- | A query from a different era than the ledger's era was sent.
pattern QueryResultEraMismatch :: EraMismatch -> CardanoQueryResult c result

-- | The <a>CodecConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>CodecConfig</a>s.
type CardanoCodecConfig c = CodecConfig (CardanoBlock c)
data family CodecConfig blk
pattern CardanoCodecConfig :: CodecConfig ByronBlock -> CodecConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CodecConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> CodecConfig (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoCodecConfig c
data family BlockConfig blk
pattern CardanoBlockConfig :: BlockConfig ByronBlock -> BlockConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> BlockConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> BlockConfig (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoBlockConfig c

-- | The <a>BlockConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>BlockConfig</a>s.
type CardanoBlockConfig c = BlockConfig (CardanoBlock c)

-- | The <a>StorageConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>StorageConfig</a>s.
type CardanoStorageConfig c = StorageConfig (CardanoBlock c)
data family StorageConfig blk
pattern CardanoStorageConfig :: StorageConfig ByronBlock -> StorageConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> StorageConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> StorageConfig (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoStorageConfig c

-- | The <a>ConsensusConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>PartialConsensusConfig</a>s.
--   
--   NOTE: not <a>ConsensusConfig</a>, but <a>PartialConsensusConfig</a>.
type CardanoConsensusConfig c = ConsensusConfig (HardForkProtocol (CardanoEras c))
data family ConsensusConfig p
pattern CardanoConsensusConfig :: PartialConsensusConfig (BlockProtocol ByronBlock) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (ShelleyEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (AllegraEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (MaryEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (AlonzoEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (Praos c) (BabbageEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (Praos c) (ConwayEra c))) -> CardanoConsensusConfig c

-- | The <tt>LedgerConfig</tt> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>PartialLedgerConfig</a>s.
--   
--   NOTE: not <tt>LedgerConfig</tt>, but <a>PartialLedgerConfig</a>.
type CardanoLedgerConfig c = HardForkLedgerConfig (CardanoEras c)
data () => HardForkLedgerConfig (xs :: [Type])
pattern CardanoLedgerConfig :: PartialLedgerConfig ByronBlock -> PartialLedgerConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> PartialLedgerConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> PartialLedgerConfig (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoLedgerConfig c

-- | The <a>LedgerState</a> for <a>CardanoBlock</a>.
--   
--   NOTE: the <a>CardanoLedgerState</a> contains more than just the
--   current era's <a>LedgerState</a>. We don't give access to those
--   internal details through the pattern synonyms. This is also the reason
--   the pattern synonyms are not bidirectional.
type CardanoLedgerState c = LedgerState (CardanoBlock c)
data family LedgerState blk
pattern LedgerStateAllegra :: LedgerState (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoLedgerState c
pattern LedgerStateAlonzo :: LedgerState (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoLedgerState c
pattern LedgerStateBabbage :: LedgerState (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoLedgerState c
pattern LedgerStateConway :: LedgerState (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoLedgerState c
pattern LedgerStateByron :: LedgerState ByronBlock -> CardanoLedgerState c
pattern LedgerStateMary :: LedgerState (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoLedgerState c
pattern LedgerStateShelley :: LedgerState (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoLedgerState c

-- | The <a>ChainDepState</a> for <a>CardanoBlock</a>.
--   
--   NOTE: the <a>CardanoChainDepState</a> contains more than just the
--   current era's <a>ChainDepState</a>. We don't give access to those
--   internal details through the pattern synonyms. This is also the reason
--   the pattern synonyms are not bidirectional.
type CardanoChainDepState c = HardForkChainDepState (CardanoEras c)
data () => HardForkState (f :: Type -> Type) (xs :: [Type])
pattern ChainDepStateAllegra :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (AllegraEra c))) -> CardanoChainDepState c
pattern ChainDepStateAlonzo :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (AlonzoEra c))) -> CardanoChainDepState c
pattern ChainDepStateBabbage :: ChainDepState (BlockProtocol (ShelleyBlock (Praos c) (BabbageEra c))) -> CardanoChainDepState c
pattern ChainDepStateConway :: ChainDepState (BlockProtocol (ShelleyBlock (Praos c) (ConwayEra c))) -> CardanoChainDepState c
pattern ChainDepStateByron :: ChainDepState (BlockProtocol ByronBlock) -> CardanoChainDepState c
pattern ChainDepStateMary :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (MaryEra c))) -> CardanoChainDepState c
pattern ChainDepStateShelley :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (ShelleyEra c))) -> CardanoChainDepState c
data () => EraMismatch
EraMismatch :: !Text -> !Text -> EraMismatch
[ledgerEraName] :: EraMismatch -> !Text
[otherEraName] :: EraMismatch -> !Text

module Ouroboros.Consensus.Shelley.Protocol.Praos
data PraosEnvelopeError

-- | This is a subtle case.
--   
--   This node is explicitly rejecting the header, but the header isn't
--   necessarily _directly_ at fault.
--   
--   This rejection specifically happens when the ticked ledger state being
--   used to validate this header contains a protocol major version (the
--   first <a>Version</a>) that exceeds the maximum major protocol version
--   allowed for this era this specific node's configuration (the second
--   <a>Version</a>). The only thing the header did "wrong" was extend such
--   a ledger state.
--   
--   Note that the ChainSync client ensures that that ledger state is
--   ticked starting from one of the latest k+1 ledger states on the node's
--   current chain (modulo STM scheduling).
--   
--   For Cardano and for now at least, this max major prot ver is typically
--   hardcoded in the source code (subject only to whether or not the
--   run-time config files enable "experimental" eras).
--   
--   Hence, most likely, the appropriate rectifying action is for the node
--   operator to update their node software and/or config; hence the name
--   <a>ObsoleteNode</a>. (Or if they're intentionally testing an
--   experimental era, they forgot to set the appropriate config flag.)
--   
--   TODO Would it be more intuitive to instead enforce this when
--   validating the block that results in a ledger state with a major prot
--   ver that violates the config's limit? Would the errors the user sees
--   be more or less helpful? Etc.
--   
--   TODO (cont'd) It's not even obviously that specific ledger
--   state's/block's fault, since the protocol version is the consequence
--   of on-chain governance. Is it the voters' fault? Is the fault of the
--   first block that was after the voting deadline? So "extending the
--   ledger state that resulting from ticking after applying the block
--   after the epoch that extended the ancestor block that was after the
--   voting deadline that ..." is merely one step more removed. And this
--   <a>envelopeChecks</a> approach does avoid the surprise (since the
--   rejection doesn't even depend on the block's non-header content
--   either) where the header could be validated but its underlying block
--   could not. See
--   <a>https://github.com/IntersectMBO/ouroboros-consensus/issues/325</a>.
ObsoleteNode :: Version -> Version -> PraosEnvelopeError
HeaderSizeTooLarge :: Int -> Word16 -> PraosEnvelopeError
BlockSizeTooLarge :: Word32 -> Word32 -> PraosEnvelopeError
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsEnvelope (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsKES (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsProtocol (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsLedger (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Protocol.Praos.Header.Header c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocol (Ouroboros.Consensus.Protocol.Praos.Praos c)

module Ouroboros.Consensus.Shelley.Node.Praos

-- | Create a <a>BlockForging</a> record for a single era.
praosBlockForging :: forall m era c. (ShelleyCompatible (Praos c) era, c ~ EraCrypto era, TxLimits (ShelleyBlock (Praos c) era), IOLike m) => PraosParams -> TxOverrides (ShelleyBlock (Praos c) era) -> ShelleyLeaderCredentials (EraCrypto era) -> m (BlockForging m (ShelleyBlock (Praos c) era))

-- | Create a <a>BlockForging</a> record safely using the given
--   <tt>Hotkey</tt>.
--   
--   The name of the era (separated by a <tt>_</tt>) will be appended to
--   each <a>forgeLabel</a>.
praosSharedBlockForging :: forall m c era. (ShelleyEraWithCrypto c (Praos c) era, IOLike m) => HotKey c m -> (SlotNo -> KESPeriod) -> ShelleyLeaderCredentials c -> TxOverrides (ShelleyBlock (Praos c) era) -> BlockForging m (ShelleyBlock (Praos c) era)
data family ProtocolParams blk

module Ouroboros.Consensus.Shelley.Protocol.TPraos
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsEnvelope (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsKES (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsProtocol (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsLedger (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Cardano.Protocol.TPraos.BHeader.BHeader c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocol (Ouroboros.Consensus.Protocol.TPraos.TPraos c)

module Ouroboros.Consensus.Shelley.Node.TPraos
newtype () => MaxMajorProtVer
MaxMajorProtVer :: Version -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Version
data family ProtocolParams blk

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
data ProtocolParamsShelleyBased c
ProtocolParamsShelleyBased :: Nonce -> [ShelleyLeaderCredentials c] -> ProtocolParamsShelleyBased c

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased c -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased c -> [ShelleyLeaderCredentials c]
data () => Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce
NeutralNonce :: Nonce
data () => ProtVer
ProtVer :: !Version -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Version
[pvMinor] :: ProtVer -> !Natural
data () => ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
data () => ShelleyGenesisStaking c
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool c) (PoolParams c) -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c) -> ShelleyGenesisStaking c
[sgsPools] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'StakePool c) (PoolParams c)
[sgsStake] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c)
emptyGenesisStaking :: ShelleyGenesisStaking c
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
protocolInfoShelley :: forall m c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) (ShelleyEra c), TxLimits (ShelleyBlock (TPraos c) (ShelleyEra c))) => ShelleyGenesis c -> ProtocolParamsShelleyBased c -> ProtocolParams (ShelleyBlock (TPraos c) (ShelleyEra c)) -> (ProtocolInfo (ShelleyBlock (TPraos c) (ShelleyEra c)), m [BlockForging m (ShelleyBlock (TPraos c) (ShelleyEra c))])
protocolInfoTPraosShelleyBased :: forall m era c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) era, TxLimits (ShelleyBlock (TPraos c) era), c ~ EraCrypto era) => ProtocolParamsShelleyBased c -> TransitionConfig era -> ProtVer -> TxOverrides (ShelleyBlock (TPraos c) era) -> (ProtocolInfo (ShelleyBlock (TPraos c) era), m [BlockForging m (ShelleyBlock (TPraos c) era)])

-- | Create a <a>BlockForging</a> record for a single era.
--   
--   In case the same credentials should be shared across multiple
--   Shelley-based eras, use <a>shelleySharedBlockForging</a>.
shelleyBlockForging :: forall m era c. (ShelleyCompatible (TPraos c) era, PraosCrypto c, c ~ EraCrypto era, TxLimits (ShelleyBlock (TPraos c) era), IOLike m) => TPraosParams -> TxOverrides (ShelleyBlock (TPraos c) era) -> ShelleyLeaderCredentials (EraCrypto era) -> m (BlockForging m (ShelleyBlock (TPraos c) era))

-- | Create a <a>BlockForging</a> record safely using a given
--   <tt>Hotkey</tt>.
--   
--   The name of the era (separated by a <tt>_</tt>) will be appended to
--   each <a>forgeLabel</a>.
shelleySharedBlockForging :: forall m c era. (PraosCrypto c, ShelleyEraWithCrypto c (TPraos c) era, IOLike m) => HotKey c m -> (SlotNo -> KESPeriod) -> ShelleyLeaderCredentials c -> TxOverrides (ShelleyBlock (TPraos c) era) -> BlockForging m (ShelleyBlock (TPraos c) era)

-- | Check the validity of the genesis config. To be used in conjunction
--   with <a>assertWithMsg</a>.
validateGenesis :: PraosCrypto c => ShelleyGenesis c -> Either String ()

module Ouroboros.Consensus.Shelley.Node
newtype () => MaxMajorProtVer
MaxMajorProtVer :: Version -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Version
data family ProtocolParams blk

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
data ProtocolParamsShelleyBased c
ProtocolParamsShelleyBased :: Nonce -> [ShelleyLeaderCredentials c] -> ProtocolParamsShelleyBased c

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased c -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased c -> [ShelleyLeaderCredentials c]
data () => Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce
NeutralNonce :: Nonce
data () => ProtVer
ProtVer :: !Version -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Version
[pvMinor] :: ProtVer -> !Natural
data () => ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
data () => ShelleyGenesisStaking c
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool c) (PoolParams c) -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c) -> ShelleyGenesisStaking c
[sgsPools] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'StakePool c) (PoolParams c)
[sgsStake] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c)
emptyGenesisStaking :: ShelleyGenesisStaking c
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
protocolClientInfoShelley :: ProtocolClientInfo (ShelleyBlock proto era)
protocolInfoShelley :: forall m c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) (ShelleyEra c), TxLimits (ShelleyBlock (TPraos c) (ShelleyEra c))) => ShelleyGenesis c -> ProtocolParamsShelleyBased c -> ProtocolParams (ShelleyBlock (TPraos c) (ShelleyEra c)) -> (ProtocolInfo (ShelleyBlock (TPraos c) (ShelleyEra c)), m [BlockForging m (ShelleyBlock (TPraos c) (ShelleyEra c))])
protocolInfoTPraosShelleyBased :: forall m era c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) era, TxLimits (ShelleyBlock (TPraos c) era), c ~ EraCrypto era) => ProtocolParamsShelleyBased c -> TransitionConfig era -> ProtVer -> TxOverrides (ShelleyBlock (TPraos c) era) -> (ProtocolInfo (ShelleyBlock (TPraos c) era), m [BlockForging m (ShelleyBlock (TPraos c) era)])

-- | Check the validity of the genesis config. To be used in conjunction
--   with <a>assertWithMsg</a>.
validateGenesis :: PraosCrypto c => ShelleyGenesis c -> Either String ()
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.SupportsMetrics.BlockSupportsMetrics (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.Node.Run.RunNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)


-- | This module contains <tt>SupportsProtocol</tt> instances tying the
--   ledger and protocol together. Since these instances reference both
--   ledger concerns and protocol concerns, it is the one class where we
--   cannot provide a generic instance for <a>ShelleyBlock</a>.
module Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era, crypto GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era) => Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.Praos.Praos crypto) era, Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era, crypto GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era, Ouroboros.Consensus.Protocol.Translate.TranslateProto (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) (Ouroboros.Consensus.Protocol.Praos.Praos crypto)) => Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.Praos.Praos crypto) era)


-- | This module is the Shelley Hard Fork Combinator
module Ouroboros.Consensus.Shelley.ShelleyHFC
type ProtocolShelley = HardForkProtocol '[ShelleyBlock (TPraos StandardCrypto) StandardShelley]

-- | Shelley as the single era in the hard fork combinator
type ShelleyBlockHFC proto era = HardForkBlock '[ShelleyBlock proto era]
data ShelleyPartialLedgerConfig era
ShelleyPartialLedgerConfig :: !ShelleyLedgerConfig era -> !TriggerHardFork -> ShelleyPartialLedgerConfig era

-- | We cache the non-partial ledger config containing a dummy
--   <a>EpochInfo</a> that needs to be replaced with the correct one.
--   
--   We do this to avoid recomputing the ledger config each time
--   <a>completeLedgerConfig</a> is called, as <a>mkShelleyLedgerConfig</a>
--   does some rather expensive computations that shouldn't be repeated too
--   often (e.g., <tt>sgActiveSlotCoeff</tt>).
[shelleyLedgerConfig] :: ShelleyPartialLedgerConfig era -> !ShelleyLedgerConfig era
[shelleyTriggerHardFork] :: ShelleyPartialLedgerConfig era -> !TriggerHardFork
crossEraForecastAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => RequiringBoth WrapLedgerConfig (CrossEraForecaster LedgerState WrapLedgerView) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)

-- | Forecast from a Shelley-based era to the next Shelley-based era.
forecastAcrossShelley :: forall protoFrom protoTo eraFrom eraTo. (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => ShelleyLedgerConfig eraFrom -> ShelleyLedgerConfig eraTo -> Bound -> SlotNo -> LedgerState (ShelleyBlock protoFrom eraFrom) -> Except OutsideForecastRange (WrapLedgerView (ShelleyBlock protoTo eraTo))
translateChainDepStateAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. TranslateProto protoFrom protoTo => RequiringBoth WrapConsensusConfig (Translate WrapChainDepState) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyPartialLedgerConfig era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.Translation.TranslationContext era), Cardano.Ledger.Core.Era.Era era) => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyPartialLedgerConfig era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Abstract.NoHardForks.NoHardForks (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Abstract.SingleEraBlock.SingleEraBlock (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialLedgerConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyBlockHFC proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC '[Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era]
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseConstraintsHFC (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Core.Era.PreviousEra era), Cardano.Ledger.Core.Era.Era (Cardano.Ledger.Core.Era.PreviousEra era), Cardano.Ledger.Core.Era.EraCrypto (Cardano.Ledger.Core.Era.PreviousEra era) GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era) => Cardano.Ledger.Core.Translation.TranslateEra era (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Core.Translation.TranslateEra era (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto), Cardano.Ledger.Core.Translation.TranslateEra era Cardano.Ledger.Shelley.LedgerState.Types.NewEpochState, Cardano.Ledger.Core.Translation.TranslationError era Cardano.Ledger.Shelley.LedgerState.Types.NewEpochState GHC.Types.~ GHC.Base.Void) => Cardano.Ledger.Core.Translation.TranslateEra era (Ouroboros.Consensus.Ledger.Basics.LedgerState Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Core.Translation.TranslateEra era Ouroboros.Consensus.Shelley.Eras.WrapTx) => Cardano.Ledger.Core.Translation.TranslateEra era (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Core.Translation.TranslateEra era Ouroboros.Consensus.Shelley.Eras.WrapTx) => Cardano.Ledger.Core.Translation.TranslateEra era (Ouroboros.Consensus.TypeFamilyWrappers.WrapValidatedGenTx Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)


-- | Hard fork eras.
--   
--   Compare this to <a>Eras</a>, which defines ledger eras. This module
--   defines hard fork eras, which are a combination of a ledger era and a
--   protocol.
module Ouroboros.Consensus.Shelley.HFEras
type StandardAllegraBlock = ShelleyBlock (TPraos StandardCrypto) StandardAllegra
type StandardAlonzoBlock = ShelleyBlock (TPraos StandardCrypto) StandardAlonzo
type StandardBabbageBlock = ShelleyBlock (Praos StandardCrypto) StandardBabbage
type StandardConwayBlock = ShelleyBlock (Praos StandardCrypto) StandardConway
type StandardMaryBlock = ShelleyBlock (TPraos StandardCrypto) StandardMary
type StandardShelleyBlock = ShelleyBlock (TPraos StandardCrypto) StandardShelley
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Allegra.Era.AllegraEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Mary.Era.MaryEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Alonzo.Era.AlonzoEra c)
instance (Ouroboros.Consensus.Protocol.Praos.PraosCrypto c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Babbage.Era.BabbageEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.Praos.Praos c) (Cardano.Ledger.Babbage.Era.BabbageEra c)
instance (Ouroboros.Consensus.Protocol.Praos.PraosCrypto c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Conway.Era.ConwayEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.Praos.Praos c) (Cardano.Ledger.Conway.Era.ConwayEra c)

module Ouroboros.Consensus.Cardano.CanHardFork

-- | When Byron is part of the hard-fork combinator, we use the partial
--   ledger config. Standalone Byron uses the regular ledger config. This
--   means that the partial ledger config is the perfect place to store the
--   trigger condition for the hard fork to Shelley, as we don't have to
--   modify the ledger config for standalone Byron.
data ByronPartialLedgerConfig
ByronPartialLedgerConfig :: !LedgerConfig ByronBlock -> !TriggerHardFork -> ByronPartialLedgerConfig
[byronLedgerConfig] :: ByronPartialLedgerConfig -> !LedgerConfig ByronBlock
[byronTriggerHardFork] :: ByronPartialLedgerConfig -> !TriggerHardFork
type CardanoHardForkConstraints c = (PraosCrypto c, PraosCrypto c, TranslateProto (TPraos c) (Praos c), ShelleyCompatible (TPraos c) (ShelleyEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (ShelleyEra c)), ShelleyCompatible (TPraos c) (AllegraEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AllegraEra c)), ShelleyCompatible (TPraos c) (MaryEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (MaryEra c)), ShelleyCompatible (TPraos c) (AlonzoEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AlonzoEra c)), ShelleyCompatible (Praos c) (BabbageEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (BabbageEra c)), ShelleyCompatible (Praos c) (ConwayEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (ConwayEra c)), HASH c ~ Blake2b_256, ADDRHASH c ~ Blake2b_224, DSIGN c ~ Ed25519DSIGN)
data () => TriggerHardFork
TriggerHardForkAtVersion :: !Word16 -> TriggerHardFork
TriggerHardForkAtEpoch :: !EpochNo -> TriggerHardFork
TriggerHardForkNotDuringThisExecution :: TriggerHardFork
data ShelleyPartialLedgerConfig era
ShelleyPartialLedgerConfig :: !ShelleyLedgerConfig era -> !TriggerHardFork -> ShelleyPartialLedgerConfig era

-- | We cache the non-partial ledger config containing a dummy
--   <a>EpochInfo</a> that needs to be replaced with the correct one.
--   
--   We do this to avoid recomputing the ledger config each time
--   <a>completeLedgerConfig</a> is called, as <a>mkShelleyLedgerConfig</a>
--   does some rather expensive computations that shouldn't be repeated too
--   often (e.g., <tt>sgActiveSlotCoeff</tt>).
[shelleyLedgerConfig] :: ShelleyPartialLedgerConfig era -> !ShelleyLedgerConfig era
[shelleyTriggerHardFork] :: ShelleyPartialLedgerConfig era -> !TriggerHardFork

-- | Forecast from a Shelley-based era to the next Shelley-based era.
forecastAcrossShelley :: forall protoFrom protoTo eraFrom eraTo. (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => ShelleyLedgerConfig eraFrom -> ShelleyLedgerConfig eraTo -> Bound -> SlotNo -> LedgerState (ShelleyBlock protoFrom eraFrom) -> Except OutsideForecastRange (WrapLedgerView (ShelleyBlock protoTo eraTo))
translateChainDepStateAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. TranslateProto protoFrom protoTo => RequiringBoth WrapConsensusConfig (Translate WrapChainDepState) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Cardano.CanHardFork.ByronPartialLedgerConfig
instance GHC.Generics.Generic Ouroboros.Consensus.Cardano.CanHardFork.ByronPartialLedgerConfig
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Abstract.CanHardFork.CanHardFork (Ouroboros.Consensus.Cardano.Block.CardanoEras c)
instance (Ouroboros.Consensus.Protocol.Abstract.SelectView (Ouroboros.Consensus.Block.Abstract.BlockProtocol blk) GHC.Types.~ Ouroboros.Consensus.Protocol.Praos.Common.PraosChainSelectView c) => Ouroboros.Consensus.Cardano.CanHardFork.HasPraosSelectView c blk
instance Ouroboros.Consensus.HardFork.Combinator.Abstract.SingleEraBlock.SingleEraBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialLedgerConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Protocol.PBFT.Crypto.PBftCrypto bc => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.PBFT.PBft bc)

module Ouroboros.Consensus.Cardano.Node
type CardanoHardForkConstraints c = (PraosCrypto c, PraosCrypto c, TranslateProto (TPraos c) (Praos c), ShelleyCompatible (TPraos c) (ShelleyEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (ShelleyEra c)), ShelleyCompatible (TPraos c) (AllegraEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AllegraEra c)), ShelleyCompatible (TPraos c) (MaryEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (MaryEra c)), ShelleyCompatible (TPraos c) (AlonzoEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AlonzoEra c)), ShelleyCompatible (Praos c) (BabbageEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (BabbageEra c)), ShelleyCompatible (Praos c) (ConwayEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (ConwayEra c)), HASH c ~ Blake2b_256, ADDRHASH c ~ Blake2b_224, DSIGN c ~ Ed25519DSIGN)
newtype CardanoHardForkTriggers
CardanoHardForkTriggers :: NP (K TriggerHardFork) (CardanoShelleyEras StandardCrypto) -> CardanoHardForkTriggers
[getCardanoHardForkTriggers] :: CardanoHardForkTriggers -> NP (K TriggerHardFork) (CardanoShelleyEras StandardCrypto)
pattern CardanoHardForkTriggers' :: TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> CardanoHardForkTriggers
type CardanoProtocolParams c = ProtocolParams (CardanoBlock c)
newtype () => MaxMajorProtVer
MaxMajorProtVer :: Version -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Version
data family ProtocolParams blk
pattern CardanoProtocolParams :: ProtocolParams ByronBlock -> ProtocolParamsShelleyBased c -> ProtocolParams (ShelleyBlock (TPraos c) (ShelleyEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (AlonzoEra c)) -> ProtocolParams (ShelleyBlock (Praos c) (BabbageEra c)) -> ProtocolParams (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoHardForkTriggers -> TransitionConfig (LatestKnownEra c) -> CardanoProtocolParams c
data () => TriggerHardFork
TriggerHardForkAtVersion :: !Word16 -> TriggerHardFork
TriggerHardForkAtEpoch :: !EpochNo -> TriggerHardFork
TriggerHardForkNotDuringThisExecution :: TriggerHardFork
protocolClientInfoCardano :: forall c. EpochSlots -> ProtocolClientInfo (CardanoBlock c)

-- | Create a <a>ProtocolInfo</a> for <a>CardanoBlock</a>
--   
--   NOTE: For testing and benchmarking purposes, the <a>ShelleyGenesis</a>
--   can contain initial staking and funds. These are registered in the
--   initial ledger state <i>only if</i> the given
--   <a>CardanoHardForkTriggers</a> tell us to skip the Byron era and hard
--   fork directly to Shelley or a later era by using
--   <tt>TestXHardForkAtEpoch 0</tt>. When <tt><a>gNetworkId</a> ==
--   <a>Mainnet</a></tt>, the initial staking and funds <i>must</i> be
--   empty.
--   
--   PRECONDITION: only a single set of Shelley credentials is allowed when
--   used for mainnet (check against <tt><a>gNetworkId</a> ==
--   <a>Mainnet</a></tt>).
protocolInfoCardano :: forall c m. (IOLike m, CardanoHardForkConstraints c) => CardanoProtocolParams c -> (ProtocolInfo (CardanoBlock c), m [BlockForging m (CardanoBlock c)])

-- | We support the sole Byron version with the hard fork disabled.
pattern CardanoNodeToClientVersion1 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary, Alonzo and
--   Babbage eras enabled Using <a>ShelleyNodeToClientVersion6</a> for the
--   Shelley-based eras, which enables new queries.
pattern CardanoNodeToClientVersion10 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary, Alonzo and
--   Babbage eras enabled, using <a>ShelleyNodeToClientVersion7</a> for the
--   Shelley-based eras, which enables new queries.
pattern CardanoNodeToClientVersion11 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary, Alonzo and
--   Babbage and Conway eras enabled, using
--   <a>ShelleyNodeToClientVersion7</a> for the Shelley-based eras.
pattern CardanoNodeToClientVersion12 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled and the Shelley era enabled.
pattern CardanoNodeToClientVersion2 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled and the Shelley era enabled, but using
--   <a>ShelleyNodeToClientVersion2</a> and
--   <a>HardForkSpecificNodeToClientVersion2</a>.
pattern CardanoNodeToClientVersion3 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley and Allegra eras enabled.
--   
--   We don't bother with <a>ShelleyNodeToClientVersion1</a> and
--   <a>HardForkSpecificNodeToClientVersion1</a>.
pattern CardanoNodeToClientVersion4 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, and Mary eras
--   enabled.
--   
--   We don't bother with <a>ShelleyNodeToClientVersion1</a>.
pattern CardanoNodeToClientVersion5 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, and Mary eras
--   enabled, but using <a>ShelleyNodeToClientVersion3</a> for the
--   Shelley-based eras , which enables new queries.
pattern CardanoNodeToClientVersion6 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary and Alonzo eras
--   enabled
pattern CardanoNodeToClientVersion7 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary and Alonzo eras
--   enabled Using <a>ShelleyNodeToClientVersion5</a> for the Shelley-based
--   eras , which enables new queries.
pattern CardanoNodeToClientVersion8 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary, Alonzo and
--   Babbage eras enabled Using <a>ShelleyNodeToClientVersion5</a> for the
--   Shelley-based eras, which enables new queries.
pattern CardanoNodeToClientVersion9 :: BlockNodeToClientVersion (CardanoBlock c)

-- | We support only Byron V1 with the hard fork disabled, as no other
--   versions have been released before the hard fork
pattern CardanoNodeToNodeVersion1 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled using the latest version of Byron and Shelley
--   for each Byron and Shelley era.
pattern CardanoNodeToNodeVersion2 :: BlockNodeToNodeVersion (CardanoBlock c)
instance Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseConstraintsHFC Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC (Ouroboros.Consensus.Cardano.Block.CardanoEras c)
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Cardano.Block.CardanoBlock c)

module Ouroboros.Consensus.Cardano.Condense
instance Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints (Ouroboros.Consensus.Cardano.Block.CardanoBlock c)

module Ouroboros.Consensus.Cardano.ByronHFC

-- | Byron as the single era in the hard fork combinator
type ByronBlockHFC = HardForkBlock '[ByronBlock]
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion Ouroboros.Consensus.Cardano.ByronHFC.ByronBlockHFC
instance Ouroboros.Consensus.HardFork.Combinator.Abstract.NoHardForks.NoHardForks Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC '[Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock]

module Ouroboros.Consensus.Cardano

-- | <i>The</i> Cardano block.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>BlockByron</a> and <a>BlockShelley</a>.
--   
--   <pre>
--   f :: CardanoBlock c -&gt; _
--   f (BlockByron   b) = _
--   f (BlockShelley s) = _
--   f (BlockAllegra a) = _
--   f (BlockMary    m) = _
--   f (BlockAlonzo  m) = _
--   </pre>
type CardanoBlock c = HardForkBlock (CardanoEras c)
type ProtocolByron = HardForkProtocol '[ByronBlock]
type ProtocolCardano = HardForkProtocol '[ByronBlock, ShelleyBlock (TPraos StandardCrypto) StandardShelley, ShelleyBlock (TPraos StandardCrypto) StandardAllegra, ShelleyBlock (TPraos StandardCrypto) StandardMary, ShelleyBlock (TPraos StandardCrypto) StandardAlonzo, ShelleyBlock (Praos StandardCrypto) StandardBabbage, ShelleyBlock (Praos StandardCrypto) StandardConway]
type ProtocolShelley = HardForkProtocol '[ShelleyBlock (TPraos StandardCrypto) StandardShelley]
newtype CardanoHardForkTriggers
CardanoHardForkTriggers :: NP (K TriggerHardFork) (CardanoShelleyEras StandardCrypto) -> CardanoHardForkTriggers
[getCardanoHardForkTriggers] :: CardanoHardForkTriggers -> NP (K TriggerHardFork) (CardanoShelleyEras StandardCrypto)
pattern CardanoHardForkTriggers' :: TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> TriggerHardFork -> CardanoHardForkTriggers
data family ProtocolParams blk
pattern CardanoProtocolParams :: ProtocolParams ByronBlock -> ProtocolParamsShelleyBased c -> ProtocolParams (ShelleyBlock (TPraos c) (ShelleyEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParams (ShelleyBlock (TPraos c) (AlonzoEra c)) -> ProtocolParams (ShelleyBlock (Praos c) (BabbageEra c)) -> ProtocolParams (ShelleyBlock (Praos c) (ConwayEra c)) -> CardanoHardForkTriggers -> TransitionConfig (LatestKnownEra c) -> CardanoProtocolParams c
