<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">ouroboros-consensus-0.15.0.0: Consensus layer for the Ouroboros blockchain protocol</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Exported for testing purposes</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Iterators</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:closeAllIterators">closeAllIterators</a> :: <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m =&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:ChainDbEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">ChainDbEnv</a> m blk -&gt; m ()</li><li class="src short"><a href="#v:stream">stream</a> :: <span class="keyword">forall</span> m blk b. (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Block-Abstract.html#t:HasHeader" title="Ouroboros.Consensus.Block.Abstract">HasHeader</a> blk, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>) =&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:ChainDbHandle" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">ChainDbHandle</a> m blk -&gt; <a href="Ouroboros-Consensus-Util-ResourceRegistry.html#t:ResourceRegistry" title="Ouroboros.Consensus.Util.ResourceRegistry">ResourceRegistry</a> m -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:BlockComponent" title="Ouroboros.Consensus.Storage.Common">BlockComponent</a> blk b -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamFrom" title="Ouroboros.Consensus.Storage.Common">StreamFrom</a> blk -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamTo" title="Ouroboros.Consensus.Storage.Common">StreamTo</a> blk -&gt; m (<a href="Ouroboros-Consensus-HardFork-Combinator-Degenerate.html#t:Either" title="Ouroboros.Consensus.HardFork.Combinator.Degenerate">Either</a> (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:UnknownRange" title="Ouroboros.Consensus.Storage.ChainDB.API">UnknownRange</a> blk) (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:Iterator" title="Ouroboros.Consensus.Storage.ChainDB.API">Iterator</a> m blk b))</li><li class="src short"><span class="keyword">data</span> <a href="#t:IteratorEnv">IteratorEnv</a> m blk = <a href="#v:IteratorEnv">IteratorEnv</a> {<ul class="subs"><li><a href="#v:itImmutableDB">itImmutableDB</a> :: <a href="Ouroboros-Consensus-Storage-ImmutableDB-API.html#t:ImmutableDB" title="Ouroboros.Consensus.Storage.ImmutableDB.API">ImmutableDB</a> m blk</li><li><a href="#v:itVolatileDB">itVolatileDB</a> :: <a href="Ouroboros-Consensus-Storage-VolatileDB-API.html#t:VolatileDB" title="Ouroboros.Consensus.Storage.VolatileDB.API">VolatileDB</a> m blk</li><li><a href="#v:itIterators">itIterators</a> :: <a href="Ouroboros-Consensus-Util-NormalForm-StrictTVar.html#t:StrictTVar" title="Ouroboros.Consensus.Util.NormalForm.StrictTVar">StrictTVar</a> m (<a href="file:///nix/store/9f69j6hfgwz5xdil7lfn1c1mbhrhidl1-ghc-9.6.3-doc/share/doc/ghc-9.6.3/html/libraries/containers-0.6.7/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:IteratorKey" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">IteratorKey</a> (m ()))</li><li><a href="#v:itNextIteratorKey">itNextIteratorKey</a> :: <a href="Ouroboros-Consensus-Util-NormalForm-StrictTVar.html#t:StrictTVar" title="Ouroboros.Consensus.Util.NormalForm.StrictTVar">StrictTVar</a> m <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:IteratorKey" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">IteratorKey</a></li><li><a href="#v:itTracer">itTracer</a> :: Tracer m (<a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:TraceIteratorEvent" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">TraceIteratorEvent</a> blk)</li></ul>}</li><li class="src short"><a href="#v:newIterator">newIterator</a> :: <span class="keyword">forall</span> m blk b. (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Block-Abstract.html#t:HasHeader" title="Ouroboros.Consensus.Block.Abstract">HasHeader</a> blk, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>) =&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#t:IteratorEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">IteratorEnv</a> m blk -&gt; (<span class="keyword">forall</span> r. (<a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#t:IteratorEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">IteratorEnv</a> m blk -&gt; m r) -&gt; m r) -&gt; <a href="Ouroboros-Consensus-Util-ResourceRegistry.html#t:ResourceRegistry" title="Ouroboros.Consensus.Util.ResourceRegistry">ResourceRegistry</a> m -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:BlockComponent" title="Ouroboros.Consensus.Storage.Common">BlockComponent</a> blk b -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamFrom" title="Ouroboros.Consensus.Storage.Common">StreamFrom</a> blk -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamTo" title="Ouroboros.Consensus.Storage.Common">StreamTo</a> blk -&gt; m (<a href="Ouroboros-Consensus-HardFork-Combinator-Degenerate.html#t:Either" title="Ouroboros.Consensus.HardFork.Combinator.Degenerate">Either</a> (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:UnknownRange" title="Ouroboros.Consensus.Storage.ChainDB.API">UnknownRange</a> blk) (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:Iterator" title="Ouroboros.Consensus.Storage.ChainDB.API">Iterator</a> m blk b))</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:closeAllIterators" class="def">closeAllIterators</a> :: <a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m =&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:ChainDbEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">ChainDbEnv</a> m blk -&gt; m () <a href="src/Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator.html#closeAllIterators" class="link">Source</a> <a href="#v:closeAllIterators" class="selflink">#</a></p><div class="doc"><p>Close all open <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:Iterator" title="Ouroboros.Consensus.Storage.ChainDB.API">Iterator</a></code>s.</p><p>This <em>can</em> be called when the ChainDB is already closed.</p></div></div><div class="top"><p class="src"><a id="v:stream" class="def">stream</a> :: <span class="keyword">forall</span> m blk b. (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Block-Abstract.html#t:HasHeader" title="Ouroboros.Consensus.Block.Abstract">HasHeader</a> blk, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>) =&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:ChainDbHandle" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">ChainDbHandle</a> m blk -&gt; <a href="Ouroboros-Consensus-Util-ResourceRegistry.html#t:ResourceRegistry" title="Ouroboros.Consensus.Util.ResourceRegistry">ResourceRegistry</a> m -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:BlockComponent" title="Ouroboros.Consensus.Storage.Common">BlockComponent</a> blk b -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamFrom" title="Ouroboros.Consensus.Storage.Common">StreamFrom</a> blk -&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamTo" title="Ouroboros.Consensus.Storage.Common">StreamTo</a> blk -&gt; m (<a href="Ouroboros-Consensus-HardFork-Combinator-Degenerate.html#t:Either" title="Ouroboros.Consensus.HardFork.Combinator.Degenerate">Either</a> (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:UnknownRange" title="Ouroboros.Consensus.Storage.ChainDB.API">UnknownRange</a> blk) (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:Iterator" title="Ouroboros.Consensus.Storage.ChainDB.API">Iterator</a> m blk b)) <a href="src/Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator.html#stream" class="link">Source</a> <a href="#v:stream" class="selflink">#</a></p><div class="doc"><p>Stream blocks</p><h1>Start &amp; end point</h1><p>The start point can either be in the ImmutableDB (on our chain) or in the
 VolatileDB (on our chain or on a recent fork). We first check whether it is
 in the VolatileDB, if not, we check if it is in the ImmutableDB (see
 &quot;Garbage collection&quot; for why this order is important). Similarly for the
 end point.</p><p>If a bound can't be found in the ChainDB, an <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:UnknownRange" title="Ouroboros.Consensus.Storage.ChainDB.API">UnknownRange</a></code> error is
 returned.</p><p>When the bounds are nonsensical, e.g.,
 &gt; StreamFromExclusive (Point     (SlotNo 3) _)
 &gt; StreamToInclusive   (RealPoint (SlotNo 3) _)
 An <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#v:InvalidIteratorRange" title="Ouroboros.Consensus.Storage.ChainDB.API">InvalidIteratorRange</a></code> exception is thrown.</p><h1>Paths of blocks</h1><p>To stream blocks from the ImmutableDB we can simply use the iterators
 offered by the ImmutableDB.</p><p>To stream blocks from the VolatileDB we have to construct a path of points
 backwards through the VolatileDB, starting from the end point using
 <code>getPredecessor</code> until we get to the start point, genesis, or we get to a
 block that is not in the VolatileDB. Then, for each point in the path, we
 can ask the VolatileDB for the corresponding block.</p><p>If the path through the VolatileDB is incomplete, we will first have to
 stream blocks from the ImmutableDB and then switch to the path through the
 VolatileDB. We only allow the tip of the ImmutableDB to be the switchover
 point between the two DBs. In other words, the incomplete path through the
 VolatileDB must fit onto the tip of the ImmutableDB. This must be true at
 the time of initialising the iterator, but does not have to hold during the
 whole lifetime of the iterator. If it doesn't fit on it, it means the path
 forked off more than <code>k</code> blocks in the past and blocks belonging to it are
 more likely to go missing because of garbage-collection (see the next
 paragraph). In that case, we return <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#v:ForkTooOld" title="Ouroboros.Consensus.Storage.ChainDB.API">ForkTooOld</a></code>.</p><h1>Garbage collection</h1><p>We have to be careful about the following: as our chain grows, blocks from
 our chain will be copied to the ImmutableDB in the background. After a
 while, old blocks will be garbage-collected from the VolatileDB. Blocks
 that were part of the current chain will be in the ImmutableDB, but blocks
 that only lived on forks will be gone forever.</p><p>This means that blocks that were part of the VolatileDB when the iterator
 was initialised might no longer be part of the VolatileDB when we come to
 the point that the iterator will try to read them. When this is noticed, we
 will try to open an iterator from the ImmutableDB to obtain the blocks that
 have moved over. However, this will only work if they were and are part of
 the current chain, otherwise they will have been deleted from the
 VolatileDB without being copied to the ImmutableDB.</p><p>This iterator is opened with an open upper bound and will be used to stream
 blocks until the path has been fully streamed, the iterator is exhausted,
 or a block doesn't match the expected point. In the latter two cases, we
 switch back to the VolatileDB. If the block is missing from the VolatileDB,
 we will switch back to streaming from the ImmutableDB. If that fails, we
 switch back to the VolatileDB. To avoid eternally switching between the two
 DBs, we only switch back to the VolatileDB if the stream from the
 ImmutableDB has made progress, i.e. streamed at least one block with the
 expected point. If no block was streamed from the ImmutableDB, not even the
 first one, we know for sure that that block isn't part of the VolatileDB
 (the reason we switch to the ImmutableDB) and isn't part of the ImmutableDB
 (no block was streamed). In that case, we return <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#v:IteratorBlockGCed" title="Ouroboros.Consensus.Storage.ChainDB.API">IteratorBlockGCed</a></code> and
 stop the stream.</p><p>Note that the open upper bound doesn't allow us to include blocks in the
 stream that are copied to the ImmutableDB after opening this iterator, as
 the bound of the iterator is fixed upon initialisation. These newly added
 blocks will be included in the stream because we will repeatedly open new
 ImmutableDB iterators (as long as we make progress).</p><h1>Bounds checking</h1><p>The VolatileDB is hash-based instead of point-based. While the bounds of a
 stream are <em>point</em>s, we can simply check whether the hashes of the bounds
 match the hashes stored in the points.</p><p>The ImmutableDB is slot-based instead of point-based, which means that
 before we know whether a block in the ImmutableDB matches a given point, we
 must first read the block's hash corresponding to the point's slot from the
 (cached) on-disk indices, after which we can then verify whether it matches
 the hash of the point. This is important for the start and end bounds (both
 points) of a stream in case they are in the ImmutableDB (i.e., their slots
 are &lt;= the tip of the ImmutableDB): we must first read the hashes
 corresponding to the bounds from the (cached) on-disk indices to be sure
 the range is valid. Note that these reads happen before the first call to
 <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#v:iteratorNext" title="Ouroboros.Consensus.Storage.ChainDB.API">iteratorNext</a></code>.</p><p>Note that when streaming to an <em>exclusive</em> bound, the block corresponding
 to that bound (<code><a href="Ouroboros-Consensus-Block-Abstract.html#t:Point" title="Ouroboros.Consensus.Block.Abstract">Point</a></code>) must exist in the ChainDB.</p><p>The ImmutableDB will keep the on-disk indices of a chunk of blocks in
 memory after the first read so that the next lookup doesn't have to read
 from disk. When both bounds are in the same chunk, which will typically be
 the case, only checking the first bound will require disk reads, the second
 will be cached.</p><h1>Costs</h1><p>Opening an iterator has some costs:</p><ul><li>When blocks have to be streamed from the ImmutableDB: as discussed in
   &quot;Bounds checking&quot;, the hashes corresponding to the bounds have to be
   read from the (cached) on-disk indices.</li><li>When blocks have to be streamed both from the ImmutableDB and the
   VolatileDB, only the hash of the block corresponding to the lower bound
   will have to be read from the ImmutableDB upfront, as described in the
   previous bullet point. Note that the hash of the block corresponding to
   the upper bound does not have to be read from disk, since it will be in
   the VolatileDB, which means that we know its hash already from the
   in-memory index.</li></ul><p>In summary:</p><ul><li>Only streaming from the VolatileDB: 0 (cached) reads from disk upfront.</li><li>Only streaming from the ImmutableDB: 2 (cached) reads from disk upfront.</li><li>Streaming from both the ImmutableDB and the VolatileDB: 1 (cached) read
   from disk upfront.</li></ul><p>Additionally, when we notice during streaming that a block is no longer in
 the VolatileDB, we try to see whether it can be streamed from the ImmutableDB
 instead. Opening such an iterator costs 2 (cached) reads from disk upfront.
 This can happen multiple times.</p></div></div><a href="#g:1" id="g:1"><h1>Exported for testing purposes</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IteratorEnv" class="def">IteratorEnv</a> m blk <a href="src/Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator.html#IteratorEnv" class="link">Source</a> <a href="#t:IteratorEnv" class="selflink">#</a></p><div class="doc"><p>Environment containing everything needed to implement iterators.</p><p>The main purpose of bundling these things in a separate record is to make
 it easier to test this code: no need to set up a whole ChainDB, just
 provide this record.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:IteratorEnv" class="def">IteratorEnv</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:itImmutableDB" class="def">itImmutableDB</a> :: <a href="Ouroboros-Consensus-Storage-ImmutableDB-API.html#t:ImmutableDB" title="Ouroboros.Consensus.Storage.ImmutableDB.API">ImmutableDB</a> m blk</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:itVolatileDB" class="def">itVolatileDB</a> :: <a href="Ouroboros-Consensus-Storage-VolatileDB-API.html#t:VolatileDB" title="Ouroboros.Consensus.Storage.VolatileDB.API">VolatileDB</a> m blk</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:itIterators" class="def">itIterators</a> :: <a href="Ouroboros-Consensus-Util-NormalForm-StrictTVar.html#t:StrictTVar" title="Ouroboros.Consensus.Util.NormalForm.StrictTVar">StrictTVar</a> m (<a href="file:///nix/store/9f69j6hfgwz5xdil7lfn1c1mbhrhidl1-ghc-9.6.3-doc/share/doc/ghc-9.6.3/html/libraries/containers-0.6.7/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:IteratorKey" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">IteratorKey</a> (m ()))</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:itNextIteratorKey" class="def">itNextIteratorKey</a> :: <a href="Ouroboros-Consensus-Util-NormalForm-StrictTVar.html#t:StrictTVar" title="Ouroboros.Consensus.Util.NormalForm.StrictTVar">StrictTVar</a> m <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:IteratorKey" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">IteratorKey</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:itTracer" class="def">itTracer</a> :: Tracer m (<a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Types.html#t:TraceIteratorEvent" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Types">TraceIteratorEvent</a> blk)</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:newIterator" class="def">newIterator</a> <a href="src/Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator.html#newIterator" class="link">Source</a> <a href="#v:newIterator" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> m blk b. (<a href="Ouroboros-Consensus-Util-IOLike.html#t:IOLike" title="Ouroboros.Consensus.Util.IOLike">IOLike</a> m, <a href="Ouroboros-Consensus-Block-Abstract.html#t:HasHeader" title="Ouroboros.Consensus.Block.Abstract">HasHeader</a> blk, <a href="Ouroboros-Consensus-Util-CallStack.html#t:HasCallStack" title="Ouroboros.Consensus.Util.CallStack">HasCallStack</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#t:IteratorEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">IteratorEnv</a> m blk</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<span class="keyword">forall</span> r. (<a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#t:IteratorEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">IteratorEnv</a> m blk -&gt; m r) -&gt; m r)</td><td class="doc"><p>Function with which the operations on the returned iterator should
 obtain their <code><a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#t:IteratorEnv" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">IteratorEnv</a></code>. This function should check whether the
 ChainDB is still open or throw an exception otherwise. This makes sure
 that when we call <code><a href="Ouroboros-Consensus-Storage-ChainDB-API.html#v:iteratorNext" title="Ouroboros.Consensus.Storage.ChainDB.API">iteratorNext</a></code>, we first check whether the ChainDB
 is still open.</p></td></tr><tr><td class="src">-&gt; <a href="Ouroboros-Consensus-Util-ResourceRegistry.html#t:ResourceRegistry" title="Ouroboros.Consensus.Util.ResourceRegistry">ResourceRegistry</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:BlockComponent" title="Ouroboros.Consensus.Storage.Common">BlockComponent</a> blk b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamFrom" title="Ouroboros.Consensus.Storage.Common">StreamFrom</a> blk</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Ouroboros-Consensus-Storage-Common.html#t:StreamTo" title="Ouroboros.Consensus.Storage.Common">StreamTo</a> blk</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m (<a href="Ouroboros-Consensus-HardFork-Combinator-Degenerate.html#t:Either" title="Ouroboros.Consensus.HardFork.Combinator.Degenerate">Either</a> (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:UnknownRange" title="Ouroboros.Consensus.Storage.ChainDB.API">UnknownRange</a> blk) (<a href="Ouroboros-Consensus-Storage-ChainDB-API.html#t:Iterator" title="Ouroboros.Consensus.Storage.ChainDB.API">Iterator</a> m blk b))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>See <code><a href="Ouroboros-Consensus-Storage-ChainDB-Impl-Iterator.html#v:stream" title="Ouroboros.Consensus.Storage.ChainDB.Impl.Iterator">stream</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.1</p></div></body></html>