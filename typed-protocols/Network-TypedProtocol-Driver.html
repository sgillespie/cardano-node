<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Network.TypedProtocol.Driver</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">typed-protocols-0.1.1.0: A framework for strongly typed protocols</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Network.TypedProtocol.Driver.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Network.TypedProtocol.Driver</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Normal peers</a></li><li><a href="#g:3">Pipelined peers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Actions for running <code><a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a></code>s with a <code><a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a></code></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Driver">Driver</a> ps dstate m = <a href="#v:Driver">Driver</a> {<ul class="subs"><li><a href="#v:sendMessage">sendMessage</a> :: <span class="keyword">forall</span> (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st :: ps) (st' :: ps). <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st -&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; m ()</li><li><a href="#v:recvMessage">recvMessage</a> :: <span class="keyword">forall</span> (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st :: ps). <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st -&gt; dstate -&gt; m (<a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st, dstate)</li><li><a href="#v:startDState">startDState</a> :: dstate</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:SomeMessage">SomeMessage</a> (st :: ps) <span class="keyword">where</span><ul class="subs"><li><a href="#v:SomeMessage">SomeMessage</a> :: <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; <a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st</li></ul></li><li class="src short"><a href="#v:runPeerWithDriver">runPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. <a href="file:///nix/store/9f69j6hfgwz5xdil7lfn1c1mbhrhidl1-ghc-9.6.3-doc/share/doc/ghc-9.6.3/html/libraries/base-4.18.1.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps dstate m -&gt; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a -&gt; dstate -&gt; m (a, dstate)</li><li class="src short"><a href="#v:runPipelinedPeerWithDriver">runPipelinedPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. MonadAsync m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps dstate m -&gt; <a href="Network-TypedProtocol-Pipelined.html#t:PeerPipelined" title="Network.TypedProtocol.Pipelined">PeerPipelined</a> ps pr st m a -&gt; dstate -&gt; m (a, dstate)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>A <code><a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a></code> is a particular implementation of an agent that engages in a
 typed protocol. To actually run one we need a source and sink for the typed
 protocol messages. These are provided by a <code>Channel</code> and a <code>Codec</code>. The
 <code>Channel</code> represents one end of an untyped duplex message transport, and
 the <code>Codec</code> handles conversion between the typed protocol messages and
 the untyped channel.</p><p>So given the <code><a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a></code> and a compatible <code>Codec</code> and <code>Channel</code> we can run the
 peer in some appropriate monad. The peer and codec have to agree on
 the same protocol and role in that protocol. The codec and channel have to
 agree on the same untyped medium, e.g. text or bytes. All three have to
 agree on the same monad in which they will run.</p><p>This module provides drivers for normal and pipelined peers. There is
 very little policy involved here so typically it should be possible to
 use these drivers, and customise things by adjusting the peer, or codec
 or channel.</p><p>It is of course possible to write custom drivers and the code for these ones
 may provide a useful starting point. The <code>runDecoder</code> function may be a
 helpful utility for use in custom drives.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Driver" class="def">Driver</a> ps dstate m <a href="src/Network.TypedProtocol.Driver.html#Driver" class="link">Source</a> <a href="#t:Driver" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Driver" class="def">Driver</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:sendMessage" class="def">sendMessage</a> :: <span class="keyword">forall</span> (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st :: ps) (st' :: ps). <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st -&gt; <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; m ()</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:recvMessage" class="def">recvMessage</a> :: <span class="keyword">forall</span> (pr :: <a href="Network-TypedProtocol-Core.html#t:PeerRole" title="Network.TypedProtocol.Core">PeerRole</a>) (st :: ps). <a href="Network-TypedProtocol-Core.html#t:PeerHasAgency" title="Network.TypedProtocol.Core">PeerHasAgency</a> pr st -&gt; dstate -&gt; m (<a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st, dstate)</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:startDState" class="def">startDState</a> :: dstate</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SomeMessage" class="def">SomeMessage</a> (st :: ps) <span class="keyword">where</span> <a href="src/Network.TypedProtocol.Driver.html#SomeMessage" class="link">Source</a> <a href="#t:SomeMessage" class="selflink">#</a></p><div class="doc"><p>When decoding a <code><a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a></code> we only know the expected &quot;from&quot; state. We
 cannot know the &quot;to&quot; state as this depends on the message we decode. To
 resolve this we use the <code><a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a></code> wrapper which uses an existential
 type to hide the &quot;to&quot; state.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:SomeMessage" class="def">SomeMessage</a> :: <a href="Network-TypedProtocol-Core.html#t:Message" title="Network.TypedProtocol.Core">Message</a> ps st st' -&gt; <a href="Network-TypedProtocol-Driver.html#t:SomeMessage" title="Network.TypedProtocol.Driver">SomeMessage</a> st</td><td class="doc empty">&nbsp;</td></tr></table></div></div><a href="#g:2" id="g:2"><h1>Normal peers</h1></a><div class="top"><p class="src"><a id="v:runPeerWithDriver" class="def">runPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. <a href="file:///nix/store/9f69j6hfgwz5xdil7lfn1c1mbhrhidl1-ghc-9.6.3-doc/share/doc/ghc-9.6.3/html/libraries/base-4.18.1.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps dstate m -&gt; <a href="Network-TypedProtocol-Core.html#t:Peer" title="Network.TypedProtocol.Core">Peer</a> ps pr st m a -&gt; dstate -&gt; m (a, dstate) <a href="src/Network.TypedProtocol.Driver.html#runPeerWithDriver" class="link">Source</a> <a href="#v:runPeerWithDriver" class="selflink">#</a></p><div class="doc"><p>Run a peer with the given driver.</p><p>This runs the peer to completion (if the protocol allows for termination).</p></div></div><a href="#g:3" id="g:3"><h1>Pipelined peers</h1></a><div class="top"><p class="src"><a id="v:runPipelinedPeerWithDriver" class="def">runPipelinedPeerWithDriver</a> :: <span class="keyword">forall</span> ps (st :: ps) pr dstate m a. MonadAsync m =&gt; <a href="Network-TypedProtocol-Driver.html#t:Driver" title="Network.TypedProtocol.Driver">Driver</a> ps dstate m -&gt; <a href="Network-TypedProtocol-Pipelined.html#t:PeerPipelined" title="Network.TypedProtocol.Pipelined">PeerPipelined</a> ps pr st m a -&gt; dstate -&gt; m (a, dstate) <a href="src/Network.TypedProtocol.Driver.html#runPipelinedPeerWithDriver" class="link">Source</a> <a href="#v:runPipelinedPeerWithDriver" class="selflink">#</a></p><div class="doc"><p>Run a pipelined peer with the given driver.</p><p>This runs the peer to completion (if the protocol allows for termination).</p><p>Unlike normal peers, running pipelined peers rely on concurrency, hence the
 <code>MonadAsync</code> constraint.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.1</p></div></body></html>