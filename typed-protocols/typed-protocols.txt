-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A framework for strongly typed protocols
--   
--   A framework for strongly typed protocols
@package typed-protocols
@version 0.1.1.0


-- | This module defines the core of the typed protocol framework.
module Network.TypedProtocol.Core

-- | The protocol type class bundles up all the requirements for a typed
--   protocol.
--   
--   Each protocol consists of three things:
--   
--   <ul>
--   <li>The protocol itself, which is also expected to be the kind of the
--   types of the protocol states. The class is indexed on the protocol
--   itself.</li>
--   <li>The protocol messages.</li>
--   <li>The partition of the protocol states into those in which the
--   client has agency, or the server has agency, or neither have
--   agency.</li>
--   </ul>
--   
--   The labelling of each protocol state with the peer that has agency in
--   that state is done by giving a definition to the data families
--   <a>ClientHasAgency</a>, <a>ServerHasAgency</a> and
--   <a>NobodyHasAgency</a>. These definitions are expected to be
--   singleton-style GADTs with one constructor per protocol state.
--   
--   Each protocol state must be assigned to only one label. See
--   <a>Network.TypedProtocol.Proofs</a> for more details on this point.
class Protocol ps where {
    
    -- | The messages for this protocol. It is expected to be a GADT that is
    --   indexed by the <tt>from</tt> and <tt>to</tt> protocol states. That is
    --   the protocol state the message transitions from, and the protocol
    --   state it transitions into. These are the edges of the protocol state
    --   transition system.
    data Message ps (st :: ps) (st' :: ps);
    
    -- | Tokens for those protocol states in which the client has agency.
    data ClientHasAgency (st :: ps);
    
    -- | Tokens for those protocol states in which the server has agency.
    data ServerHasAgency (st :: ps);
    
    -- | Tokens for terminal protocol states in which neither the client nor
    --   server has agency.
    data NobodyHasAgency (st :: ps);
}

-- | Lemma that if the client has agency for a state, there are no cases in
--   which the server has agency for the same state.
exclusionLemma_ClientAndServerHaveAgency :: forall (st :: ps). Protocol ps => ClientHasAgency st -> ServerHasAgency st -> Void

-- | Lemma that if the nobody has agency for a state, there are no cases in
--   which the client has agency for the same state.
exclusionLemma_NobodyAndClientHaveAgency :: forall (st :: ps). Protocol ps => NobodyHasAgency st -> ClientHasAgency st -> Void

-- | Lemma that if the nobody has agency for a state, there are no cases in
--   which the server has agency for the same state.
exclusionLemma_NobodyAndServerHaveAgency :: forall (st :: ps). Protocol ps => NobodyHasAgency st -> ServerHasAgency st -> Void

-- | Types for client and server peer roles. As protocol can be viewed from
--   either client or server side.
--   
--   Note that technically "client" and "server" are arbitrary labels. The
--   framework is completely symmetric between the two peers.
--   
--   This definition is only used as promoted types and kinds, never as
--   values.
data PeerRole
AsClient :: PeerRole
AsServer :: PeerRole

-- | Singletons for the promoted <a>PeerRole</a> types. Not directly used
--   by the framework, however some times useful when writing code that is
--   shared between client and server.
data TokPeerRole (peerRole :: PeerRole)
[TokAsClient] :: TokPeerRole AsClient
[TokAsServer] :: TokPeerRole AsServer

-- | A type function to flip the client and server roles.
type family FlipAgency (pr :: PeerRole)

-- | This data type is used to hold state tokens for states with either
--   client or server agency. This GADT shows up when writing protocol
--   peers, when <a>Yield</a>ing or <a>Await</a>ing, and when writing
--   message encoders/decoders.
data PeerHasAgency (pr :: PeerRole) (st :: ps)
[ClientAgency] :: !ClientHasAgency st -> PeerHasAgency AsClient st
[ServerAgency] :: !ServerHasAgency st -> PeerHasAgency AsServer st

-- | A synonym for an state token in which "our" peer has agency. This is
--   parametrised over the client or server roles. In either case the peer
--   in question has agency.
--   
--   This shows up when we are sending messages, or dealing with encoding
--   outgoing messages.
type WeHaveAgency (pr :: PeerRole) st = PeerHasAgency pr st

-- | A synonym for an state token in which the other peer has agency. This
--   is parametrised over the client or server roles. In either case the
--   other peer has agency.
--   
--   This shows up when we are receiving messages, or dealing with decoding
--   incoming messages.
type TheyHaveAgency (pr :: PeerRole) st = PeerHasAgency (FlipAgency pr) st

-- | A description of a peer that engages in a protocol.
--   
--   The protocol describes what messages peers <i>may</i> send or
--   <i>must</i> accept. A particular peer implementation decides what to
--   actually do within the constraints of the protocol.
--   
--   Peers engage in a protocol in either the client or server role. Of
--   course the client role can only interact with the serve role for the
--   same protocol and vice versa.
--   
--   <a>Peer</a> has several type arguments:
--   
--   <ul>
--   <li>the protocol itself;</li>
--   <li>the client/server role;</li>
--   <li>.the current protocol state;</li>
--   <li>the monad in which the peer operates; and</li>
--   <li>the type of any final result once the peer terminates.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   pingPongClientExample :: Int -&gt; Peer PingPong AsClient StIdle m ()
--   pingPongServerExample ::        Peer PingPong AsServer StIdle m Int
--   </pre>
--   
--   The actions that a peer can take are:
--   
--   <ul>
--   <li>to perform local monadic effects</li>
--   <li>to terminate with a result (but only in a terminal protocol
--   state)</li>
--   <li>to send a message (but only in a protocol state in which we have
--   agency)</li>
--   <li>to wait to receive a message (but only in a protocol state in
--   which the other peer has agency)</li>
--   </ul>
--   
--   In the <a>Done</a>, <a>Yield</a> and <a>Await</a> cases we must
--   provide evidence of both the protocol state we are in and that the
--   appropriate peer has agency. This takes the form of
--   <a>ClientAgency</a> or <a>ServerAgency</a> applied to a
--   protocol-specific state token: either a <a>ClientHasAgency</a> or a
--   <a>ServerHasAgency</a> token for the protocol. The <a>Done</a> state
--   does not need the extra agency information.
--   
--   While this evidence must be provided, the types guarantee that it is
--   not possible to supply incorrect evidence.
data Peer ps (pr :: PeerRole) (st :: ps) m a

-- | Perform a local monadic effect and then continue.
--   
--   Example:
--   
--   <pre>
--   Effect $ do
--     ...          -- actions in the monad
--     return $ ... -- another Peer value
--   </pre>
[Effect] :: m (Peer ps pr st m a) -> Peer ps pr st m a

-- | Terminate with a result. A state token must be provided from the
--   <a>NobodyHasAgency</a> states, so show that this is a state in which
--   we can terminate.
--   
--   Example:
--   
--   <pre>
--   Yield (ClientAgency TokIdle)
--          MsgDone
--         (Done TokDone result)
--   </pre>
[Done] :: !NobodyHasAgency st -> a -> Peer ps pr st m a

-- | Send a message to the other peer and then continue. This takes the
--   message and the continuation. It also requires evidence that we have
--   agency for this protocol state and thus are allowed to send messages.
--   
--   Example:
--   
--   <pre>
--   Yield (ClientAgency TokIdle) MsgPing $ ...
--   </pre>
[Yield] :: !WeHaveAgency pr st -> Message ps st st' -> Peer ps pr st' m a -> Peer ps pr st m a

-- | Waits to receive a message from the other peer and then continues.
--   This takes the the continuation that is supplied with the received
--   message. It also requires evidence that the other peer has agency for
--   this protocol state and thus we are expected to wait to receive
--   messages.
--   
--   Note that the continuation that gets supplied with the message must be
--   prepared to deal with <i>any</i> message that is allowed in
--   <i>this</i> protocol state. This is why the continuation <i>must</i>
--   be polymorphic in the target state of the message (the third type
--   argument of <a>Message</a>).
--   
--   Example:
--   
--   <pre>
--   Await (ClientAgency TokIdle) $ \msg -&gt;
--   case msg of
--     MsgDone -&gt; ...
--     MsgPing -&gt; ...
--   </pre>
[Await] :: !TheyHaveAgency pr st -> (forall st'. Message ps st st' -> Peer ps pr st' m a) -> Peer ps pr st m a
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Core.Peer ps pr st m)
instance forall ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps). (forall (st' :: ps). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st'), forall (st' :: ps). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st')) => GHC.Show.Show (Network.TypedProtocol.Core.PeerHasAgency pr st)

module Network.TypedProtocol.Pipelined

-- | A description of a peer that engages in a protocol in a pipelined
--   fashion.
--   
--   This is very much like <a>Peer</a>, and can work with the same
--   protocol state machine descriptions, but allows the peer to pipeline
--   the execution of the protocol.
--   
--   This wraps a <a>PeerSender</a>, but works for any internal collect
--   type <tt>c</tt>, and with the starting condition of zero outstanding
--   pipelined responses.
data PeerPipelined ps (pr :: PeerRole) (st :: ps) m a
[PeerPipelined] :: PeerSender ps pr st Z c m a -> PeerPipelined ps pr st m a

-- | This is the pipelined variant of <a>Peer</a>.
--   
--   In particular it has two extra type arguments:
--   
--   <ul>
--   <li><tt>(n :: <a>Outstanding</a>)</tt> records the number of
--   outstanding pipelined responses. Note that when this is <a>Z</a> then
--   we have no such outstanding responses, and we are in an equivalent
--   situation to a normal non-pipelined <a>Peer</a></li>
--   <li><tt>c</tt> records the internal type of the pipelined
--   responses.</li>
--   </ul>
data PeerSender ps (pr :: PeerRole) (st :: ps) (n :: Outstanding) c m a

-- | Same idea as normal <a>Peer</a> <a>Effect</a>.
[SenderEffect] :: m (PeerSender ps pr st n c m a) -> PeerSender ps pr st n c m a

-- | Same idea as normal <a>Peer</a> <a>Done</a>.
[SenderDone] :: !NobodyHasAgency st -> a -> PeerSender ps pr st Z c m a

-- | A normal non-pipelined <a>Yield</a>.
--   
--   Note that we cannot mix pipelined and normal synchronous syle, so this
--   can only be used when there are no outstanding pipelined responses.
--   
--   The <tt>n ~ <a>Z</a></tt> constraint provides the type level
--   guarantees that there are no outstanding pipelined responses.
[SenderYield] :: !WeHaveAgency pr st -> Message ps st st' -> PeerSender ps pr st' Z c m a -> PeerSender ps pr st Z c m a

-- | A normal non-pipelined <a>Await</a>. Note that this can only be used .
--   
--   Note that we cannot mix pipelined and normal synchronous syle, so this
--   can only be used when there are no outstanding pipelined responses.
--   
--   The <tt>n ~ <a>Z</a></tt> constraint provides the type level
--   guarantees that there are no outstanding pipelined responses.
[SenderAwait] :: !TheyHaveAgency pr st -> (forall st'. Message ps st st' -> PeerSender ps pr st' Z c m a) -> PeerSender ps pr st Z c m a

-- | A pipelined equivalent of <a>Yield</a>. The key difference is that
--   instead of moving into the immediate next state <tt>st'</tt>, the
--   sender jumps directly to state <tt>st''</tt> and a seperate
--   <a>PeerReceiver</a> has to be supplied which will get from
--   <tt>st'</tt> to <tt>st''</tt>. This sets up an outstanding pipelined
--   receive. The queue of outstanding pipelined receive actions
--   <a>PeerReceiver</a> are executed in order, as messages arrive from the
--   remote peer.
--   
--   The type records the fact that the number of outstanding pipelined
--   responses increases by one.
[SenderPipeline] :: !WeHaveAgency pr st -> Message ps st st' -> PeerReceiver ps pr (st' :: ps) (st'' :: ps) m c -> PeerSender ps pr (st'' :: ps) (S n) c m a -> PeerSender ps pr (st :: ps) n c m a

-- | Collect the result of a previous pipelined receive action.
--   
--   This (optionally) provides two choices:
--   
--   <ul>
--   <li>Continue without a pipelined result</li>
--   <li>Continue with a pipelined result</li>
--   </ul>
--   
--   Since presenting the first choice is optional, this allows expressing
--   both a blocking collect and a non-blocking collect. This allows
--   implementations to express policies such as sending a short sequence
--   of messages and then waiting for all replies, but also a maximum
--   pipelining policy that keeps a large number of messages in flight but
--   collects results eagerly.
--   
--   The type records the fact that when collecting a response, the number
--   of outstanding pipelined responses decreases by one. The type also
--   guarantees that it can only be used when there is at least one
--   outstanding response.
[SenderCollect] :: Maybe (PeerSender ps pr (st :: ps) (S n) c m a) -> (c -> PeerSender ps pr (st :: ps) n c m a) -> PeerSender ps pr (st :: ps) (S n) c m a
data PeerReceiver ps (pr :: PeerRole) (st :: ps) (stdone :: ps) m c
[ReceiverEffect] :: m (PeerReceiver ps pr st stdone m c) -> PeerReceiver ps pr st stdone m c
[ReceiverDone] :: c -> PeerReceiver ps pr stdone stdone m c
[ReceiverAwait] :: !TheyHaveAgency pr st -> (forall st'. Message ps st st' -> PeerReceiver ps pr st' stdone m c) -> PeerReceiver ps pr st stdone m c

-- | Type level count of the number of outstanding pipelined yields for
--   which we have not yet collected a receiver result. Used in
--   <a>PeerSender</a> to ensure <a>SenderCollect</a> is only used when
--   there are outstanding results to collect, and to ensure
--   <a>SenderYield</a>, <a>SenderAwait</a> and <a>SenderDone</a> are only
--   used when there are none.
type Outstanding = N

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>SenderCollect</a> and <a>SenderDone</a> are being used
--   correctly.
data Nat (n :: N)
pattern Zero :: () => Z ~ n => Nat n
pattern Succ :: () => m ~ S n => Nat n -> Nat m
natToInt :: Nat n -> Int
unsafeIntToNat :: Int -> Nat n

-- | More general than <a>fmap</a>, as it allows to change the protocol.
fmapPeerPipelined :: (forall c. PeerSender ps pr st Z c m a -> PeerSender ps' pr st' Z c m b) -> PeerPipelined ps pr st m a -> PeerPipelined ps' pr st' m b
instance GHC.Show.Show (Network.TypedProtocol.Pipelined.Nat n)
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps). GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Pipelined.PeerPipelined ps pr st m)
instance forall (m :: * -> *) ps (pr :: Network.TypedProtocol.Core.PeerRole) (st :: ps) (n :: Network.TypedProtocol.Pipelined.Outstanding) c. GHC.Base.Functor m => GHC.Base.Functor (Network.TypedProtocol.Pipelined.PeerSender ps pr st n c m)


-- | Actions for running <a>Peer</a>s with a <a>Driver</a>
module Network.TypedProtocol.Driver
data Driver ps dstate m
Driver :: (forall (pr :: PeerRole) (st :: ps) (st' :: ps). PeerHasAgency pr st -> Message ps st st' -> m ()) -> (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> dstate -> m (SomeMessage st, dstate)) -> dstate -> Driver ps dstate m
[sendMessage] :: Driver ps dstate m -> forall (pr :: PeerRole) (st :: ps) (st' :: ps). PeerHasAgency pr st -> Message ps st st' -> m ()
[recvMessage] :: Driver ps dstate m -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> dstate -> m (SomeMessage st, dstate)
[startDState] :: Driver ps dstate m -> dstate

-- | When decoding a <a>Message</a> we only know the expected "from" state.
--   We cannot know the "to" state as this depends on the message we
--   decode. To resolve this we use the <a>SomeMessage</a> wrapper which
--   uses an existential type to hide the "to" state.
data SomeMessage (st :: ps)
[SomeMessage] :: Message ps st st' -> SomeMessage st

-- | Run a peer with the given driver.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
runPeerWithDriver :: forall ps (st :: ps) pr dstate m a. Monad m => Driver ps dstate m -> Peer ps pr st m a -> dstate -> m (a, dstate)

-- | Run a pipelined peer with the given driver.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadAsync</a> constraint.
runPipelinedPeerWithDriver :: forall ps (st :: ps) pr dstate m a. MonadAsync m => Driver ps dstate m -> PeerPipelined ps pr st m a -> dstate -> m (a, dstate)

module Network.TypedProtocol.Codec

-- | A codec for a <a>Protocol</a> handles the encoding and decoding of
--   typed protocol messages. This is typically used when sending protocol
--   messages over untyped channels. The codec chooses the exact encoding,
--   for example encoding in some text-based syntax, or some choice of
--   binary format.
--   
--   The codec is parametrised by:
--   
--   <ul>
--   <li>The protocol</li>
--   <li>The peer role (client/server)</li>
--   <li>the type of decoding failures</li>
--   <li>the monad in which the decoder runs</li>
--   <li>the type of the encoded data (typically strings or bytes)</li>
--   </ul>
--   
--   It is expected that typical codec implementations will be polymorphic
--   in the peer role. For example a codec for the ping/pong protocol might
--   have type:
--   
--   <pre>
--   codecPingPong :: forall m. Monad m =&gt; Codec PingPong String m String
--   </pre>
--   
--   A codec consists of a message encoder and a decoder.
--   
--   The encoder is supplied both with the message to encode and the
--   current protocol state (matching the message). The protocol state can
--   be either a client or server state, but for either peer role it is a
--   protocol state in which the peer has agency, since those are the only
--   states where a peer needs to encode a message to be able to send it.
--   
--   For example a simple text encoder for the ping/pong protocol could be:
--   
--   <pre>
--   encode :: WeHaveAgency pr st
--          -&gt; Message PingPong st st'
--          -&gt; String
--    encode (ClientAgency TokIdle) MsgPing = "ping\n"
--    encode (ClientAgency TokIdle) MsgDone = "done\n"
--    encode (ServerAgency TokBusy) MsgPong = "pong\n"
--   </pre>
--   
--   The decoder is also given the current protocol state and it is
--   expected to be able to decode <i>any</i> message that is valid in that
--   state, but <i>only</i> messages that are valid in that state. Messages
--   that are unexpected for the current state should be treated like any
--   other decoding format error.
--   
--   While the current protocol state is known, the state that the message
--   will have the peer transition to is not known. For this reason the
--   decoded message is wrapped in the <a>SomeMessage</a> constructor which
--   hides the "to" state.
--   
--   The decoder uses an incremental decoding interface <a>DecodeStep</a>
--   so that input can be supplied (e.g. from a Channel) bit by bit. This
--   style of decoder allows but does not require a format with message
--   framing where the decoder input matches exactly with the message
--   boundaries.
--   
--   <pre>
--   decode :: TheyHaveAgency pr st
--          -&gt; m (DecodeStep String String m (SomeMessage st))
--   decode stok =
--     decodeTerminatedFrame '\n' $ \str trailing -&gt;
--       case (stok, str) of
--         (ServerAgency TokBusy, "pong") -&gt;
--              DecodeDone (SomeMessage MsgPong) trailing
--         (ClientAgency TokIdle, "ping") -&gt;
--              DecodeDone (SomeMessage MsgPing) trailing
--         (ClientAgency TokIdle, "done") -&gt;
--              DecodeDone (SomeMessage MsgDone) trailing
--         _ -&gt; DecodeFail ("unexpected message: " ++ str)
--   </pre>
--   
--   The main thing to note is the pattern matching on the combination of
--   the message string and the protocol state. This neatly fulfils the
--   requirement that we only return messages that are of the correct type
--   for the given protocol state.
--   
--   This toy example format uses newlines <tt>n</tt> as a framing format.
--   See <a>DecodeStep</a> for suggestions on how to use it for more
--   realistic formats.
data Codec ps failure m bytes
Codec :: (forall (pr :: PeerRole) (st :: ps) (st' :: ps). PeerHasAgency pr st -> Message ps st st' -> bytes) -> (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> m (DecodeStep bytes failure m (SomeMessage st))) -> Codec ps failure m bytes
[encode] :: Codec ps failure m bytes -> forall (pr :: PeerRole) (st :: ps) (st' :: ps). PeerHasAgency pr st -> Message ps st st' -> bytes
[decode] :: Codec ps failure m bytes -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> m (DecodeStep bytes failure m (SomeMessage st))
hoistCodec :: Functor n => (forall x. m x -> n x) -> Codec ps failure m bytes -> Codec ps failure n bytes
isoCodec :: Functor m => (bytes -> bytes') -> (bytes' -> bytes) -> Codec ps failure m bytes -> Codec ps failure m bytes'
mapFailureCodec :: Functor m => (failure -> failure') -> Codec ps failure m bytes -> Codec ps failure' m bytes

-- | Types for client and server peer roles. As protocol can be viewed from
--   either client or server side.
--   
--   Note that technically "client" and "server" are arbitrary labels. The
--   framework is completely symmetric between the two peers.
--   
--   This definition is only used as promoted types and kinds, never as
--   values.
data PeerRole
AsClient :: PeerRole
AsServer :: PeerRole

-- | This data type is used to hold state tokens for states with either
--   client or server agency. This GADT shows up when writing protocol
--   peers, when <a>Yield</a>ing or <a>Await</a>ing, and when writing
--   message encoders/decoders.
data PeerHasAgency (pr :: PeerRole) (st :: ps)
[ClientAgency] :: !ClientHasAgency st -> PeerHasAgency AsClient st
[ServerAgency] :: !ServerHasAgency st -> PeerHasAgency AsServer st

-- | A synonym for an state token in which "our" peer has agency. This is
--   parametrised over the client or server roles. In either case the peer
--   in question has agency.
--   
--   This shows up when we are sending messages, or dealing with encoding
--   outgoing messages.
type WeHaveAgency (pr :: PeerRole) st = PeerHasAgency pr st

-- | A synonym for an state token in which the other peer has agency. This
--   is parametrised over the client or server roles. In either case the
--   other peer has agency.
--   
--   This shows up when we are receiving messages, or dealing with decoding
--   incoming messages.
type TheyHaveAgency (pr :: PeerRole) st = PeerHasAgency (FlipAgency pr) st

-- | When decoding a <a>Message</a> we only know the expected "from" state.
--   We cannot know the "to" state as this depends on the message we
--   decode. To resolve this we use the <a>SomeMessage</a> wrapper which
--   uses an existential type to hide the "to" state.
data SomeMessage (st :: ps)
[SomeMessage] :: Message ps st st' -> SomeMessage st

-- | Each <a>Codec</a> can use whatever <tt>failure</tt> type is
--   appropriate. This simple exception type is provided for use by simple
--   codecs (e.g. "identity") when nothing more than a <a>String</a> is
--   needed. It is an instance of <a>Exception</a>.
data CodecFailure
CodecFailureOutOfInput :: CodecFailure
CodecFailure :: String -> CodecFailure

-- | An incremental decoder with return a value of type <tt>a</tt>.
--   
--   This interface is not designed to be used directly for implementing
--   decoders, only for running them. In real applications it is expected
--   to use libraries for text or binary decoding and to implement
--   appropriate wrappers to match up with this incremental decoder
--   interface.
--   
--   This style of interface already closely matches that provided by
--   libraries such as <tt>attoparsec</tt> for text formats, and
--   <tt>binary</tt>, <tt>cereal</tt> and <tt>cborg</tt> for binary
--   formats.
data DecodeStep bytes failure m a

-- | The decoder has consumed the available input and needs more to
--   continue. Provide <tt><a>Just</a></tt> if more input is available and
--   <tt><a>Nothing</a></tt> otherwise, and you will get a new
--   <tt><a>DecodeStep</a></tt>.
DecodePartial :: (Maybe bytes -> m (DecodeStep bytes failure m a)) -> DecodeStep bytes failure m a

-- | The decoder has successfully finished. This provides the decoded
--   result value plus any unused input.
DecodeDone :: a -> Maybe bytes -> DecodeStep bytes failure m a

-- | The decoder ran into an error. The decoder either used
--   <tt><a>fail</a></tt> or was not provided enough input.
DecodeFail :: failure -> DecodeStep bytes failure m a

-- | Run a codec incremental decoder <a>DecodeStep</a> against a list of
--   input.
--   
--   It ignores any unused trailing data. This is useful for demos, quick
--   experiments and tests.
--   
--   See also <a>runDecoderWithChannel</a>
runDecoder :: Monad m => [bytes] -> DecodeStep bytes failure m a -> m (Either failure a)

-- | A variant of <a>runDecoder</a> that is suitable for "pure" monads that
--   have a run function. This includes <tt>ST</tt>, using <a>runST</a>.
runDecoderPure :: Monad m => (forall b. m b -> b) -> m (DecodeStep bytes failure m a) -> [bytes] -> Either failure a

-- | Any message for a protocol, without knowing the protocol state.
--   
--   Used at least for <a>Eq</a> instances for messages, but also as a
--   target for an identity codec `Codec ps failure m (AnyMessage ps)` .
data AnyMessage ps
[AnyMessage] :: Message ps st st' -> AnyMessage ps

-- | Used to hold the <a>PeerHasAgency</a> state token and a corresponding
--   <a>Message</a>.
--   
--   Used where we don't know statically what the state type is, but need
--   the agency and message to match each other.
data AnyMessageAndAgency ps
[AnyMessageAndAgency] :: PeerHasAgency pr (st :: ps) -> Message ps (st :: ps) (st' :: ps) -> AnyMessageAndAgency ps

-- | The <a>Codec</a> round-trip property: decode after encode gives the
--   same message. Every codec must satisfy this property.
prop_codecM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => Codec ps failure m bytes -> AnyMessageAndAgency ps -> m Bool

-- | The <a>Codec</a> round-trip property in a pure monad.
prop_codec :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (forall a. m a -> a) -> Codec ps failure m bytes -> AnyMessageAndAgency ps -> Bool

-- | A variant on the codec round-trip property: given the encoding of a
--   message, check that decode always gives the same result irrespective
--   of how the chunks of input are fed to the incremental decoder.
--   
--   This property guards against boundary errors in incremental decoders.
--   It is not necessary to check this for every message type, just for
--   each generic codec construction. For example given some binary
--   serialisation library one would write a generic adaptor to the codec
--   interface. This adaptor has to deal with the incremental decoding and
--   this is what needs to be checked.
prop_codec_splitsM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (bytes -> [[bytes]]) -> Codec ps failure m bytes -> AnyMessageAndAgency ps -> m Bool

-- | Like <tt><a>prop_codec_splitsM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codec_splits :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps)) => (bytes -> [[bytes]]) -> (forall a. m a -> a) -> Codec ps failure m bytes -> AnyMessageAndAgency ps -> Bool

-- | Binary compatibility of two protocols
--   
--   We check the following property:
--   
--   <ol>
--   <li>Using codec A, we encode a message of protocol <tt>psA</tt> to
--   <tt>bytes</tt>.</li>
--   <li>When we decode those <tt>bytes</tt> using codec B, we get a
--   message of protocol <tt>ps</tt>B.</li>
--   <li>When we encode that message again using codec B, we get
--   <tt>bytes</tt>.</li>
--   <li>When we decode those <tt>bytes</tt> using codec A, we get the
--   original message again.</li>
--   </ol>
prop_codec_binary_compatM :: forall psA psB failure m bytes. (Monad m, Eq (AnyMessage psA)) => Codec psA failure m bytes -> Codec psB failure m bytes -> (forall pr (stA :: psA). PeerHasAgency pr stA -> SamePeerHasAgency pr psB) -> AnyMessageAndAgency psA -> m Bool

-- | Like <tt><a>prop_codec_splitsM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codec_binary_compat :: forall psA psB failure m bytes. (Monad m, Eq (AnyMessage psA)) => (forall a. m a -> a) -> Codec psA failure m bytes -> Codec psB failure m bytes -> (forall pr (stA :: psA). PeerHasAgency pr stA -> SamePeerHasAgency pr psB) -> AnyMessageAndAgency psA -> Bool

-- | Compatibility between two codecs of the same protocol. Encode a
--   message with one codec and decode it with the other one, then compare
--   if the result is the same as initial message.
prop_codecs_compatM :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps), forall a. Monoid a => Monoid (m a)) => Codec ps failure m bytes -> Codec ps failure m bytes -> AnyMessageAndAgency ps -> m Bool

-- | Like <tt><a>prop_codecs_compatM</a></tt> but run in a pure monad
--   <tt>m</tt>, e.g. <tt>Identity</tt>.
prop_codecs_compat :: forall ps failure m bytes. (Monad m, Eq (AnyMessage ps), forall a. Monoid a => Monoid (m a)) => (forall a. m a -> a) -> Codec ps failure m bytes -> Codec ps failure m bytes -> AnyMessageAndAgency ps -> Bool

-- | Auxiliary definition for <a>prop_codec_binary_compatM</a>.
--   
--   Used for the existential <tt>st :: ps</tt> parameter when expressing
--   that for each value of <a>PeerHasAgency</a> for protocol A, there is a
--   corresponding <a>PeerHasAgency</a> for protocol B of some <tt>st ::
--   ps</tt>.
data SamePeerHasAgency (pr :: PeerRole) (ps :: Type)
[SamePeerHasAgency] :: forall (pr :: PeerRole) ps (st :: ps). PeerHasAgency pr st -> SamePeerHasAgency pr ps
instance GHC.Show.Show Network.TypedProtocol.Codec.CodecFailure
instance GHC.Classes.Eq Network.TypedProtocol.Codec.CodecFailure
instance (forall (st :: ps). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st), forall (st :: ps). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st), forall (st :: ps) (st' :: ps). GHC.Show.Show (Network.TypedProtocol.Core.Message ps st st')) => GHC.Show.Show (Network.TypedProtocol.Codec.AnyMessageAndAgency ps)
instance (forall (st :: ps) (st' :: ps). GHC.Show.Show (Network.TypedProtocol.Core.Message ps st st')) => GHC.Show.Show (Network.TypedProtocol.Codec.AnyMessage ps)
instance GHC.Exception.Type.Exception Network.TypedProtocol.Codec.CodecFailure


-- | Proofs about the typed protocol framework.
--   
--   It also provides helpful testing utilities.
module Network.TypedProtocol.Proofs

-- | The <a>connect</a> function takes two peers that agree on a protocol
--   and runs them in lock step, until (and if) they complete.
--   
--   The <a>connect</a> function serves a few purposes.
--   
--   <ul>
--   <li>The fact we can define this function at at all proves some minimal
--   sanity property of the typed protocol framework.</li>
--   <li>It demonstrates that all protocols defined in the framework can be
--   run with synchronous communication rather than requiring buffered
--   communication.</li>
--   <li>It is useful for testing peer implementations against each other
--   in a minimalistic setting.</li>
--   </ul>
connect :: forall ps (pr :: PeerRole) (st :: ps) m a b. (Monad m, Protocol ps) => Peer ps pr st m a -> Peer ps (FlipAgency pr) st m b -> m (a, b, TerminalStates ps)

-- | The terminal states for the protocol. Used in <a>connect</a> and
--   <a>connectPipelined</a> to return the states in which the peers
--   terminated.
data TerminalStates ps
[TerminalStates] :: forall ps (st :: ps). NobodyHasAgency st -> NobodyHasAgency st -> TerminalStates ps

-- | Analogous to <a>connect</a> but for pipelined peers.
--   
--   Since pipelining allows multiple possible interleavings, we provide a
--   <tt>[Bool]</tt> parameter to control the choices. Each <tt>True</tt>
--   will trigger picking the first choice in the <tt>SenderCollect</tt>
--   construct (if possible), leading to more results outstanding. This can
--   also be interpreted as a greater pipeline depth, or more messages
--   in-flight.
--   
--   This can be exercised using a QuickCheck style generator.
connectPipelined :: forall ps (pr :: PeerRole) (st :: ps) m a b. (Monad m, Protocol ps) => [Bool] -> PeerPipelined ps pr st m a -> Peer ps (FlipAgency pr) st m b -> m (a, b, TerminalStates ps)

-- | Prove that we have a total conversion from pipelined peers to regular
--   peers. This is a sanity property that shows that pipelining did not
--   give us extra expressiveness or to break the protocol state machine.
forgetPipelined :: forall ps (pr :: PeerRole) (st :: ps) m a. Functor m => PeerPipelined ps pr st m a -> Peer ps pr st m a

-- | A size indexed queue. This is useful for proofs, including
--   <a>connectPipelined</a> but also as so-called <tt>direct</tt>
--   functions for running a client and server wrapper directly against
--   each other.
data Queue (n :: N) a
[EmptyQ] :: Queue Z a
[ConsQ] :: a -> Queue n a -> Queue (S n) a

-- | At an element to the end of a <a>Queue</a>. This is not intended to be
--   efficient. It is only for proofs and tests.
enqueue :: a -> Queue n a -> Queue (S n) a

-- | A reference specification for interleaving of requests and responses
--   with pipelining, where the environment can choose whether a response
--   is available yet.
--   
--   This also supports bounded choice where the maximum number of
--   outstanding in-flight responses is limted.
pipelineInterleaving :: Int -> [Bool] -> [req] -> [resp] -> [Either req resp]


-- | This package defines the typed protocol framework. This module
--   re-exports the public API.
module Network.TypedProtocol
