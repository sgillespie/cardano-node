-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binary serialization library used throughout ledger
--   
--   Binary serialization library used throughout ledger
@package cardano-ledger-binary
@version 1.3.0.0


-- | Module that re-exports everythign from `cardano-binary` package.
--   
--   Everything that gets defined in this module should most likely be
--   migrated to `cardano-binary` package.
module Cardano.Ledger.Binary.Plain
data () => Decoder s a
type ByteOffset = Int64
type Size = Fix SizeF
data () => Range b
Range :: b -> b -> Range b
[lo] :: Range b -> b
[hi] :: Range b -> b
newtype () => Encoding
Encoding :: (Tokens -> Tokens) -> Encoding
class Typeable a => FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a
label :: FromCBOR a => Proxy a -> Text
class Typeable a => ToCBOR a
toCBOR :: ToCBOR a => a -> Encoding
encodedListSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy [a] -> Size
data () => Tokens
TkWord :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkWord64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInt :: {-# UNPACK #-} !Int -> Tokens -> Tokens
TkInt64 :: {-# UNPACK #-} !Int64 -> Tokens -> Tokens
TkBytes :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkBytesBegin :: Tokens -> Tokens
TkByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkString :: {-# UNPACK #-} !Text -> Tokens -> Tokens
TkUtf8ByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkStringBegin :: Tokens -> Tokens
TkListLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkListBegin :: Tokens -> Tokens
TkMapLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkMapBegin :: Tokens -> Tokens
TkTag :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkTag64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInteger :: !Integer -> Tokens -> Tokens
TkNull :: Tokens -> Tokens
TkUndef :: Tokens -> Tokens
TkBool :: !Bool -> Tokens -> Tokens
TkSimple :: {-# UNPACK #-} !Word8 -> Tokens -> Tokens
TkFloat16 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat32 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat64 :: {-# UNPACK #-} !Double -> Tokens -> Tokens
TkBreak :: Tokens -> Tokens
TkEncoded :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkEnd :: Tokens
data () => Case t
Case :: Text -> t -> Case t
newtype () => LengthOf xs
LengthOf :: xs -> LengthOf xs
data () => SizeOverride
SizeConstant :: Size -> SizeOverride
SizeExpression :: ((forall a. ToCBOR a => Proxy a -> Size) -> Size) -> SizeOverride
SelectCases :: [Text] -> SizeOverride
data () => DecoderError
DecoderErrorCanonicityViolation :: Text -> DecoderError
DecoderErrorCustom :: Text -> Text -> DecoderError
DecoderErrorDeserialiseFailure :: Text -> DeserialiseFailure -> DecoderError
DecoderErrorEmptyList :: Text -> DecoderError
DecoderErrorLeftover :: Text -> ByteString -> DecoderError
DecoderErrorSizeMismatch :: Text -> Int -> Int -> DecoderError
DecoderErrorUnknownTag :: Text -> Word8 -> DecoderError
DecoderErrorVoid :: DecoderError
data () => DecodeAction s a
ConsumeWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTag :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInteger :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDouble :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytes :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeString :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBool :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimple :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeStringIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeMapLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeNull :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBreakOr :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekTokenType :: (TokenType -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekAvailable :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekByteOffset :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTagCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntegerCanonical :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat16Canonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloatCanonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDoubleCanonical :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesCanonical :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeStringCanonical :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimpleCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
Fail :: String -> DecodeAction s a
Done :: a -> DecodeAction s a
data () => TokenType
TypeUInt :: TokenType
TypeUInt64 :: TokenType
TypeNInt :: TokenType
TypeNInt64 :: TokenType
TypeInteger :: TokenType
TypeFloat16 :: TokenType
TypeFloat32 :: TokenType
TypeFloat64 :: TokenType
TypeBytes :: TokenType
TypeBytesIndef :: TokenType
TypeString :: TokenType
TypeStringIndef :: TokenType
TypeListLen :: TokenType
TypeListLen64 :: TokenType
TypeListLenIndef :: TokenType
TypeMapLen :: TokenType
TypeMapLen64 :: TokenType
TypeMapLenIndef :: TokenType
TypeTag :: TokenType
TypeTag64 :: TokenType
TypeBool :: TokenType
TypeNull :: TokenType
TypeSimple :: TokenType
TypeBreak :: TokenType
TypeInvalid :: TokenType
liftST :: ST s a -> Decoder s a
decodeFloat :: Decoder s Float
encodeFloat :: Float -> Encoding
decodeFull :: FromCBOR a => ByteString -> Either DecoderError a
decodeFull' :: FromCBOR a => ByteString -> Either DecoderError a
decodeFullDecoder :: Text -> (forall s. () => Decoder s a) -> ByteString -> Either DecoderError a
decodeFullDecoder' :: Text -> (forall s. () => Decoder s a) -> ByteString -> Either DecoderError a
decodeNestedCbor :: FromCBOR a => Decoder s a
decodeNestedCborBytes :: Decoder s ByteString
unsafeDeserialize :: FromCBOR a => ByteString -> a
unsafeDeserialize' :: FromCBOR a => ByteString -> a
toStrictByteString :: Encoding -> ByteString
serialize :: ToCBOR a => a -> ByteString
serialize' :: ToCBOR a => a -> ByteString
serializeBuilder :: ToCBOR a => a -> Builder
encodeNestedCbor :: ToCBOR a => a -> Encoding
encodeNestedCborBytes :: ByteString -> Encoding
nestedCborSizeExpr :: Size -> Size
nestedCborBytesSizeExpr :: Size -> Size
encodeListLen :: Word -> Encoding
encodeMapLen :: Word -> Encoding
encodeTag :: Word -> Encoding
encodeWord :: Word -> Encoding
encodeMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeSeq :: (a -> Encoding) -> Seq a -> Encoding
encodeWord8 :: Word8 -> Encoding
encodeWord16 :: Word16 -> Encoding
encodeWord32 :: Word32 -> Encoding
encodeWord64 :: Word64 -> Encoding
encodeInt :: Int -> Encoding
encodeInt8 :: Int8 -> Encoding
encodeInt16 :: Int16 -> Encoding
encodeInt32 :: Int32 -> Encoding
encodeInt64 :: Int64 -> Encoding
encodeInteger :: Integer -> Encoding
encodeBytes :: ByteString -> Encoding
encodeBytesIndef :: Encoding
encodeByteArray :: SlicedByteArray -> Encoding
encodeString :: Text -> Encoding
encodeStringIndef :: Encoding
encodeUtf8ByteArray :: SlicedByteArray -> Encoding
encodeListLenIndef :: Encoding
encodeMapLenIndef :: Encoding
encodeBreak :: Encoding
encodeTag64 :: Word64 -> Encoding
encodeBool :: Bool -> Encoding
encodeUndef :: Encoding
encodeNull :: Encoding
encodeSimple :: Word8 -> Encoding
encodeFloat16 :: Float -> Encoding
encodeDouble :: Double -> Encoding
encodePreEncoded :: ByteString -> Encoding
withWordSize :: (Integral s, Integral a) => s -> a
szEval :: (forall t. ToCBOR t => (Proxy t -> Size) -> Proxy t -> Range Natural) -> Size -> Range Natural
caseValue :: Case t -> t
isTodo :: Size -> Bool
szCases :: [Case Size] -> Size
szLazy :: ToCBOR a => Proxy a -> Size
szGreedy :: ToCBOR a => Proxy a -> Size
szForce :: Size -> Size
szWithCtx :: ToCBOR a => Map TypeRep SizeOverride -> Proxy a -> Size
szSimplify :: Size -> Either Size (Range Natural)
apMono :: Text -> (Natural -> Natural) -> Size -> Size
szBounds :: ToCBOR a => a -> Either Size (Range Natural)
decodeWithByteSpan :: Decoder s a -> Decoder s (a, ByteOffset, ByteOffset)
cborError :: (MonadFail m, Buildable e) => e -> m a
toCborError :: (MonadFail m, Buildable e) => Either e a -> m a
enforceSize :: Text -> Int -> Decoder s ()
matchSize :: Text -> Int -> Int -> Decoder s ()
decodeMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeSeq :: Decoder s a -> Decoder s (Seq a)
decodeBool :: Decoder s Bool
decodeBreakOr :: Decoder s Bool
decodeByteArray :: Decoder s ByteArray
decodeByteArrayCanonical :: Decoder s ByteArray
decodeBytes :: Decoder s ByteString
decodeBytesCanonical :: Decoder s ByteString
decodeBytesIndef :: Decoder s ()
decodeDouble :: Decoder s Double
decodeDoubleCanonical :: Decoder s Double
decodeFloat16Canonical :: Decoder s Float
decodeFloatCanonical :: Decoder s Float
decodeInt :: Decoder s Int
decodeInt16 :: Decoder s Int16
decodeInt16Canonical :: Decoder s Int16
decodeInt32 :: Decoder s Int32
decodeInt32Canonical :: Decoder s Int32
decodeInt64 :: Decoder s Int64
decodeInt64Canonical :: Decoder s Int64
decodeInt8 :: Decoder s Int8
decodeInt8Canonical :: Decoder s Int8
decodeIntCanonical :: Decoder s Int
decodeInteger :: Decoder s Integer
decodeIntegerCanonical :: Decoder s Integer
decodeListLen :: Decoder s Int
decodeListLenCanonical :: Decoder s Int
decodeListLenCanonicalOf :: Int -> Decoder s ()
decodeListLenIndef :: Decoder s ()
decodeListLenOf :: Int -> Decoder s ()
decodeListLenOrIndef :: Decoder s (Maybe Int)
decodeMapLen :: Decoder s Int
decodeMapLenCanonical :: Decoder s Int
decodeMapLenIndef :: Decoder s ()
decodeMapLenOrIndef :: Decoder s (Maybe Int)
decodeNegWord :: Decoder s Word
decodeNegWord64 :: Decoder s Word64
decodeNegWord64Canonical :: Decoder s Word64
decodeNegWordCanonical :: Decoder s Word
decodeNull :: Decoder s ()
decodeSequenceLenIndef :: (r -> a -> r) -> r -> (r -> r') -> Decoder s a -> Decoder s r'
decodeSequenceLenN :: (r -> a -> r) -> r -> (r -> r') -> Int -> Decoder s a -> Decoder s r'
decodeSimple :: Decoder s Word8
decodeSimpleCanonical :: Decoder s Word8
decodeString :: Decoder s Text
decodeStringCanonical :: Decoder s Text
decodeStringIndef :: Decoder s ()
decodeTag :: Decoder s Word
decodeTag64 :: Decoder s Word64
decodeTag64Canonical :: Decoder s Word64
decodeTagCanonical :: Decoder s Word
decodeUtf8ByteArray :: Decoder s ByteArray
decodeUtf8ByteArrayCanonical :: Decoder s ByteArray
decodeWord :: Decoder s Word
decodeWord16 :: Decoder s Word16
decodeWord16Canonical :: Decoder s Word16
decodeWord32 :: Decoder s Word32
decodeWord32Canonical :: Decoder s Word32
decodeWord64 :: Decoder s Word64
decodeWord64Canonical :: Decoder s Word64
decodeWord8 :: Decoder s Word8
decodeWord8Canonical :: Decoder s Word8
decodeWordCanonical :: Decoder s Word
decodeWordCanonicalOf :: Word -> Decoder s ()
decodeWordOf :: Word -> Decoder s ()
peekAvailable :: Decoder s Int
peekByteOffset :: Decoder s ByteOffset
peekTokenType :: Decoder s TokenType
decodeCollection :: Decoder s (Maybe Int) -> Decoder s a -> Decoder s [a]
decodeCollectionWithLen :: Decoder s (Maybe Int) -> Decoder s v -> Decoder s (Int, [v])
decodeListWith :: Decoder s a -> Decoder s [a]
decodeMapSkel :: (Ord k, FromCBOR k, FromCBOR v) => ([(k, v)] -> m) -> Decoder s m
decodeNominalDiffTime :: Decoder s NominalDiffTime
decodeNominalDiffTimeMicro :: Decoder s NominalDiffTime
fromCBORMaybe :: Decoder s a -> Decoder s (Maybe a)
serializeEncoding :: Encoding -> ByteString
serializeEncoding' :: Encoding -> ByteString
encodeNominalDiffTime :: NominalDiffTime -> Encoding
encodeNominalDiffTimeMicro :: NominalDiffTime -> Encoding
toCBORMaybe :: (a -> Encoding) -> Maybe a -> Encoding
getDecodeAction :: Decoder s a -> ST s (DecodeAction s a)
showDecoderError :: Buildable e => e -> String

-- | Report an error when a numeric key of the type constructor doesn't
--   match.
invalidKey :: MonadFail m => Word -> m a
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: Text -> (Word -> Decoder s (Int, a)) -> Decoder s a
decodeListLikeT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> m (Decoder s) a -> (a -> Int -> m (Decoder s) ()) -> m (Decoder s) a

-- | Encode a type as CBOR and encode it as base16
serializeAsHexText :: ToCBOR a => a -> Text

-- | Try decoding base16 encode bytes and then try to decoding them as CBOR
decodeFullFromHexText :: FromCBOR a => Text -> Either DecoderError a
encodeEnum :: Enum a => a -> Encoding
decodeEnumBounded :: forall a s. (Enum a, Bounded a, Typeable a) => Decoder s a
encodeVerKeyDSIGN :: DSIGNAlgorithm v => VerKeyDSIGN v -> Encoding
decodeVerKeyDSIGN :: DSIGNAlgorithm v => Decoder s (VerKeyDSIGN v)
encodeSignKeyDSIGN :: DSIGNAlgorithm v => SignKeyDSIGN v -> Encoding
decodeSignKeyDSIGN :: DSIGNAlgorithm v => Decoder s (SignKeyDSIGN v)
encodeSigDSIGN :: DSIGNAlgorithm v => SigDSIGN v -> Encoding
decodeSigDSIGN :: DSIGNAlgorithm v => Decoder s (SigDSIGN v)
encodeSignedDSIGN :: DSIGNAlgorithm v => SignedDSIGN v a -> Encoding
decodeSignedDSIGN :: DSIGNAlgorithm v => Decoder s (SignedDSIGN v a)
encodeVerKeyKES :: KESAlgorithm v => VerKeyKES v -> Encoding
decodeVerKeyKES :: KESAlgorithm v => Decoder s (VerKeyKES v)
encodeSignKeyKES :: KESAlgorithm v => SignKeyKES v -> Encoding
decodeSignKeyKES :: KESAlgorithm v => Decoder s (SignKeyKES v)
encodeSigKES :: KESAlgorithm v => SigKES v -> Encoding
decodeSigKES :: KESAlgorithm v => Decoder s (SigKES v)
encodeSignedKES :: KESAlgorithm v => SignedKES v a -> Encoding
decodeSignedKES :: KESAlgorithm v => Decoder s (SignedKES v a)
encodeVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> Encoding
decodeVerKeyVRF :: VRFAlgorithm v => Decoder s (VerKeyVRF v)
encodeSignKeyVRF :: VRFAlgorithm v => SignKeyVRF v -> Encoding
decodeSignKeyVRF :: VRFAlgorithm v => Decoder s (SignKeyVRF v)
encodeCertVRF :: VRFAlgorithm v => CertVRF v -> Encoding
decodeCertVRF :: VRFAlgorithm v => Decoder s (CertVRF v)

module Cardano.Ledger.Binary.Version

-- | Protocol version number that is used during encoding and decoding. All
--   supported versions are in the range from <a>MinVersion</a> to
--   <a>MaxVersion</a>.
data Version

-- | Convert a <a>Version</a> to an <a>Integral</a> value.
--   
--   <i>Note</i> - Version spans a fairly small range of non-negative
--   numbers, so this should be safe even for smallest integral types.
getVersion :: Integral i => Version -> i

-- | Minimum supported version
type MinVersion = 0

-- | Maximum supported version. This is the protocol version of the next
--   upcoming era
type MaxVersion = 10

-- | Same as <a>natVersionProxy</a>, construct a version from a type level
--   <tt>Nat</tt>, except it can be supplied through
--   <tt>TypeApplications</tt>.
natVersion :: forall v. (KnownNat v, MinVersion <= v, v <= MaxVersion) => Version

-- | Safely construct a <a>Version</a> from a type level <tt>Nat</tt>,
--   which is supplied as a <a>Proxy</a>
natVersionProxy :: (KnownNat v, MinVersion <= v, v <= MaxVersion) => Proxy v -> Version

-- | Increment version by 1.
succVersion :: MonadFail m => Version -> m Version

-- | Construct a <a>Version</a> and fail if the supplied value is not a
--   supported version number.
mkVersion :: (Integral i, MonadFail m) => i -> m Version

-- | Construct a <a>Version</a> and fail if the supplied value is not
--   supported version number.
mkVersion64 :: MonadFail m => Word64 -> m Version

-- | Extract <a>Word64</a> representation of the <a>Version</a>
getVersion64 :: Version -> Word64
allVersions :: [Version]
byronProtVer :: Version
shelleyProtVer :: Version
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Binary.Version.Version
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Binary.Version.Version
instance NoThunks.Class.NoThunks Cardano.Ledger.Binary.Version.Version
instance Control.DeepSeq.NFData Cardano.Ledger.Binary.Version.Version
instance GHC.Show.Show Cardano.Ledger.Binary.Version.Version
instance GHC.Classes.Ord Cardano.Ledger.Binary.Version.Version
instance GHC.Classes.Eq Cardano.Ledger.Binary.Version.Version
instance GHC.Enum.Bounded Cardano.Ledger.Binary.Version.Version
instance GHC.Enum.Enum Cardano.Ledger.Binary.Version.Version
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Binary.Version.Version
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Binary.Version.Version

module Cardano.Ledger.Binary.Crypto
encodeVerKeyDSIGN :: DSIGNAlgorithm v => VerKeyDSIGN v -> Encoding
decodeVerKeyDSIGN :: DSIGNAlgorithm v => Decoder s (VerKeyDSIGN v)
encodeSignKeyDSIGN :: DSIGNAlgorithm v => SignKeyDSIGN v -> Encoding
decodeSignKeyDSIGN :: DSIGNAlgorithm v => Decoder s (SignKeyDSIGN v)
encodeSigDSIGN :: DSIGNAlgorithm v => SigDSIGN v -> Encoding
decodeSigDSIGN :: DSIGNAlgorithm v => Decoder s (SigDSIGN v)
encodeSignedDSIGN :: DSIGNAlgorithm v => SignedDSIGN v a -> Encoding
decodeSignedDSIGN :: DSIGNAlgorithm v => Decoder s (SignedDSIGN v a)
encodeVerKeyKES :: KESAlgorithm v => VerKeyKES v -> Encoding
decodeVerKeyKES :: KESAlgorithm v => Decoder s (VerKeyKES v)
encodeSignKeyKES :: KESAlgorithm v => SignKeyKES v -> Encoding
decodeSignKeyKES :: KESAlgorithm v => Decoder s (SignKeyKES v)
encodeSigKES :: KESAlgorithm v => SigKES v -> Encoding
decodeSigKES :: KESAlgorithm v => Decoder s (SigKES v)
encodeSignedKES :: KESAlgorithm v => SignedKES v a -> Encoding
decodeSignedKES :: KESAlgorithm v => Decoder s (SignedKES v a)
encodeVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> Encoding
decodeVerKeyVRF :: VRFAlgorithm v => Decoder s (VerKeyVRF v)
encodeSignKeyVRF :: VRFAlgorithm v => SignKeyVRF v -> Encoding
decodeSignKeyVRF :: VRFAlgorithm v => Decoder s (SignKeyVRF v)
encodeCertVRF :: VRFAlgorithm v => CertVRF v -> Encoding
decodeCertVRF :: VRFAlgorithm v => Decoder s (CertVRF v)

module Cardano.Ledger.Binary.Encoding

-- | Serialize a Haskell value with a <a>EncCBOR</a> instance to an
--   external binary representation.
--   
--   The output is represented as a lazy <a>ByteString</a> and is
--   constructed incrementally.
serialize :: EncCBOR a => Version -> a -> ByteString

-- | Serialize a Haskell value to an external binary representation.
--   
--   The output is represented as a strict <tt>ByteString</tt>.
serialize' :: EncCBOR a => Version -> a -> ByteString

-- | Serialize into a Builder. Useful if you want to throw other
--   ByteStrings around it.
serializeBuilder :: EncCBOR a => Version -> a -> Builder
hashWithEncoder :: forall h a. HashAlgorithm h => Version -> (a -> Encoding) -> a -> Hash h a
hashEncCBOR :: forall h a. (HashAlgorithm h, EncCBOR a) => Version -> a -> Hash h a
data Encoding
toBuilder :: Version -> Encoding -> Builder
data () => Tokens
TkWord :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkWord64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInt :: {-# UNPACK #-} !Int -> Tokens -> Tokens
TkInt64 :: {-# UNPACK #-} !Int64 -> Tokens -> Tokens
TkBytes :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkBytesBegin :: Tokens -> Tokens
TkByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkString :: {-# UNPACK #-} !Text -> Tokens -> Tokens
TkUtf8ByteArray :: {-# UNPACK #-} !SlicedByteArray -> Tokens -> Tokens
TkStringBegin :: Tokens -> Tokens
TkListLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkListBegin :: Tokens -> Tokens
TkMapLen :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkMapBegin :: Tokens -> Tokens
TkTag :: {-# UNPACK #-} !Word -> Tokens -> Tokens
TkTag64 :: {-# UNPACK #-} !Word64 -> Tokens -> Tokens
TkInteger :: !Integer -> Tokens -> Tokens
TkNull :: Tokens -> Tokens
TkUndef :: Tokens -> Tokens
TkBool :: !Bool -> Tokens -> Tokens
TkSimple :: {-# UNPACK #-} !Word8 -> Tokens -> Tokens
TkFloat16 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat32 :: {-# UNPACK #-} !Float -> Tokens -> Tokens
TkFloat64 :: {-# UNPACK #-} !Double -> Tokens -> Tokens
TkBreak :: Tokens -> Tokens
TkEncoded :: {-# UNPACK #-} !ByteString -> Tokens -> Tokens
TkEnd :: Tokens
toPlainEncoding :: Version -> Encoding -> Encoding
fromPlainEncoding :: Encoding -> Encoding
fromPlainEncodingWithVersion :: (Version -> Encoding) -> Encoding

-- | Get access to the current version being used in the encoder
withCurrentEncodingVersion :: (Version -> Encoding) -> Encoding

-- | Ignore the current version of the encoder and enforce the supplied one
--   instead.
enforceEncodingVersion :: Version -> Encoding -> Encoding

-- | Conditionoly choose the encoder newer or older deceder, depending on
--   the current version. Supplied version acts as a pivot.
--   
--   <h5><b>Example</b></h5>
ifEncodingVersionAtLeast :: Version -> Encoding -> Encoding -> Encoding
encodeVersion :: Version -> Encoding
encodeMaybe :: (a -> Encoding) -> Maybe a -> Encoding

-- | Alternative way to encode a Maybe type.
--   
--   <i>Note</i> - this is not the default method for encoding
--   <a>Maybe</a>, use <a>encodeMaybe</a> instead
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeStrictMaybe :: (a -> Encoding) -> StrictMaybe a -> Encoding

-- | Alternative way to encode a Maybe type.
--   
--   <i>Note</i> - this is not the default method for encoding
--   <a>StrictMaybe</a>, use <a>encodeStrictMaybe</a> instead
encodeNullStrictMaybe :: (a -> Encoding) -> StrictMaybe a -> Encoding

-- | <i>Deprecated: In favor of <a>encodeTuple</a></i>
encodePair :: (a -> Encoding) -> (b -> Encoding) -> (a, b) -> Encoding
encodeTuple :: (a -> Encoding) -> (b -> Encoding) -> (a, b) -> Encoding
encodeRatio :: (t -> Encoding) -> Ratio t -> Encoding
encodeRatioNoTag :: (t -> Encoding) -> Ratio t -> Encoding

-- | Encode a rational number with tag 30, as per tag assignment:
--   <a>https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml</a>
--   
--   <a>https://peteroupc.github.io/CBOR/rational.html</a>
encodeRatioWithTag :: (t -> Encoding) -> Ratio t -> Encoding
encodeEnum :: Enum a => a -> Encoding
encodeWithOrigin :: (a -> Encoding) -> WithOrigin a -> Encoding

-- | Encode a list. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 2] - Variable length encoding for lists longer than 23
--   elements, otherwise exact length encoding</li>
--   <li>[&lt; 2] - Variable length encoding</li>
--   </ul>
encodeList :: (a -> Encoding) -> [a] -> Encoding

-- | Encode a Seq. Variable length encoding for Sequences larger than 23
--   elements, otherwise exact length encoding
encodeSeq :: (a -> Encoding) -> Seq a -> Encoding
encodeStrictSeq :: (a -> Encoding) -> StrictSeq a -> Encoding

-- | Encode a Set. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 9] - Variable length encoding for Sets larger than 23
--   elements, otherwise exact length encoding. Prefixes with a special 258
--   <a>setTag</a>.</li>
--   <li>[&gt;= 2] - Variable length encoding for Sets larger than 23
--   elements, otherwise exact length encoding</li>
--   <li>[&lt; 2] - Variable length encoding. Prefixes with a special 258
--   <a>setTag</a>.</li>
--   </ul>
encodeSet :: (a -> Encoding) -> Set a -> Encoding

-- | Encode a Map. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 2] - Variable length encoding for Maps larger than 23 key
--   value pairs, otherwise exact length encoding</li>
--   <li>[&lt; 2] - Variable length encoding.</li>
--   </ul>
encodeMap :: (k -> Encoding) -> (v -> Encoding) -> Map k v -> Encoding

-- | Mimics <tt>Map</tt> encoder <a>encodeMap</a> identically.
encodeVMap :: (Vector kv k, Vector vv v) => (k -> Encoding) -> (v -> Encoding) -> VMap kv vv k v -> Encoding

-- | Generic encoder for vectors. Its intended use is to allow easy
--   definition of <tt>EncCBOR</tt> instances for custom vector
encodeVector :: Vector v a => (a -> Encoding) -> v a -> Encoding

-- | Conditionally use variable length encoding for list like structures
--   with length larger than 23, otherwise use exact list length encoding.
variableListLenEncoding :: Int -> Encoding -> Encoding

-- | Encode any Foldable with the variable list length encoding, which will
--   use indefinite encoding over 23 elements and definite otherwise.
encodeFoldableEncoder :: Foldable f => (a -> Encoding) -> f a -> Encoding
encodeFoldableAsDefLenList :: Foldable f => (a -> Encoding) -> f a -> Encoding

-- | Encode any Foldable with indefinite list length encoding
encodeFoldableAsIndefLenList :: Foldable f => (a -> Encoding) -> f a -> Encoding

-- | Encode a data structure as a Map with the 0-based index for a Key to a
--   value. Uses variable map length encoding, which means an indefinite
--   encoding for maps with over 23 elements and definite otherwise.
encodeFoldableMapEncoder :: Foldable f => (Word -> a -> Maybe Encoding) -> f a -> Encoding

-- | This is the optimal maximum number for encoding exact length. Above
--   that threashold using variable length encoding will result in less
--   bytes on the wire.
lengthThreshold :: Int
encodeUTCTime :: UTCTime -> Encoding
encodeIPv4 :: IPv4 -> Encoding
ipv4ToBytes :: IPv4 -> ByteString
encodeIPv6 :: IPv6 -> Encoding
ipv6ToBytes :: IPv6 -> ByteString
encodeWord :: Word -> Encoding
encodeWord8 :: Word8 -> Encoding
encodeWord16 :: Word16 -> Encoding
encodeWord32 :: Word32 -> Encoding
encodeWord64 :: Word64 -> Encoding
encodeInt :: Int -> Encoding
encodeInt8 :: Int8 -> Encoding
encodeInt16 :: Int16 -> Encoding
encodeInt32 :: Int32 -> Encoding
encodeInt64 :: Int64 -> Encoding
encodeInteger :: Integer -> Encoding
encodeBytes :: ByteString -> Encoding
encodeBytesIndef :: Encoding
encodeByteArray :: SlicedByteArray -> Encoding
encodeString :: Text -> Encoding
encodeStringIndef :: Encoding
encodeUtf8ByteArray :: SlicedByteArray -> Encoding
encodeListLen :: Word -> Encoding
encodeListLenIndef :: Encoding
encodeMapLen :: Word -> Encoding
encodeMapLenIndef :: Encoding
encodeBreak :: Encoding
encodeTag :: Word -> Encoding
encodeTag64 :: Word64 -> Encoding
encodeBool :: Bool -> Encoding
encodeUndef :: Encoding
encodeNull :: Encoding
encodeSimple :: Word8 -> Encoding
encodeFloat16 :: Float -> Encoding
encodeFloat :: Float -> Encoding
encodeDouble :: Double -> Encoding
encodePreEncoded :: ByteString -> Encoding
encodeTerm :: Term -> Encoding
class Typeable a => EncCBOR a
encCBOR :: EncCBOR a => a -> Encoding
encCBOR :: (EncCBOR a, ToCBOR a) => a -> Encoding
encodedSizeExpr :: EncCBOR a => (forall t. EncCBOR t => Proxy t -> Size) -> Proxy a -> Size
encodedListSizeExpr :: EncCBOR a => (forall t. EncCBOR t => Proxy t -> Size) -> Proxy [a] -> Size

-- | Compute encoded size of an integer
withWordSize :: (Integral s, Integral a) => s -> a
newtype PreEncoded
PreEncoded :: ByteString -> PreEncoded
[unPreEncoded] :: PreEncoded -> ByteString

-- | Convert a versioned <a>EncCBOR</a> instance to a plain <a>Encoding</a>
--   using Byron protocol version.
toByronCBOR :: EncCBOR a => a -> Encoding

-- | A range of values. Should satisfy the invariant <tt>forall x. lo x
--   &lt;= hi x</tt>.
data Range b
Range :: b -> b -> Range b
[lo] :: Range b -> b
[hi] :: Range b -> b

-- | Fully evaluate a size expression by applying the given function to any
--   suspended computations. <tt>szEval g</tt> effectively turns each
--   "thunk" of the form <tt>TodoF f x</tt> into <tt>g x</tt>, then
--   evaluates the result.
szEval :: (forall t. EncCBOR t => (Proxy t -> Size) -> Proxy t -> Range Natural) -> Size -> Range Natural

-- | Expressions describing the statically-computed size bounds on a type's
--   possible values.
type Size = Fix SizeF

-- | An individual labeled case.
data Case t
Case :: Text -> t -> Case t

-- | Discard the label on a case.
caseValue :: Case t -> t

-- | A type used to represent the length of a value in <a>Size</a>
--   computations.
newtype LengthOf xs
LengthOf :: xs -> LengthOf xs

-- | Override mechanisms to be used with <a>szWithCtx</a>.
data SizeOverride

-- | Replace with a fixed <tt>Size</tt>.
SizeConstant :: Size -> SizeOverride

-- | Recursively compute the size.
SizeExpression :: ((forall a. EncCBOR a => Proxy a -> Size) -> Size) -> SizeOverride

-- | Select only a specific case from a <tt>CasesF</tt>.
SelectCases :: [Text] -> SizeOverride

-- | Is this expression a thunk?
isTodo :: Size -> Bool

-- | Create a case expression from individual cases.
szCases :: [Case Size] -> Size

-- | Evaluate the expression lazily, by immediately creating a thunk that
--   will evaluate its contents lazily.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szLazy (Proxy @TxAux)
--   (_ :: TxAux)
--   </pre>
szLazy :: EncCBOR a => Proxy a -> Size

-- | Evaluate an expression greedily. There may still be thunks in the
--   result, for types that did not provide a custom <a>encodedSizeExpr</a>
--   method in their <a>EncCBOR</a> instance.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szGreedy (Proxy @TxAux)
--   (0 + { TxAux=(2 + ((0 + (((1 + (2 + ((_ :: LengthOf [TxIn]) * (2 + { TxInUtxo=(2 + ((1 + 34) + { minBound=1 maxBound=5 })) })))) + (2 + ((_ :: LengthOf [TxOut]) * (0 + { TxOut=(2 + ((0 + ((2 + ((2 + withWordSize((((1 + 30) + (_ :: Attributes AddrAttributes)) + 1))) + (((1 + 30) + (_ :: Attributes AddrAttributes)) + 1))) + { minBound=1 maxBound=5 })) + { minBound=1 maxBound=9 })) })))) + (_ :: Attributes ()))) + (_ :: Vector TxInWitness))) })
--   </pre>
szGreedy :: EncCBOR a => Proxy a -> Size

-- | Force any thunks in the given <tt>Size</tt> expression.
--   
--   <pre>
--   ghci&gt; putStrLn $ pretty $ szForce $ szLazy (Proxy @TxAux)
--   (0 + { TxAux=(2 + ((0 + (_ :: Tx)) + (_ :: Vector TxInWitness))) })
--   </pre>
szForce :: Size -> Size

-- | Greedily compute the size bounds for a type, using the given context
--   to override sizes for specific types.
szWithCtx :: EncCBOR a => Map TypeRep SizeOverride -> Proxy a -> Size

-- | Simplify the given <tt>Size</tt>, resulting in either the simplified
--   <tt>Size</tt> or, if it was fully simplified, an explicit upper and
--   lower bound.
szSimplify :: Size -> Either Size (Range Natural)

-- | Apply a monotonically increasing function to the expression. There are
--   three cases when applying <tt>f</tt> to a <tt>Size</tt> expression: *
--   When applied to a value <tt>x</tt>, compute <tt>f x</tt>. * When
--   applied to cases, apply to each case individually. * In all other
--   cases, create a deferred application of <tt>f</tt>.
apMono :: Text -> (Natural -> Natural) -> Size -> Size
szBounds :: EncCBOR a => a -> Either Size (Range Natural)

-- | <a>Size</a> expression for <a>VerKeyDSIGN</a> which is using
--   <a>sizeVerKeyDSIGN</a> encoded as <a>Size</a>.
encodedVerKeyDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (VerKeyDSIGN v) -> Size

-- | <a>Size</a> expression for <a>SignKeyDSIGN</a> which is using
--   <a>sizeSignKeyDSIGN</a> encoded as <a>Size</a>.
encodedSignKeyDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (SignKeyDSIGN v) -> Size

-- | <a>Size</a> expression for <a>SigDSIGN</a> which is using
--   <a>sizeSigDSIGN</a> encoded as <a>Size</a>.
encodedSigDSIGNSizeExpr :: forall v. DSIGNAlgorithm v => Proxy (SigDSIGN v) -> Size

-- | <a>Size</a> expression for <a>SignedDSIGN</a> which uses
--   <a>encodedSigDSIGNSizeExpr</a>
encodedSignedDSIGNSizeExpr :: forall v a. DSIGNAlgorithm v => Proxy (SignedDSIGN v a) -> Size

-- | <a>Size</a> expression for <a>VerKeyKES</a> which is using
--   <a>sizeVerKeyKES</a> encoded as <a>Size</a>.
encodedVerKeyKESSizeExpr :: forall v. KESAlgorithm v => Proxy (VerKeyKES v) -> Size

-- | <a>Size</a> expression for <a>SignKeyKES</a> which is using
--   <a>sizeSignKeyKES</a> encoded as <a>Size</a>.
encodedSignKeyKESSizeExpr :: forall v. KESAlgorithm v => Proxy (SignKeyKES v) -> Size

-- | <a>Size</a> expression for <a>SigKES</a> which is using
--   <a>sizeSigKES</a> encoded as <a>Size</a>.
encodedSigKESSizeExpr :: forall v. KESAlgorithm v => Proxy (SigKES v) -> Size

-- | <a>Size</a> expression for <a>VerKeyVRF</a> which is using
--   <a>sizeVerKeyVRF</a> encoded as <a>Size</a>.
encodedVerKeyVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (VerKeyVRF v) -> Size

-- | <a>Size</a> expression for <a>SignKeyVRF</a> which is using
--   <a>sizeSignKeyVRF</a> encoded as <a>Size</a>
encodedSignKeyVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (SignKeyVRF v) -> Size

-- | <a>Size</a> expression for <a>CertVRF</a> which is using
--   <a>sizeCertVRF</a> encoded as <a>Size</a>.
encodedCertVRFSizeExpr :: forall v. VRFAlgorithm v => Proxy (CertVRF v) -> Size

-- | Encode and serialise the given <tt>a</tt> and sorround it with the
--   semantic tag 24 In CBOR diagnostic notation: &gt;&gt;&gt;
--   24(h<tt>DEADBEEF</tt>)
encodeNestedCbor :: EncCBOR a => a -> Encoding

-- | Like <a>encodeNestedCbor</a>, but assumes nothing about the shape of
--   input object, so that it must be passed as a binary
--   <tt>ByteString</tt> blob. It's the caller responsibility to ensure the
--   input <tt>ByteString</tt> correspond indeed to valid,
--   previously-serialised CBOR data.
encodeNestedCborBytes :: ByteString -> Encoding
nestedCborSizeExpr :: Size -> Size
nestedCborBytesSizeExpr :: Size -> Size

-- | Run a ByteString <a>Builder</a> using a strategy aimed at making
--   smaller things efficiently.
--   
--   It takes a size hint and produces a strict <tt>ByteString</tt>. This
--   will be fast when the size hint is the same or slightly bigger than
--   the true size.
runByteBuilder :: Int -> Builder -> ByteString

-- | <i>Deprecated: In favor of <a>encodeMaybe</a></i>
encCBORMaybe :: (a -> Encoding) -> Maybe a -> Encoding


-- | <a>Cardano.Ledger.Binary.Coders</a> provides tools for writing
--   <tt>EncCBOR</tt> and <tt>DecCBOR</tt> instances (see module
--   <a>Binary</a>) in an intuitive way that mirrors the way one constructs
--   values of a particular type. Advantages include:
--   
--   <ol>
--   <li>Book-keeping details neccesary to write correct instances are
--   hidden from the user.</li>
--   <li>Inverse <tt>EncCBOR</tt> and <tt>DecCBOR</tt> instances have
--   visually similar definitions.</li>
--   <li>Advanced instances involving sparse-encoding,
--   compact-representation, and <tt>Annotator</tt> instances are also
--   supported.</li>
--   </ol>
--   
--   A Guide to Visual inspection of Duality in Encode and Decode
--   
--   <ol>
--   <li><tt>(Sum c)</tt> and <tt>(SumD c)</tt> are duals</li>
--   <li><tt>(Rec c)</tt> and <tt>(RecD c)</tt> are duals</li>
--   <li><tt>(Keyed c)</tt> and <tt>(KeyedD c)</tt> are duals</li>
--   <li><tt>(OmitC x)</tt> and <tt>(Emit x)</tt> are duals</li>
--   <li><tt>(Omit p ..)</tt> and <tt>(Emit x)</tt> are duals if (p x) is
--   True</li>
--   <li><tt>(To x)</tt> and <tt>(From)</tt> are duals if (x::T) and
--   (forall (y::T). isRight (roundTrip y))</li>
--   <li><tt>(E enc x)</tt> and <tt>(D dec)</tt> are duals if (forall x .
--   isRight (roundTrip' enc dec x))</li>
--   <li><tt>(f !&gt; x)</tt> and <tt>(g &lt;! y)</tt> are duals if (f and
--   g are duals) and (x and y are duals)</li>
--   </ol>
--   
--   Duality properties of <tt>(Summands name decodeT)</tt> and
--   <tt>(SparseKeyed name (init::T) pick required)</tt> also exist but are
--   harder to describe succinctly.
module Cardano.Ledger.Binary.Coders

-- | A first-order domain specific langage for describing EncCBOR
--   instances. Applying the interpreter <a>encode</a> to a well-typed
--   <tt>(Encode w T)</tt> always produces a valid encoding for <tt>T</tt>.
--   Constructing an Encode of type T is just like building a value of type
--   T, applying a constructor of <tt>T</tt> to the correctly typed
--   arguments. For example
--   
--   <pre>
--   data T = T Bool Word
--   
--   instance EncCBOR T where
--     encCBOR (T b w) = encode (Rec T !&gt; To b !&gt; To w)
--   </pre>
--   
--   Note the similarity of
--   
--   <tt>(<i>T</i> <i>b</i> <i>w</i>)</tt> and <tt>(<i>T</i> $ <i>b</i> $
--   <i>w</i>)</tt> and <tt>(Rec <i>T</i> !&gt; To <i>b</i> !&gt; To
--   <i>w</i>)</tt>
--   
--   Where (<a>!&gt;</a>) is the infx version of <a>ApplyE</a> with the
--   same infixity and precedence as (<a>$</a>). Note how the constructor
--   and each (component, field, argument) is labeled with one of the
--   constructors of <a>Encode</a>, and are combined with the application
--   operator (<a>!&gt;</a>). Using different constructors supports
--   different styles of encoding.
data Encode (w :: Wrapped) t

-- | Label the constructor of a Record-like datatype (one with exactly 1
--   constructor) as an Encode.
[Rec] :: t -> Encode ('Closed 'Dense) t

-- | Label one of the constructors of a sum datatype (one with multiple
--   constructors) as an Encode
[Sum] :: t -> Word -> Encode 'Open t

-- | Label the constructor of a Record-like datatype as being encoded
--   sparsely (storing only non-default values).
[Keyed] :: t -> Encode ('Closed 'Sparse) t

-- | Label an (component, field, argument) to be encoded using an existing
--   EncCBOR instance.
[To] :: EncCBOR a => a -> Encode ('Closed 'Dense) a

-- | Label an (component, field, argument) to be encoded using an existing
--   EncCBOR instance.
[E] :: (t -> Encoding) -> t -> Encode ('Closed 'Dense) t

-- | Lift one Encode to another with a different type. Used to make a
--   Functor instance of (Encode w).
[MapE] :: (a -> b) -> Encode w a -> Encode w b

-- | Skip over the (component,field, argument), don't encode it at all
--   (used in sparse encoding).
[OmitC] :: t -> Encode w t

-- | Precede the given encoding (in the produced bytes) with the given tag
--   Word.
[Tag] :: Word -> Encode ('Closed x) t -> Encode ('Closed x) t

-- | Omit the (component,field, argument) if the function is True,
--   otherwise encode with the given encoding.
[Omit] :: (t -> Bool) -> Encode ('Closed 'Sparse) t -> Encode ('Closed 'Sparse) t

-- | Precede the encoding (in the produced bytes) with the key Word.
--   Analagous to <a>Tag</a>, but lifts a <a>Dense</a> encoding to a
--   <a>Sparse</a> encoding.
[Key] :: Word -> Encode ('Closed 'Dense) t -> Encode ('Closed 'Sparse) t

-- | Apply a functional encoding (arising from <a>Rec</a> or <a>Sum</a>) to
--   get (type wise) smaller encoding. A fully saturated chain of
--   <a>ApplyE</a> will be a complete encoding. See also <a>!&gt;</a> which
--   is infix <a>ApplyE</a>.
[ApplyE] :: Encode w (a -> t) -> Encode ('Closed r) a -> Encode w t

-- | Infix operator version of <tt>ApplyE</tt>. Has the same infxity and
--   operator precedence as <a>$</a>
(!>) :: Encode w (a -> t) -> Encode ('Closed r) a -> Encode w t
infixl 4 !>

-- | Translate a first-order @(Encode w d) domain specific langage program,
--   into an <a>Encoding</a> .
encode :: Encode w t -> Encoding
runE :: Encode w t -> t

-- | Use <a>encodeDual</a> and <a>decodeDual</a>, when you want to
--   guarantee that a type has both <a>EncCBOR</a> and <tt>FromCBR</tt>
--   instances.
encodeDual :: forall t. (EncCBOR t, DecCBOR t) => t -> Encode ('Closed 'Dense) t
encodeKeyedStrictMaybeWith :: Word -> (a -> Encoding) -> StrictMaybe a -> Encode ('Closed 'Sparse) (StrictMaybe a)
encodeKeyedStrictMaybe :: EncCBOR a => Word -> StrictMaybe a -> Encode ('Closed 'Sparse) (StrictMaybe a)

-- | The type <tt>(<a>Decode</a> t)</tt> is designed to be dual to
--   <tt>(<tt>Encode</tt> t)</tt>. It was designed so that in many cases a
--   decoder can be extracted from an encoder by visual inspection. We now
--   give some example of <tt>(Decode t)</tt> and <tt>(Encode t)</tt>
--   pairs.
--   
--   An example with 1 constructor (a record) uses <tt>Rec</tt> and
--   <a>RecD</a>
--   
--   In this example, let <tt>Int</tt> and <tt>C</tt> have <a>EncCBOR</a>
--   instances.
--   
--   <pre>
--   data C = C { unC :: Text.Text }
--   instance EncCBOR C where
--     encCBOR (C t) = encCBOR t
--   instance DecCBOR C where
--     decCBOR = C <a>$</a> decCBOR
--   
--   data B = B { unB :: Text.Text }
--   
--   data A = ACon Int B C
--   
--   encodeA :: A -&gt; Encode ('Closed 'Dense) A
--   encodeA (ACon i b c) = Rec ACon !&gt; To i !&gt; E (encCBOR . unB) b !&gt; To c
--   
--   decodeA :: Decode ('Closed 'Dense) A
--   decodeA = RecD ACon <a>From &lt;! D (B &lt;$</a> decCBOR) &lt;! From
--   
--   instance EncCBOR A where
--     encCBOR = encode . encodeA
--   instance DecCBOR A where
--     decCBOR = decode decodeA
--   </pre>
--   
--   An example with multiple constructors uses <tt>Sum</tt>, <a>SumD</a>,
--   and <a>Summands</a>.
--   
--   <pre>
--   data N = N1 Int | N2 B Bool | N3 A
--   
--   encodeN :: N -&gt; Encode 'Open N
--   encodeN (N1 i)    = Sum N1 0 !&gt; To i
--   encodeN (N2 b tf) = Sum N2 1 !&gt; E (encCBOR . unB) b !&gt; To tf
--   encodeN (N3 a)    = Sum N3 2 !&gt; To a
--   
--   decodeN :: Decode ('Closed 'Dense) N    -- Note each clause has an 'Open decoder,
--   decodeN = Summands <a>N</a> decodeNx           -- But Summands returns a ('Closed 'Dense) decoder
--     where decodeNx 0 = SumD N1 &lt;! From
--           decodeNx 1 = SumD N2 <a>D (B &lt;$</a> decCBOR) &lt;! From
--           decodeNx 3 = SumD N3 &lt;! From
--           decodeNx k = Invalid k
--   
--   instance EncCBOR N   where encCBOR x = encode(encodeN x)
--   instance DecCBOR N where decCBOR = decode decodeN
--   </pre>
--   
--   Two examples using variants of sparse encoding for records, i.e. those
--   datatypes with only one constructor. The Virtual constructor approach
--   using <a>Summands</a>, <tt>OmitC</tt>, <a>Emit</a>. The Sparse field
--   approach using <tt>Keyed</tt>, <tt>Key</tt> and <tt>Omit</tt>. The
--   approaches work because encoders and decoders don't put fields with
--   default values in the Encoding, and reconstruct the default values on
--   the decoding side. We will illustrate the two approaches using the
--   datatype M
--   
--   <pre>
--   data M = M Int [Bool] Text.Text
--     deriving (Show, Typeable)
--   
--   a0, a1, a2, a3 :: M  -- Some illustrative examples, using things that might be given default values.
--   a0 = M 0 [] <a>ABC</a>
--   a1 = M 0 [True] <a>ABC</a>
--   a2 = M 9 [] <a>ABC</a>
--   a3 = M 9 [False] <a>ABC</a>
--   </pre>
--   
--   The virtual constructor strategy pretends there are mutiple
--   constructors Even though there is only one. We use invariants about
--   the data to avoid encoding some of the values. Note the use of
--   <tt>Sum</tt> with virtual constructor tags 0,1,2,3
--   
--   <pre>
--   encM :: M -&gt; Encode 'Open M
--   encM (M 0 [] t) = Sum M 0 !&gt; OmitC 0 !&gt; OmitC [] !&gt; To t
--   encM (M 0 bs t) = Sum M 1 !&gt; OmitC 0 !&gt; To bs !&gt; To t
--   encM (M n [] t) = Sum M 2 !&gt; To n !&gt; OmitC [] !&gt; To t
--   encM (M n bs t) = Sum M 3 !&gt; To n !&gt; To bs !&gt; To t
--   
--   decM :: Word -&gt; Decode 'Open M
--   decM 0 = SumD M &lt;! Emit 0 &lt;! Emit [] &lt;! From  -- The virtual constructors tell which fields have been Omited
--   decM 1 = SumD M &lt;! Emit 0 &lt;! From &lt;! From     -- So those fields are reconstructed using <a>Emit</a>.
--   decM 2 = SumD M &lt;! From &lt;! Emit [] &lt;! From
--   decM 3 = SumD M &lt;! From &lt;! From &lt;! From
--   decM n = Invalid n
--   
--   instance EncCBOR M where
--     encCBOR m = encode (encM m)
--   
--   instance DecCBOR M where
--     decCBOR = decode (Summands <a>M</a> decM)
--   </pre>
--   
--   The Sparse field approach uses N keys, one for each field that is not
--   defaulted. For example <tt>(M 9 [True] (pack "hi")))</tt>. Here zero
--   fields are defaulted, so there should be 3 keys. Encoding this example
--   would look something like this.
--   
--   <pre>
--   [TkMapLen 3,TkInt 0,TkInt 9,TkInt 1,TkListBegin,TkBool True,TkBreak,TkInt 2,TkString "hi"]
--                     ^key            ^key                                    ^key
--   </pre>
--   
--   So the user supplies a function, that encodes every field, each field
--   must use a unique key, and fields with default values have Omit
--   wrapped around the Key encoding. The user must ensure that there is
--   NOT an Omit on a required field. <tt>encM2</tt> is an example.
--   
--   <pre>
--   encM2:: M -&gt; Encode ('Closed 'Sparse) M
--   encM2 (M n xs t) =
--       Keyed M
--          !&gt; Omit (== 0) (Key 0 (To n))    -- Omit if n is zero
--          !&gt; Omit null (Key 1 (To xs))     -- Omit if xs is null
--          !&gt; Key 2 (To t)                  -- Always encode t
--   </pre>
--   
--   To write an Decoder we must pair a decoder for each field, with a
--   function that updates only that field. We use the <a>Field</a> GADT to
--   construct these pairs, and we must write a function, that for each
--   field tag, picks out the correct pair. If the Encode and Decode don't
--   agree on how the tags correspond to a particular field, things will
--   fail.
--   
--   <pre>
--   boxM :: Word -&gt; Field M
--   boxM 0 = field update0 From
--     where
--       update0 n (M _ xs t) = M n xs t
--   boxM 1 = field update1 From
--     where
--       update1 xs (M n _ t) = M n xs t
--   boxM 2 = field update2 From
--     where
--       update2 t (M n xs _) = M n xs t
--   boxM n = invalidField n
--   </pre>
--   
--   Finally there is a new constructor for <a>Decode</a>, called
--   <a>SparseKeyed</a>, that decodes field keyed sparse objects. The user
--   supplies an initial value and field function, and a list of tags of
--   the required fields. The initial value should have default values and
--   any well type value in required fields. If the encode function (baz
--   above) is encoded properly the required fields in the initial value
--   should always be over overwritten. If it is not written properly, or a
--   bad encoding comes from somewhere else, the intial values in the
--   required fields might survive decoding. The list of required fields is
--   checked.
--   
--   <pre>
--   instance DecCBOR M where
--     decCBOR = decode (SparseKeyed
--                         <a>TT</a>                        -- ^ Name of the type being decoded
--                         (M 0 [] (Text.pack "a"))  -- ^ The default value
--                         boxM                      -- ^ The Field function
--                         [(2, <a>Stringpart</a>)]         -- ^ The required Fields
--                       )
--   
--   instance EncCBOR M where
--     encCBOR m = encode(encM2 m)
--   </pre>
data Decode (w :: Wrapped) t

-- | Label the constructor of a Record-like datatype (one with exactly 1
--   constructor) as a Decode.
[RecD] :: t -> Decode ('Closed 'Dense) t

-- | Label the constructor of a Record-like datatype (one with multiple
--   constructors) as an Decode.
[SumD] :: t -> Decode 'Open t

-- | Lift a Word to Decode function into a DeCode for a type with multiple
--   constructors.
[Summands] :: Text -> (Word -> Decode 'Open t) -> Decode ('Closed 'Dense) t

-- | Lift a Word to Field function into a DeCode for a type with 1
--   constructor stored sparsely
[SparseKeyed] :: Typeable t => String -> t -> (Word -> Field t) -> [(Word, String)] -> Decode ('Closed 'Dense) t

-- | Label a (component, field, argument) as sparsely stored, which will be
--   populated with the default value.
[KeyedD] :: t -> Decode ('Closed 'Sparse) t

-- | Label a (component, field, argument). It will be decoded using the
--   existing DecCBOR instance at <tt>t</tt>
[From] :: DecCBOR t => Decode w t

-- | Label a (component, field, argument). It will be decoded using the
--   given decoder.
[D] :: (forall s. Decoder s t) -> Decode ('Closed 'Dense) t

-- | Apply a functional decoding (arising from <a>RecD</a> or <a>SumD</a>)
--   to get (type wise) smaller decoding.
[ApplyD] :: Decode w1 (a -> t) -> Decode ('Closed d) a -> Decode w1 t

-- | Mark a Word as a Decoding which is not a valid Decoding. Used when
--   decoding sums that are tagged out of range.
[Invalid] :: Word -> Decode w t

-- | Used to make (Decode w) an instance of Functor.
[Map] :: (a -> b) -> Decode w a -> Decode w b

-- | Assert that the next thing decoded must be tagged with the given word.
[TagD] :: Word -> Decode ('Closed x) t -> Decode ('Closed x) t

-- | Decode the next thing, not by inspecting the bytes, but pulled out of
--   thin air, returning <tt>t</tt>. Used in sparse decoding.
[Emit] :: t -> Decode w t

-- | Lift a <tt>(Decode w t)</tt> to a <tt>(Decode w (Annotator t))</tt>.
--   Used on a (component, field, argument) that was not Annotator encoded,
--   but contained in Record or Sum which is Annotator encoded.
[Ann] :: Decode w t -> Decode w (Annotator t)

-- | Apply a functional decoding (arising from <a>RecD</a> or <a>SumD</a>
--   that needs to be Annotator decoded) to get (type wise) smaller
--   decoding.
[ApplyAnn] :: Decode w1 (Annotator (a -> t)) -> Decode ('Closed d) (Annotator a) -> Decode w1 (Annotator t)

-- | the function to Either can raise an error when applied by returning
--   (Left errorMessage)
[ApplyErr] :: Decode w1 (a -> Either String t) -> Decode ('Closed d) a -> Decode w1 t

-- | Infix form of <tt>ApplyD</tt> with the same infixity and precedence as
--   <tt>($)</tt>.
(<!) :: Decode w1 (a -> t) -> Decode ('Closed w) a -> Decode w1 t
infixl 4 <!

-- | Infix form of <tt>ApplyAnn</tt> with the same infixity and precedence
--   as <tt>($)</tt>.
(<*!) :: Decode w1 (Annotator (a -> t)) -> Decode ('Closed d) (Annotator a) -> Decode w1 (Annotator t)
infixl 4 <*!

-- | Infix form of <tt>ApplyErr</tt> with the same infixity and precedence
--   as <tt>($)</tt>.
(<?) :: Decode w1 (a -> Either String t) -> Decode ('Closed d) a -> Decode w1 t
infixl 4 <?
decode :: Decode w t -> Decoder s t
decodeSparse :: Typeable a => String -> a -> (Word -> Field a) -> [(Word, String)] -> Decoder s a

-- | Index for record density. Distinguishing (all the fields) from (some
--   of the fields).
data Density
Dense :: Density
Sparse :: Density

-- | Index for a wrapped Coder. Wrapping is necessary for <a>Summands</a>
--   and <a>SparseKeyed</a>.
data Wrapped
[Open] :: Wrapped
[Closed] :: Density -> Wrapped

-- | A Field pairs an update function and a decoder for one field of a
--   Sparse record.
data Field t
[Field] :: (x -> t -> t) -> (forall s. Decoder s x) -> Field t
ofield :: (StrictMaybe x -> t -> t) -> Decode ('Closed d) x -> Field t
invalidField :: forall t. Word -> Field t
field :: (x -> t -> t) -> Decode ('Closed d) x -> Field t
fieldGuarded :: String -> (x -> Bool) -> (x -> t -> t) -> Decode ('Closed d) x -> Field t

-- | Sparse decode something with a (DecCBOR (Annotator t)) instance A
--   special case of <a>field</a>
fieldA :: Applicative ann => (x -> t -> t) -> Decode ('Closed d) x -> Field (ann t)

-- | Sparse decode something with a (DecCBOR (Annotator t)) instance
fieldAA :: Applicative ann => (x -> t -> t) -> Decode ('Closed d) (ann x) -> Field (ann t)

-- | Use <a>encodeDual</a> and <a>decodeDual</a>, when you want to
--   guarantee that a type has both <a>EncCBOR</a> and <tt>FromCBR</tt>
--   instances.
decodeDual :: forall t. (EncCBOR t, DecCBOR t) => Decode ('Closed 'Dense) t
listDecodeA :: Decode ('Closed 'Dense) (Annotator x) -> Decode ('Closed 'Dense) (Annotator [x])
mapDecodeA :: Ord k => Decode ('Closed 'Dense) (Annotator k) -> Decode ('Closed 'Dense) (Annotator v) -> Decode ('Closed 'Dense) (Annotator (Map k v))
setDecodeA :: Ord x => Decode ('Closed 'Dense) (Annotator x) -> Decode ('Closed 'Dense) (Annotator (Set x))
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: Text -> (Word -> Decoder s (Int, a)) -> Decoder s a

-- | Report an error when a numeric key of the type constructor doesn't
--   match.
invalidKey :: MonadFail m => Word -> m a
unusedRequiredKeys :: Set Word -> [(Word, String)] -> String -> Decoder s a
duplicateKey :: String -> Word -> Decoder s a

-- | Prevent decoding until the <a>Version</a> is at least the provided
--   version.
guardUntilAtLeast :: DecCBOR a => String -> Version -> Decode ('Closed 'Dense) a

module Cardano.Ledger.Binary.Decoding

-- | Deserialize a Haskell value from a binary CBOR representation, failing
--   if there are leftovers. In other words, the <b>Full</b> here implies
--   the contract on this function that the input must be consumed in its
--   entirety by the decoder specified in <a>DecCBOR</a>.
decodeFull :: forall a. DecCBOR a => Version -> ByteString -> Either DecoderError a

-- | Same as <a>decodeFull</a>, except accepts a strict <a>ByteString</a>
--   as input instead of the lazy one.
decodeFull' :: forall a. DecCBOR a => Version -> ByteString -> Either DecoderError a

-- | Same as <a>decodeFull</a>, except instead of relying on the
--   <a>DecCBOR</a> instance the <a>Decoder</a> must be suplied manually.
decodeFullDecoder :: Version -> Text -> (forall s. Decoder s a) -> ByteString -> Either DecoderError a

-- | Same as <a>decodeFullDecoder</a>, except works on strict
--   <a>ByteString</a>
decodeFullDecoder' :: Version -> Text -> (forall s. Decoder s a) -> ByteString -> Either DecoderError a

-- | Same as <a>decodeFullDecoder</a>, except it provdes the means of
--   passing portion or all of the <a>ByteString</a> input argument to the
--   decoding <a>Annotator</a>.
decodeFullAnnotator :: Version -> Text -> (forall s. Decoder s (Annotator a)) -> ByteString -> Either DecoderError a

-- | Same as <a>decodeFullDecoder</a>, decodes a Haskell value from a lazy
--   <a>ByteString</a>, requiring that the full ByteString is consumed, and
--   replaces <a>ByteSpan</a> annotations with the corresponding slice of
--   the input as a strict <a>ByteString</a>.
decodeFullAnnotatedBytes :: Functor f => Version -> Text -> (forall s. Decoder s (f ByteSpan)) -> ByteString -> Either DecoderError (f ByteString)
class Typeable a => DecCBOR a
decCBOR :: DecCBOR a => Decoder s a
decCBOR :: (DecCBOR a, FromCBOR a) => Decoder s a

-- | Validate decoding of a Haskell value, without the need to actually
--   construct it. Coule be slightly faster than <a>decCBOR</a>, however it
--   should respect this law:
--   
--   <pre>
--   dropCBOR (proxy :: Proxy a) = () &lt;$ (decCBOR :: Decoder s a)
--   </pre>
dropCBOR :: DecCBOR a => Proxy a -> Decoder s ()
label :: DecCBOR a => Proxy a -> Text

-- | Convert a versioned <a>DecCBOR</a> instance to a plain <a>Decoder</a>
--   using Byron protocol version.
fromByronCBOR :: DecCBOR a => Decoder s a
class Monoid (Share a) => DecShareCBOR a where {
    type Share a :: Type;
    type Share a = ();
}

-- | Whenever <tt>fromShareCBOR</tt> is being used for defining the
--   instance this function should return the state that can be added
--   whenever user invokes <a>decSharePlusCBOR</a>. <a>mempty</a> is
--   returned by default.
getShare :: DecShareCBOR a => a -> Share a

-- | Utilize sharing when decoding, but do not add anything to the state
--   for future sharing.
decShareCBOR :: DecShareCBOR a => Share a -> Decoder s a

-- | Deserialize with sharing and add to the state that is used for
--   sharing. Default implementation will add value returned by
--   <a>getShare</a> for adding to the state.
decSharePlusCBOR :: DecShareCBOR a => StateT (Share a) (Decoder s) a
newtype Interns a
Interns :: [Intern a] -> Interns a

-- | This is an abstract interface that does the interning. In other words
--   it does the actual sharing by looking up the supplied value in some
--   existing data structure and uses that value instead. Relying on this
--   interface gives us the benefit of ignoring the type of underlying data
--   structure and allows us to compose many <a>Intern</a>s with the
--   monoidal interface provided by <a>Interns</a> wrapper. In order to
--   create an <a>Intern</a> see the <a>internsFromMap</a> or
--   <a>internsFromVMap</a> functions.
data Intern a
Intern :: (a -> Maybe a) -> !Int -> Intern a

-- | Function that will do the interning. If value is not available then
--   <a>Nothing</a> is returned.
[internMaybe] :: Intern a -> a -> Maybe a

-- | Used for sorting. Normally set to the size of the underlying data
--   structure. Keeping interns sorted with respect to how many elements is
--   in the underlying data structure in theory gives a better chance of
--   successful intern hit sooner rather than later.
[internWeight] :: Intern a -> !Int
decShareLensCBOR :: DecShareCBOR b => SimpleGetter bs (Share b) -> StateT bs (Decoder s) b

-- | Just like <a>decSharePlusCBOR</a>, except allows to transform the
--   shared state with a lens.
decSharePlusLensCBOR :: DecShareCBOR b => Lens' bs (Share b) -> StateT bs (Decoder s) b

-- | Use <a>DecShareCBOR</a> class while ignoring sharing
decNoShareCBOR :: DecShareCBOR a => Decoder s a
interns :: Interns k -> k -> k
internsFromMap :: Ord k => Map k a -> Interns k
internsFromVMap :: Ord k => VMap VB kv k a -> Interns k

-- | Using this function it is possible to compose two lenses. One will
--   extract a value and another will used it for placing it into a empty
--   monoid. Here is an example of how a second element of a tuple can be
--   projected on the third element of a 3-tuple.
--   
--   <pre>
--   toMemptyLens _3 _2 == lens (\(_, b) -&gt; (mempty, mempty, b)) (\(a, _) (_, _, b) -&gt; (a, b))
--   </pre>
--   
--   Here is an example where we extract a second element of a tuple and
--   insert it at third position of a three tuple while all other elements
--   are set to <a>mempty</a>:
--   
--   <pre>
--   &gt;&gt;&gt; import Lens.Micro
--   
--   &gt;&gt;&gt; ("foo","bar") ^. toMemptyLens _3 _2 :: (Maybe String, (), String)
--   (Nothing,(),"bar")
--   </pre>
--   
--   In the opposite direction of extracting the third element of a 3-tuple
--   and replacing the second element of the tuple the setter is being
--   applied to
--   
--   <pre>
--   &gt;&gt;&gt; ("foo","bar") &amp; toMemptyLens _3 _2 .~ (Just "baz", (), "booyah") :: (String, String)
--   ("foo","booyah")
--   </pre>
toMemptyLens :: Monoid a => Lens' a b -> Lens' c b -> Lens' c a

-- | Share every item in a functor, have deserializing it
decShareMonadCBOR :: (DecCBOR (f b), Monad f) => Interns b -> Decoder s (f b)
data Decoder s a

-- | Extract the underlying <a>Decoder</a> by specifying the concrete
--   version to be used.
toPlainDecoder :: Version -> Decoder s a -> Decoder s a

-- | Promote a regular <a>Decoder</a> to a versioned one. Which means it
--   will work for all versions.
fromPlainDecoder :: Decoder s a -> Decoder s a

-- | Use the supplied decoder as a plain decoder with current version.
withPlainDecoder :: Decoder s a -> (Decoder s a -> Decoder s b) -> Decoder s b

-- | Ignore the current version of the decoder and enforce the supplied one
--   instead.
enforceDecoderVersion :: Version -> Decoder s a -> Decoder s a
data () => DecoderError
DecoderErrorCanonicityViolation :: Text -> DecoderError
DecoderErrorCustom :: Text -> Text -> DecoderError
DecoderErrorDeserialiseFailure :: Text -> DeserialiseFailure -> DecoderError
DecoderErrorEmptyList :: Text -> DecoderError
DecoderErrorLeftover :: Text -> ByteString -> DecoderError
DecoderErrorSizeMismatch :: Text -> Int -> Int -> DecoderError
DecoderErrorUnknownTag :: Text -> Word8 -> DecoderError
DecoderErrorVoid :: DecoderError
type ByteOffset = Int64
data () => DecodeAction s a
ConsumeWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32 :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWord :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32 :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLen :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTag :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInteger :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDouble :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytes :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeString :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArray :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBool :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimple :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeStringIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeMapLenIndef :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeNull :: ST s (DecodeAction s a) -> DecodeAction s a
ConsumeListLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenOrIndef :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBreakOr :: (Bool -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekTokenType :: (TokenType -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekAvailable :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
PeekByteOffset :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord8Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord16Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeWord32Canonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeNegWordCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt8Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt16Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeInt32Canonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeListLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeMapLenCanonical :: (Int# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeTagCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeIntegerCanonical :: (Integer -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloat16Canonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeFloatCanonical :: (Float# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeDoubleCanonical :: (Double# -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeBytesCanonical :: (ByteString -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeStringCanonical :: (Text -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeUtf8ByteArrayCanonical :: (ByteArray -> ST s (DecodeAction s a)) -> DecodeAction s a
ConsumeSimpleCanonical :: (Word# -> ST s (DecodeAction s a)) -> DecodeAction s a
Fail :: String -> DecodeAction s a
Done :: a -> DecodeAction s a
data () => TokenType
TypeUInt :: TokenType
TypeUInt64 :: TokenType
TypeNInt :: TokenType
TypeNInt64 :: TokenType
TypeInteger :: TokenType
TypeFloat16 :: TokenType
TypeFloat32 :: TokenType
TypeFloat64 :: TokenType
TypeBytes :: TokenType
TypeBytesIndef :: TokenType
TypeString :: TokenType
TypeStringIndef :: TokenType
TypeListLen :: TokenType
TypeListLen64 :: TokenType
TypeListLenIndef :: TokenType
TypeMapLen :: TokenType
TypeMapLen64 :: TokenType
TypeMapLenIndef :: TokenType
TypeTag :: TokenType
TypeTag64 :: TokenType
TypeBool :: TokenType
TypeNull :: TokenType
TypeSimple :: TokenType
TypeBreak :: TokenType
TypeInvalid :: TokenType

-- | Extract current version of the decoder
--   
--   <pre>
--   &gt;&gt;&gt; import Cardano.Ledger.Decoding
--   
--   &gt;&gt;&gt; decodeFullDecoder 3 "Version" getDecoderVersion ""
--   Right 3
--   </pre>
getDecoderVersion :: Decoder s Version

-- | Conditionally choose the newer or older decoder, depending on the
--   current version. Version in the context of encoders/decoders is the
--   major protocol version. Supplied version acts as a pivot.
--   
--   <h5><b>Example</b></h5>
--   
--   Let's say prior to the version 2 some type <tt>Foo</tt> was backed by
--   <a>Word16</a>, but at the 2nd version onwards it was switched to
--   <a>Word32</a> instead. In order to support both versions, we change
--   the type, but we also use this condition to keep backwards
--   compatibility of the decoder:
--   
--   <pre>
--   &gt;&gt;&gt; newtype Foo = Foo Word32
--   
--   &gt;&gt;&gt; decFoo = Foo &lt;$&gt; ifDecoderVersionAtLeast 2 decodeWord32 (fromIntegral &lt;$&gt; decodeWord16)
--   </pre>
ifDecoderVersionAtLeast :: Version -> Decoder s a -> Decoder s a -> Decoder s a

-- | Optionally run a decoder depending on the current version and the
--   supplied one.
whenDecoderVersionAtLeast :: Version -> Decoder s a -> Decoder s ()

-- | Optionally run a decoder depending on the current version and the
--   supplied one.
unlessDecoderVersionAtLeast :: Version -> Decoder s a -> Decoder s ()
cborError :: (MonadFail m, Buildable e) => e -> m a
toCborError :: (MonadFail m, Buildable e) => Either e a -> m a
showDecoderError :: Buildable e => e -> String

-- | Report an error when a numeric key of the type constructor doesn't
--   match.
invalidKey :: MonadFail m => Word -> m a
assertTag :: Word -> Decoder s ()

-- | Enforces that the input size is the same as the decoded one, failing
--   in case it's not
enforceSize :: Text -> Int -> Decoder s ()

-- | Compare two sizes, failing if they are not equal
matchSize :: Text -> Int -> Int -> Decoder s ()

-- | Convert a <a>Get</a> monad from <tt>binary</tt> package into a
--   <a>Decoder</a>
binaryGetDecoder :: Bool -> Text -> Get a -> Decoder s a
allowTag :: Word -> Decoder s ()
decodeVersion :: Decoder s Version

-- | <a>Decoder</a> for <a>Rational</a>. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 9] - Allows variable as well as exact list length encoding.
--   Consumes tag 30 if one is present, but does not enforce it.</li>
--   <li>[&gt;= 2] - Allows variable as well as exact list length
--   encoding.</li>
--   <li>[== 1] - Expects exact list length encoding.</li>
--   </ul>
decodeRational :: Decoder s Rational

-- | Enforces tag 30 to indicate a rational number, as per tag assignment:
--   <a>https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml</a>
--   
--   <a>https://peteroupc.github.io/CBOR/rational.html</a>
decodeRationalWithTag :: Decoder s Rational
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: Text -> (Word -> Decoder s (Int, a)) -> Decoder s a

-- | Use this decoder for any list like structure that accepts fixed or
--   variable list length encoding.
decodeListLike :: Text -> Decoder s a -> (a -> Int -> Decoder s ()) -> Decoder s a
decodeListLikeT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> m (Decoder s) a -> (a -> Int -> m (Decoder s) ()) -> m (Decoder s) a
decodeEnumBounded :: forall a s. (Enum a, Bounded a, Typeable a) => Decoder s a
decodeWithOrigin :: Decoder s a -> Decoder s (WithOrigin a)

-- | <a>Decoder</a> for <a>Maybe</a>. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 2] - Allows variable as well as exact list length
--   encoding.</li>
--   <li>[&lt; 2] - Expects exact list length encoding</li>
--   </ul>
decodeMaybe :: Decoder s a -> Decoder s (Maybe a)

-- | Alternative way to decode a Maybe type.
--   
--   <i>Note</i> - this is not the default method for decoding
--   <a>Maybe</a>, use <a>decodeMaybe</a> instead.
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)

-- | Unlike <a>decodeMaybe</a> this allows variable as well as exact list
--   length encoding for all versions, because Byron never used
--   <a>StrictMaybe</a> type.
decodeStrictMaybe :: Decoder s a -> Decoder s (StrictMaybe a)

-- | Alternative way to decode a <a>StrictMaybe</a> type.
--   
--   <i>Note</i> - this is not the default method for decoding
--   <a>StrictMaybe</a>, use <a>decodeStrictMaybe</a> instead.
decodeNullStrictMaybe :: Decoder s a -> Decoder s (StrictMaybe a)
decodeEither :: Decoder s a -> Decoder s b -> Decoder s (Either a b)

-- | <tt><a>Decoder</a></tt> for list.
--   
--   <ul>
--   <li>[&gt;= 2] - Allows variable as well as exact list length
--   encoding.</li>
--   <li>[&lt; 2] - Expects variable list length encoding</li>
--   </ul>
decodeList :: Decoder s a -> Decoder s [a]
decodeNonEmptyList :: Decoder s a -> Decoder s (NonEmpty a)

-- | Generic decoder for vectors. Its intended use is to allow easy
--   definition of <tt>Serialise</tt> instances for custom vector
decodeVector :: Vector vec a => Decoder s a -> Decoder s (vec a)

-- | <a>Decoder</a> for <a>Set</a>. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 9] - Allows variable as well as exact list length encoding.
--   Duplicates are not allowed. Set tag 258 is permitted, but not
--   enforced.</li>
--   <li>[&gt;= 2, &lt; 9] - Allows variable as well as exact list length
--   encoding. Duplicates are silently ignored, set tag 258 is not
--   permitted.</li>
--   <li>[&lt; 2] - Expects exact list length encoding and enforces strict
--   order without any duplicates. Also enforces special set tag 258, which
--   was abandoned starting with version 2</li>
--   </ul>
decodeSet :: Ord a => Decoder s a -> Decoder s (Set a)

-- | We stitch a `258` in from of a (Hash)Set, so that tools which
--   programmatically check for canonicity can recognise it from a normal
--   array. Why 258? This will be formalised pretty soon, but IANA
--   allocated 256...18446744073709551615 to "First come, first served":
--   <a>https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml</a>
--   Currently `258` is the first unassigned tag and as it requires 2 bytes
--   to be encoded, it sounds like the best fit.
--   
--   
--   <a>https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md</a>
setTag :: Word

-- | <a>Decoder</a> for <a>Map</a>. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 9] - Allows variable as well as exact list length encoding.
--   Duplicate keys will result in a deserialization failure</li>
--   <li>[&gt;= 2] - Allows variable as well as exact list length encoding.
--   Duplicate keys are silently ignored</li>
--   <li>[&lt; 2] - Expects exact list length encoding and enforces strict
--   order without any duplicates.</li>
--   </ul>
--   
--   An example of how to use versioning
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import Codec.CBOR.FlatTerm
--   
--   &gt;&gt;&gt; fromFlatTerm (toPlainDecoder 1 (decodeMap decodeInt decodeBytes)) [TkMapLen 2,TkInt 1,TkBytes "Foo",TkInt 2,TkBytes "Bar"]
--   Right (fromList [(1,"Foo"),(2,"Bar")])
--   
--   &gt;&gt;&gt; fromFlatTerm (toPlainDecoder 1 (decodeMap decodeInt decodeBytes)) [TkMapBegin,TkInt 1,TkBytes "Foo",TkInt 2,TkBytes "Bar"]
--   Left "decodeMapLen: unexpected token TkMapBegin"
--   
--   &gt;&gt;&gt; fromFlatTerm (toPlainDecoder 2 (decodeMap decodeInt decodeBytes)) [TkMapBegin,TkInt 1,TkBytes "Foo",TkInt 2,TkBytes "Bar",TkBreak]
--   Right (fromList [(1,"Foo"),(2,"Bar")])
--   </pre>
decodeMap :: Ord k => Decoder s k -> Decoder s v -> Decoder s (Map k v)

-- | Just like <a>decodeMap</a>, but also gives access to the key for the
--   value decoder.
decodeMapByKey :: Ord k => Decoder s k -> (k -> Decoder s v) -> Decoder s (Map k v)

-- | Similar to <a>decodeMapByKey</a>, except it gives access to the key
--   value decoder as a pair and allows for different type of length
--   encoding
decodeMapLikeEnforceNoDuplicates :: Ord k => Decoder s (Maybe Int) -> Decoder s (k, v) -> Decoder s (Map k v)

-- | Decode <tt>VMap</tt>. Unlike <a>decodeMap</a> it does not behavee
--   differently for version prior to 2.
decodeVMap :: (Vector kv k, Vector vv v, Ord k) => Decoder s k -> Decoder s v -> Decoder s (VMap kv vv k v)

-- | Decoder for <a>Seq</a>. Same behavior for all versions, allows
--   variable as well as exact list length encoding
decodeSeq :: Decoder s a -> Decoder s (Seq a)

-- | Decoder for <a>StrictSeq</a>. Same behavior for all versions, allows
--   variable as well as exact list length encoding.
decodeStrictSeq :: Decoder s a -> Decoder s (StrictSeq a)
decodeSetTag :: Decoder s ()

-- | Decode a collection of values with ability to supply length decoder.
--   Number of decoded elements will be returned together with the data
--   structure
decodeListLikeWithCount :: forall s a b. Monoid b => Decoder s (Maybe Int) -> (a -> b -> b) -> (b -> Decoder s a) -> Decoder s (Int, b)

-- | Decode a Set as a either a definite or indefinite list. Duplicates are
--   not allowed. Set tag 258 is permitted, but not enforced.
decodeSetLikeEnforceNoDuplicates :: forall s a b c. Monoid b => (a -> b -> b) -> (b -> (Int, c)) -> Decoder s a -> Decoder s c

-- | Decode a collection of values with ability to supply length decoder.
--   Duplicates are not allowed.
decodeListLikeEnforceNoDuplicates :: forall s a b c. Monoid b => Decoder s (Maybe Int) -> (a -> b -> b) -> (b -> (Int, c)) -> Decoder s a -> Decoder s c
decodeMapContents :: Decoder s a -> Decoder s [a]
decodeMapTraverse :: (Ord a, Applicative t) => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t (Map a b))
decodeMapContentsTraverse :: Applicative t => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t [(a, b)])

-- | <a>Decoder</a> for <a>UTCTime</a>. Versions variance:
--   
--   <ul>
--   <li>[&gt;= 2] - Allows variable list length encoding, but still
--   expects number of elements to be 3.</li>
--   <li>[&lt; 2] - Expects exact list length encoding to be 3</li>
--   </ul>
decodeUTCTime :: Decoder s UTCTime
decodeIPv4 :: Decoder s IPv4
decodeIPv6 :: Decoder s IPv6
decodeBool :: Decoder s Bool
decodeBreakOr :: Decoder s Bool
decodeByteArray :: Decoder s ByteArray
decodeByteArrayCanonical :: Decoder s ByteArray
decodeBytes :: Decoder s ByteString
decodeBytesCanonical :: Decoder s ByteString
decodeBytesIndef :: Decoder s ()
decodeDouble :: Decoder s Double
decodeDoubleCanonical :: Decoder s Double
decodeFloat :: Decoder s Float
decodeFloat16Canonical :: Decoder s Float
decodeFloatCanonical :: Decoder s Float
decodeInt :: Decoder s Int
decodeInt16 :: Decoder s Int16
decodeInt16Canonical :: Decoder s Int16
decodeInt32 :: Decoder s Int32
decodeInt32Canonical :: Decoder s Int32
decodeInt64 :: Decoder s Int64
decodeInt64Canonical :: Decoder s Int64
decodeInt8 :: Decoder s Int8
decodeInt8Canonical :: Decoder s Int8
decodeIntCanonical :: Decoder s Int
decodeInteger :: Decoder s Integer
decodeIntegerCanonical :: Decoder s Integer
decodeNatural :: Decoder s Natural
decodeListLen :: Decoder s Int
decodeListLenCanonical :: Decoder s Int
decodeListLenCanonicalOf :: Int -> Decoder s ()
decodeListLenIndef :: Decoder s ()
decodeListLenOf :: Int -> Decoder s ()
decodeListLenOrIndef :: Decoder s (Maybe Int)
decodeMapLen :: Decoder s Int
decodeMapLenCanonical :: Decoder s Int
decodeMapLenIndef :: Decoder s ()
decodeMapLenOrIndef :: Decoder s (Maybe Int)
decodeNegWord :: Decoder s Word
decodeNegWord64 :: Decoder s Word64
decodeNegWord64Canonical :: Decoder s Word64
decodeNegWordCanonical :: Decoder s Word
decodeNull :: Decoder s ()
decodeSequenceLenIndef :: (r -> a -> r) -> r -> (r -> b) -> Decoder s a -> Decoder s b
decodeSequenceLenN :: (r -> a -> r) -> r -> (r -> b) -> Int -> Decoder s a -> Decoder s b
decodeSimple :: Decoder s Word8
decodeSimpleCanonical :: Decoder s Word8
decodeString :: Decoder s Text
decodeStringCanonical :: Decoder s Text
decodeStringIndef :: Decoder s ()
decodeTag :: Decoder s Word
decodeTag64 :: Decoder s Word64
decodeTag64Canonical :: Decoder s Word64
decodeTagCanonical :: Decoder s Word
decodeUtf8ByteArray :: Decoder s ByteArray
decodeUtf8ByteArrayCanonical :: Decoder s ByteArray
decodeWithByteSpan :: Decoder s a -> Decoder s (a, ByteOffset, ByteOffset)
decodeWord :: Decoder s Word
decodeWord16 :: Decoder s Word16
decodeWord16Canonical :: Decoder s Word16
decodeWord32 :: Decoder s Word32
decodeWord32Canonical :: Decoder s Word32
decodeWord64 :: Decoder s Word64
decodeWord64Canonical :: Decoder s Word64
decodeWord8 :: Decoder s Word8
decodeWord8Canonical :: Decoder s Word8
decodeWordCanonical :: Decoder s Word
decodeWordCanonicalOf :: Word -> Decoder s ()
decodeWordOf :: Word -> Decoder s ()
decodeTerm :: Decoder s Term
peekAvailable :: Decoder s Int
peekByteOffset :: Decoder s ByteOffset
peekTokenType :: Decoder s TokenType

-- | A CBOR deserialized value together with its size. When deserializing
--   use either <a>decodeSized</a> or its <a>DecCBOR</a> instance.
--   
--   Use <a>mkSized</a> to construct such value.
data Sized a
Sized :: !a -> Int64 -> Sized a
[sizedValue] :: Sized a -> !a

-- | Overhead in bytes. The field is lazy on purpose, because it might not
--   be needed, but it can be expensive to compute.
[sizedSize] :: Sized a -> Int64

-- | Construct a <a>Sized</a> value by serializing it first and recording
--   the amount of bytes it requires. Note, however, CBOR serialization is
--   not canonical, therefore it is *NOT* a requirement that this property
--   holds:
--   
--   <pre>
--   sizedSize (mkSized a) === sizedSize (unsafeDeserialize (serialize a) :: a)
--   </pre>
mkSized :: EncCBOR a => Version -> a -> Sized a
decodeSized :: Decoder s a -> Decoder s (Sized a)

-- | <i>Deprecated: In favor of more consistently named
--   <a>decodeSized</a></i>
sizedDecoder :: Decoder s a -> Decoder s (Sized a)

-- | Take a lens that operates on a particular type and convert it into a
--   lens that operates on the <a>Sized</a> version of the type.
toSizedL :: EncCBOR s => Version -> Lens' s a -> Lens' (Sized s) a
type Dropper s = Decoder s ()
dropBytes :: Dropper s
dropInt32 :: Dropper s

-- | Drop a list of values using the supplied <a>Dropper</a> for each
--   element
dropList :: Dropper s -> Dropper s
dropMap :: Dropper s -> Dropper s -> Dropper s
dropSet :: Dropper s -> Dropper s
dropTuple :: Dropper s -> Dropper s -> Dropper s
dropTriple :: Dropper s -> Dropper s -> Dropper s -> Dropper s
dropWord8 :: Dropper s
dropWord64 :: Dropper s
data Annotated b a
Annotated :: !b -> !a -> Annotated b a
[unAnnotated] :: Annotated b a -> !b
[annotation] :: Annotated b a -> !a

-- | A pair of offsets delimiting the beginning and end of a substring of a
--   ByteString
data ByteSpan
ByteSpan :: !ByteOffset -> !ByteOffset -> ByteSpan
class Decoded t where {
    type BaseType t :: Type;
}
recoverBytes :: Decoded t => t -> ByteString
annotationBytes :: Functor f => ByteString -> f ByteSpan -> f ByteString

-- | A decoder for a value paired with an annotation specifying the start
--   and end of the consumed bytes.
annotatedDecoder :: Decoder s a -> Decoder s (Annotated a ByteSpan)

-- | Extract a substring of a given ByteString corresponding to the
--   offsets.
slice :: ByteString -> ByteSpan -> ByteString

-- | A decoder for a value paired with an annotation specifying the start
--   and end of the consumed bytes.
decCBORAnnotated :: DecCBOR a => Decoder s (Annotated a ByteSpan)

-- | Reconstruct an annotation by re-serialising the payload to a
--   ByteString.
reAnnotate :: EncCBOR a => Version -> Annotated a b -> Annotated a ByteString

-- | A value of type <tt>(Annotator a)</tt> is one that needs access to the
--   entire bytestring used during decoding to finish construction of a
--   vaue of type <tt>a</tt>. A typical use is some type that stores the
--   bytes that were used to deserialize it. For example the type
--   <tt>Inner</tt> below is constructed using the helper function
--   <tt>makeInner</tt> which serializes and stores its bytes (using
--   <tt>serialize</tt>). Note how we build the <a>Annotator</a> by
--   abstracting over the full bytes, and using those original bytes to
--   fill the bytes field of the constructor <tt>Inner</tt>. The
--   <a>EncCBOR</a> instance just reuses the stored bytes to produce an
--   encoding (using <tt>encodePreEncoded</tt>).
--   
--   <pre>
--   data Inner = Inner Int Bool LByteString
--   
--   makeInner :: Int -&gt; Bool -&gt; Inner
--   makeInner i b = Inner i b (serialize (encCBOR i &lt;&gt; encCBOR b))
--   
--   instance EncCBOR Inner where
--     encCBOR (Inner _ _ bytes) = encodePreEncoded bytes
--   
--   instance DecCBOR (Annotator Inner) where
--     decCBOR = do
--        int &lt;- decCBOR
--        trueOrFalse &lt;- decCBOR
--        pure (Annotator ((Full bytes) -&gt; Inner int trueOrFalse bytes))
--   </pre>
--   
--   if an <tt>Outer</tt> type has a field of type <tt>Inner</tt>, with a
--   <tt>(EncCBOR (Annotator Inner))</tt> instance, the <tt>Outer</tt> type
--   must also have a <tt>(EncCBOR (Annotator Outer))</tt> instance. The
--   key to writing that instance is to use the operation
--   <tt>withSlice</tt> which returns a pair. The first component is an
--   <tt>Annotator</tt> that can build <tt>Inner</tt>, the second is an
--   <tt>Annotator</tt> that given the full bytes, extracts just the bytes
--   needed to decode <tt>Inner</tt>.
--   
--   <pre>
--   data Outer = Outer Text Inner
--   
--   instance EncCBOR Outer where
--     encCBOR (Outer t i) = encCBOR t &lt;&gt; encCBOR i
--   
--   instance DecCBOR (Annotator Outer) where
--     decCBOR = do
--       t &lt;- decCBOR
--       (Annotator mkInner, Annotator extractInnerBytes) &lt;- withSlice decCBOR
--       pure (Annotator ( full -&gt; Outer t (mkInner (Full (extractInnerBytes full)))))
--   </pre>
newtype Annotator a
Annotator :: (FullByteString -> a) -> Annotator a
[runAnnotator] :: Annotator a -> FullByteString -> a

-- | The argument is a decoder for a annotator that needs access to the
--   bytes that | were decoded. This function constructs and supplies the
--   relevant piece.
annotatorSlice :: Decoder s (Annotator (ByteString -> a)) -> Decoder s (Annotator a)

-- | Pairs the decoder result with an annotator that can be used to
--   construct the exact bytes used to decode the result.
withSlice :: Decoder s a -> Decoder s (a, Annotator ByteString)

-- | This marks the entire bytestring used during decoding, rather than the
--   piece we need to finish constructing our value.
newtype FullByteString
Full :: ByteString -> FullByteString
decodeAnnSet :: Ord t => Decoder s (Annotator t) -> Decoder s (Annotator (Set t))

-- | Remove the the semantic tag 24 from the enclosed CBOR data item,
--   decoding back the inner <tt>ByteString</tt> as a proper Haskell type.
--   Consume its input in full.
decodeNestedCbor :: DecCBOR a => Decoder s a

-- | Like <tt>decodeKnownCborDataItem</tt>, but assumes nothing about the
--   Haskell type we want to deserialise back, therefore it yields the
--   <tt>ByteString</tt> Tag 24 surrounded (stripping such tag away).
--   
--   In CBOR notation, if the data was serialised as:
--   
--   <pre>
--   &gt;&gt;&gt; 24(h'DEADBEEF')
--   </pre>
--   
--   then <a>decodeNestedCborBytes</a> yields the inner <tt>DEADBEEF</tt>,
--   unchanged.
decodeNestedCborBytes :: Decoder s ByteString

-- | Deserialize a Haskell value from the external binary representation,
--   which have been made using <tt>serialize</tt> or a matching
--   serialization functionilty in another language that uses CBOR format.
--   Accepts lazy <a>ByteString</a> as input, for strict variant use
--   <a>unsafeDeserialize'</a> instead.
--   
--   This deserializaer is not safe for these reasons:
--   
--   <ul>
--   <li><i>Throws</i>: <tt><a>DeserialiseFailure</a></tt> if the given
--   external representation is invalid or does not correspond to a value
--   of the expected type.</li>
--   <li>Decoding will not fail when the binary input is not consumed in
--   full.</li>
--   </ul>
unsafeDeserialize :: DecCBOR a => Version -> ByteString -> a

-- | Variant of <a>unsafeDeserialize</a> that accepts a strict
--   <a>ByteString</a> as input.
unsafeDeserialize' :: DecCBOR a => Version -> ByteString -> a
toStrictByteString :: Encoding -> ByteString

-- | <i>Deprecated: In favor of <a>decodeFullAnnotator</a></i>
decodeAnnotator :: Version -> Text -> (forall s. Decoder s (Annotator a)) -> ByteString -> Either DecoderError a

-- | <i>Deprecated: In favor of <a>decodeMaybe</a></i>
decCBORMaybe :: Decoder s a -> Decoder s (Maybe a)

module Cardano.Ledger.Binary.Group
newtype CBORGroup a
CBORGroup :: a -> CBORGroup a
[unCBORGroup] :: CBORGroup a -> a
groupRecord :: forall a s. (EncCBORGroup a, DecCBORGroup a) => Decoder s a
class Typeable a => EncCBORGroup a
encCBORGroup :: EncCBORGroup a => a -> Encoding
encodedGroupSizeExpr :: EncCBORGroup a => (forall x. EncCBOR x => Proxy x -> Size) -> Proxy a -> Size
listLen :: EncCBORGroup a => a -> Word

-- | an upper bound for <a>listLen</a>, used in <a>Size</a> expressions.
listLenBound :: EncCBORGroup a => Proxy a -> Word
listLenInt :: EncCBORGroup a => a -> Int
class Typeable a => DecCBORGroup a
decCBORGroup :: DecCBORGroup a => Decoder s a
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.Binary.Group.CBORGroup a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.Binary.Group.CBORGroup a)
instance (Cardano.Ledger.Binary.Group.DecCBORGroup a, Cardano.Ledger.Binary.Group.EncCBORGroup a) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Group.CBORGroup a)
instance Cardano.Ledger.Binary.Group.EncCBORGroup a => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Binary.Group.CBORGroup a)

module Cardano.Ledger.Binary.FlatTerm
type FlatTerm = [TermToken]
data () => TermToken
TkInt :: {-# UNPACK #-} !Int -> TermToken
TkInteger :: !Integer -> TermToken
TkBytes :: {-# UNPACK #-} !ByteString -> TermToken
TkBytesBegin :: TermToken
TkString :: {-# UNPACK #-} !Text -> TermToken
TkStringBegin :: TermToken
TkListLen :: {-# UNPACK #-} !Word -> TermToken
TkListBegin :: TermToken
TkMapLen :: {-# UNPACK #-} !Word -> TermToken
TkMapBegin :: TermToken
TkBreak :: TermToken
TkTag :: {-# UNPACK #-} !Word64 -> TermToken
TkBool :: !Bool -> TermToken
TkNull :: TermToken
TkSimple :: {-# UNPACK #-} !Word8 -> TermToken
TkFloat16 :: {-# UNPACK #-} !Float -> TermToken
TkFloat32 :: {-# UNPACK #-} !Float -> TermToken
TkFloat64 :: {-# UNPACK #-} !Double -> TermToken
toFlatTerm :: Version -> Encoding -> FlatTerm
fromFlatTerm :: Version -> (forall s. Decoder s a) -> FlatTerm -> Either String a
validFlatTerm :: FlatTerm -> Bool

module Cardano.Ledger.Binary
class Typeable a => FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a
class Typeable a => ToCBOR a
toCBOR :: ToCBOR a => a -> Encoding
data () => Term
TInt :: {-# UNPACK #-} !Int -> Term
TInteger :: !Integer -> Term
TBytes :: !ByteString -> Term
TBytesI :: !ByteString -> Term
TString :: !Text -> Term
TStringI :: !Text -> Term
TList :: ![Term] -> Term
TListI :: ![Term] -> Term
TMap :: ![(Term, Term)] -> Term
TMapI :: ![(Term, Term)] -> Term
TTagged :: {-# UNPACK #-} !Word64 -> !Term -> Term
TBool :: !Bool -> Term
TNull :: Term
TSimple :: {-# UNPACK #-} !Word8 -> Term
THalf :: {-# UNPACK #-} !Float -> Term
TFloat :: {-# UNPACK #-} !Float -> Term
TDouble :: {-# UNPACK #-} !Double -> Term
data () => DeserialiseFailure
DeserialiseFailure :: ByteOffset -> String -> DeserialiseFailure

-- | Translation function between values through a related binary
--   representation. This function allows you to translate one type into
--   another (or the same one) through their common binary format. It is
--   possible for the source type to be encoded with a different version
--   than the version that will be used for decoding. This is useful for
--   types that build upon one another and are "upgradeable" through their
--   binary representation. It is important to note that the
--   deserialization will happen with <a>Annotator</a>, since that is
--   usually the way we deserialize upgradeable types that live on chain.
--   Moreover, encoding does not require a version, because memoized types
--   that were decoded with annotation will have the bytes retained and
--   thus will have the <a>ToCBOR</a> instance.
translateViaCBORAnnotator :: (ToCBOR a, DecCBOR (Annotator b)) => Version -> Text -> a -> Except DecoderError b
