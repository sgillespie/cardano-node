-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A networking api shared with ouroboros-consensus
--   
--   A networking api shared with ouroboros-consensus.
@package ouroboros-network-api
@version 0.6.3.0

module Ouroboros.Network.AnchoredSeq

-- | Generalisation of a <tt>Sequence</tt> with elements of type <tt>b</tt>
--   with a custom measure <tt>v</tt> and an anchor <tt>a</tt>.
--   
--   This type is strict in the elements, but not strict in the spine.
--   
--   For example, an <a>AnchoredSeq</a> can represent a fragment of a chain
--   containing blocks that is anchored at a certain point. It can also
--   represent a history of ledger states with the anchor being the
--   "immutable" ledger state.
--   
--   NOTE: there might be multiple elements with the same measure, e.g.,
--   multiple blocks with the same <tt>WithOrigin SlotNo</tt>. That is why
--   functions operating on an <a>AnchoredSeq</a> often take a predicate in
--   addition to a measure. At most one element should satisfy that
--   predicate, e.g., the block must have a certain hash. The behaviour is
--   undefined when multiple elements satisfy the predicate.
data AnchoredSeq v a b

-- | &lt;math&gt;. Pattern for matching on or creating an empty
--   <a>AnchoredSeq</a>. An empty sequence has/needs an anchor.
pattern Empty :: Anchorable v a b => a -> AnchoredSeq v a b

-- | &lt;math&gt;. Add an element to the right of the anchored sequence.
pattern (:>) :: Anchorable v a b => AnchoredSeq v a b -> b -> AnchoredSeq v a b

-- | &lt;math&gt;. View the first, leftmost block of the anchored sequence.
--   
--   Note that the anchor shifts, i.e., the anchor of the second argument
--   will correspond to the first argument.
--   
--   This is only a view, not a constructor, as adding a block to the left
--   would change the anchor of the sequence, but we have no information
--   about the predecessor of the block we'd be prepending.
pattern (:<) :: Anchorable v a b => b -> AnchoredSeq v a b -> AnchoredSeq v a b
infixl 5 :<
infixl 5 :>

-- | Constaint needed to use an <tt>AnchoredSeq</tt>.
class (Ord v, Bounded v) => Anchorable v a b | a -> v

-- | <tt>b</tt> as anchor
asAnchor :: Anchorable v a b => b -> a

-- | Return the measure of an anchor
--   
--   The advantage of this method over a <tt><a>Measured</a> k a</tt>
--   super-class constraint is that it doesn't inherit the
--   <tt><a>Monoid</a> k</tt> constraint, which is unused and often
--   undesired.
getAnchorMeasure :: Anchorable v a b => Proxy b -> a -> v
anchor :: AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the most recently added element.
head :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. The anchor corresponding to the most recently added
--   element (i.e., the anchor that would be needed for a sequence starting
--   <i>after</i> this). When the anchored sequence is empty, the anchor is
--   returned.
headAnchor :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the leftmost element.
last :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   newest-to-oldest order.
toNewestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   oldest-to-newest order.
toOldestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   newest-to-oldest order. The last element in the list will be the one
--   after the given anchor.
fromNewestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   oldest-to-newest order. The first element in the list will be the one
--   after the given anchor.
fromOldestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> at a given position.
--   
--   POSTCONDITION: <tt>(before, after) = splitAt i s</tt>, then:
--   
--   <pre>
--   anchor      before == anchor s
--   headAnchor  before == anchor after
--   headAnchor  after  == headAnchor s
--   join before after  == Just s
--   </pre>
splitAt :: Anchorable v a b => Int -> AnchoredSeq v a b -> (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Drop the newest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
dropNewest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
takeOldest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Drop the newest elements that satisfy the predicate,
--   keeping the remainder. The anchor does not change.
dropWhileNewest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest elements that satisfy the predicate. The
--   anchor does not change.
takeWhileOldest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Return the number of elements. The anchor is not
--   counted.
length :: Anchorable v a b => AnchoredSeq v a b -> Int

-- | &lt;math&gt;. The anchor is not counted.
null :: AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Does the anchored sequence contain an element with the
--   given measure that satisfies the predicate? The anchor is ignored.
contains :: Anchorable v a b => v -> (b -> Bool) -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Does the anchored sequence contain an element with the
--   given measure that satisfies the predicate? The anchor is <i>not</i>
--   ignored.
withinBounds :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Maps over the elements and the elements.
map :: Anchorable v2 a b2 => (b1 -> b2) -> AnchoredSeq v1 a b1 -> AnchoredSeq v2 a b2

-- | &lt;math&gt;. Maps over the elements.
bimap :: Anchorable v2 a2 b2 => (a1 -> a2) -> (b1 -> b2) -> AnchoredSeq v1 a1 b1 -> AnchoredSeq v2 a2 b2

-- | &lt;math&gt;. Maps over the elements.
--   
--   NOTE: the functions must preserve the measure.
--   
--   More efficient than <a>map</a>
mapPreservingMeasure :: (b1 -> b2) -> AnchoredSeq v a b1 -> AnchoredSeq v a b2

-- | &lt;math&gt;. Maps over the anchor and the elements.
--   
--   NOTE: the functions must preserve the measure.
--   
--   More efficient than <a>bimap</a>
bimapPreservingMeasure :: (a1 -> a2) -> (b1 -> b2) -> AnchoredSeq v a1 b1 -> AnchoredSeq v a2 b2

-- | &lt;math&gt;. Roll back the anchored sequence such that its new head
--   has the same measure as the given one and satisfies the predicate.
--   When there is no such element or anchor, return <a>Nothing</a>.
rollback :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b)

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the <a>Eq</a> instances.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOf :: forall v a b. (Eq a, Eq b) => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the measure.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOfByMeasure :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt; where <i>s</i> is the number of elements with the same
--   measure. Return all elements in the anchored sequence with a measure
--   (<tt>k</tt>) equal to the given one. The elements will be ordered from
--   oldest to newest. Does not look at the anchor.
lookupByMeasure :: Anchorable v a b => v -> AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> after an element or anchor
--   with the given measure that satisfies the predicate. Return
--   <a>Nothing</a> if there is no element or anchor with the given measure
--   that satisfies the predicate.
--   
--   If the given measure corresponds to the anchor and it satisfies the
--   predicate, an empty sequence with the given anchor, and the original
--   sequence are returned.
--   
--   PRECONDITION: there can be multiple elements with the same measure,
--   but there should be at most one element (or anchor) with the given
--   measure satisfying the predicate.
--   
--   POSTCONDITION: when <tt>Just (before, after) = splitAfterMeasure k f
--   s</tt>, then:
--   
--   <pre>
--   anchor before       == anchor s
--   headMeasure before  == pt
--   anchorMeasure after == pt
--   headAnchor after    == headAnchor s
--   join before after   == Just s
--   </pre>
splitAfterMeasure :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> before an element with the
--   given measure that satisfies the predicate. Return <a>Nothing</a> if
--   the anchored sequence does not contain an element with the given
--   measure that satisfies the predicate.
--   
--   Unlike <a>splitAfterMeasure</a> we can't split before the anchor.
--   
--   PRECONDITION: there can be multiple elements with the same measure,
--   but there should be at most one element (or anchor) with the given
--   measure satisfying the predicate.
--   
--   POSTCONDITION: joining (<a>join</a>) the two anchored sequences gives
--   back the original anchored sequence.
--   
--   POSTCONDITION: the last element (oldest) in the second sequence has
--   the given measure and satisfies the predicate.
splitBeforeMeasure :: Anchorable v a b => v -> (b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Join two anchored sequences if the given function
--   returns <a>True</a> for the head (newest element or anchor when empty)
--   of the first sequence and the anchor of the second sequence, e.g.,
--   when they match.
--   
--   The returned sequence will have the same anchor as the first sequence.
join :: forall v a b. Anchorable v a b => (Either a b -> a -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b)

-- | Take the <tt>n</tt> newest elements from the anchored sequence.
--   
--   WARNING: this may change the anchor
--   
--   When the anchored sequence contains fewer than <tt>n</tt> elements,
--   the anchored sequence will be returned unmodified.
anchorNewest :: forall v a b. Anchorable v a b => Word64 -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Select the elements and optionally the anchor based on
--   the given offsets, starting from the head of the <a>AnchoredSeq</a>.
--   
--   The list of offsets must be increasing monotonically (/strictly
--   increasing is not required).
--   
--   <b>Note</b>: offset <tt>n</tt>, where <tt>n</tt> equals the length of
--   the <a>AnchoredSeq</a>, corresponds to the anchor. When the sequence
--   is empty, offset 0 will thus correspond to the anchor.
selectOffsets :: forall v a b. Anchorable v a b => [Int] -> AnchoredSeq v a b -> [Either a b]

-- | &lt;math&gt;. Variation on <a>filterWithStop</a> without a stop
--   condition.
filter :: forall v a b. Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]

-- | &lt;math&gt; where <i>r</i> is the number of consecutive ranges of
--   elements to be included in the result.
--   
--   Filter out elements that don't match the predicate.
--   
--   As filtering removes elements the result is a sequence of disconnected
--   sequences. The sequences are in the original order and are of maximum
--   size.
--   
--   As soon as the stop condition is true, the filtering stops and the
--   remaining sequence (starting with the first element for which the stop
--   condition is true) is the final sequence in the returned list.
--   
--   The stop condition wins from the filtering predicate: if the stop
--   condition is true for an element, but the filter predicate not, then
--   the element still ends up in final sequence.
--   
--   For example, given the sequence containing <tt>[0: 1, 2, 3, 4, 5,
--   6]</tt> where the anchor is separated from the elements by <tt>:</tt>:
--   
--   <pre>
--   filter         odd        -&gt; [[0: 1], [2: 3], [4: 5]]
--   filterWithStop odd (&gt;= 4) -&gt; [[0: 1], [2: 3], [3: 4, 5, 6]]
--   </pre>
filterWithStop :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
prettyPrint :: String -> (a -> String) -> (b -> String) -> AnchoredSeq v a b -> String

-- | &lt;math&gt;. Naive reference implementation of <a>filterWithStop</a>.
--   
--   While the asymptotic complexity of this function is better than that
--   of <a>filterWithStop</a>, the allocation cost is high. This function
--   deconstructs and reconstructs the anchored sequence (until the stop
--   condition is reached), even when no elements are removed.
filterWithStopSpec :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
instance GHC.Show.Show v => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.Measure v)
instance NoThunks.Class.NoThunks b => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Classes.Eq b => GHC.Classes.Eq (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Show.Show b => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance (NoThunks.Class.NoThunks a, NoThunks.Class.NoThunks b) => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance GHC.Show.Show Ouroboros.Network.AnchoredSeq.FilterRange
instance Ouroboros.Network.AnchoredSeq.Anchorable v a b => Data.FingerTree.Measured (Ouroboros.Network.AnchoredSeq.Measure v) (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Ouroboros.Network.AnchoredSeq.Measure v)
instance (GHC.Classes.Ord v, GHC.Enum.Bounded v) => GHC.Base.Monoid (Ouroboros.Network.AnchoredSeq.Measure v)

module Ouroboros.Network.CodecCBORTerm

-- | A pure codec which encodes to / decodes from <a>Term</a>. This is
--   useful if one expects a valid <tt>cbor</tt> encoding, which one might
--   not know how to decode like in the <tt>Handshake</tt> protocol.
data CodecCBORTerm fail a
CodecCBORTerm :: (a -> Term) -> (Term -> Either fail a) -> CodecCBORTerm fail a
[encodeTerm] :: CodecCBORTerm fail a -> a -> Term
[decodeTerm] :: CodecCBORTerm fail a -> Term -> Either fail a

module Ouroboros.Network.ControlMessage

-- | Control signal sent to a mini-protocol. Expected to exit, on
--   <a>Continue</a> it should continue its operation
data ControlMessage

-- | Continue operation.
Continue :: ControlMessage

-- | Hold on, e.g. do not sent messages until resumed. This is not used for
--   any hot protocol.
Quiesce :: ControlMessage

-- | The client is expected to terminate as soon as possible.
Terminate :: ControlMessage

-- | <a>ControlMessageSTM</a> should depend on <tt>muxMode</tt> (we only
--   need to schedule stop for initiator side). This is not done only
--   because this would break tests, but once the old api is removed it
--   should be possible.
type ControlMessageSTM m = STM m ControlMessage
continueForever :: Applicative (STM m) => proxy m -> ControlMessageSTM m

-- | First to finish synchronisation between <a>Terminate</a> state of
--   <a>ControlMessage</a> and an stm action.
--   
--   This should return <tt>STM m (Maybe a)</tt> but <a>STM</a> is a
--   non-injective type family, and we would need to pass <tt>Proxy m</tt>
--   to fix an ambiguous type (or use <tt>AllowAmbiguousTypes</tt>
--   extension).
timeoutWithControlMessage :: MonadSTM m => ControlMessageSTM m -> STM m a -> m (Maybe a)
instance GHC.Show.Show Ouroboros.Network.ControlMessage.ControlMessage
instance GHC.Classes.Eq Ouroboros.Network.ControlMessage.ControlMessage

module Ouroboros.Network.Handshake.Acceptable

-- | A <tt><a>Maybe</a></tt> like type which better explains its purpose.
data Accept vData
Accept :: vData -> Accept vData
Refuse :: !Text -> Accept vData
class Acceptable v

-- | The <a>acceptableVersion</a> function ought to be symmetric, this
--   guarantees that local and remote sides will agree on the same data.
acceptableVersion :: Acceptable v => v -> v -> Accept v
instance GHC.Show.Show vData => GHC.Show.Show (Ouroboros.Network.Handshake.Acceptable.Accept vData)
instance GHC.Classes.Eq vData => GHC.Classes.Eq (Ouroboros.Network.Handshake.Acceptable.Accept vData)

module Ouroboros.Network.Handshake

-- | A record that holds handshake callbacks.
data HandshakeCallbacks vData
HandshakeCallbacks :: (vData -> vData -> Accept vData) -> (vData -> Bool) -> HandshakeCallbacks vData
[acceptCb] :: HandshakeCallbacks vData -> vData -> vData -> Accept vData
[queryCb] :: HandshakeCallbacks vData -> vData -> Bool

module Ouroboros.Network.Handshake.Queryable
class Queryable v

-- | Whether or not there was a query for the supported version.
queryVersion :: Queryable v => v -> Bool

module Ouroboros.Network.Magic

-- | NetworkMagic is used to differentiate between different networks
--   during the initial handshake.
newtype NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
instance NoThunks.Class.NoThunks Ouroboros.Network.Magic.NetworkMagic
instance GHC.Generics.Generic Ouroboros.Network.Magic.NetworkMagic
instance GHC.Classes.Eq Ouroboros.Network.Magic.NetworkMagic
instance GHC.Show.Show Ouroboros.Network.Magic.NetworkMagic

module Ouroboros.Network.NodeToClient.Version

-- | Enumeration of node to client protocol versions.
data NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion7</tt>, i.e., Alonzo
NodeToClientV_9 :: NodeToClientVersion

-- | added <tt>GetChainBlockNo</tt> and <tt>GetChainPoint</tt> queries
NodeToClientV_10 :: NodeToClientVersion

-- | added <tt>GetRewardInfoPools</tt> Block query
NodeToClientV_11 :: NodeToClientVersion

-- | added <tt>LocalTxMonitor</tt> mini-protocol
NodeToClientV_12 :: NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion9</tt>, i.e., Babbage
NodeToClientV_13 :: NodeToClientVersion

-- | added <tt>GetPoolDistr</tt>, <tt>GetPoolState</tt>,
--   <tt>GetSnapshots</tt>
NodeToClientV_14 :: NodeToClientVersion

-- | added <a>query</a> to NodeToClientVersionData
NodeToClientV_15 :: NodeToClientVersion

-- | add <tt>ImmutableTip</tt> to <tt>LocalStateQuery</tt>, enabled
--   <tt>CardanoNodeToClientVersion11</tt>, i.e., Conway and
--   <tt>GetStakeDelegDeposits</tt>.
NodeToClientV_16 :: NodeToClientVersion

-- | Version data for NodeToClient protocol v1
data NodeToClientVersionData
NodeToClientVersionData :: !NetworkMagic -> !Bool -> NodeToClientVersionData
[networkMagic] :: NodeToClientVersionData -> !NetworkMagic
[query] :: NodeToClientVersionData -> !Bool
nodeToClientCodecCBORTerm :: NodeToClientVersion -> CodecCBORTerm Text NodeToClientVersionData

-- | We set 16ths bit to distinguish <tt>NodeToNodeVersion</tt> and
--   <a>NodeToClientVersion</a>. This way connecting wrong protocol suite
--   will fail during <tt>Handshake</tt> negotiation
--   
--   This is done in backward compatible way, so <tt>NodeToClientV_1</tt>
--   encoding is not changed.
nodeToClientVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToClientVersion
instance GHC.Show.Show Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Enum.Bounded Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Show.Show Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData
instance GHC.Classes.Eq Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData
instance Ouroboros.Network.Handshake.Acceptable.Acceptable Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData
instance Ouroboros.Network.Handshake.Queryable.Queryable Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData


-- | Various types related to ledger peers. This module is re-exported from
--   <a>Ouroboros.Network.PeerSelection.LedgerPeers</a>.
module Ouroboros.Network.PeerSelection.LedgerPeers.Type

-- | The relative stake of a stakepool in relation to the total amount
--   staked. A value in the [0, 1] range.
newtype PoolStake
PoolStake :: Rational -> PoolStake
[unPoolStake] :: PoolStake -> Rational

-- | The accumulated relative stake of a stake pool, like PoolStake but it
--   also includes the relative stake of all preceding pools. A value in
--   the range [0, 1].
newtype AccPoolStake
AccPoolStake :: Rational -> AccPoolStake
[unAccPoolStake] :: AccPoolStake -> Rational

-- | A boolean like type. Big ledger peers are the largest SPOs which
--   control 90% of staked stake.
--   
--   Note that <a>IsBigLedgerPeer</a> indicates a role that peer plays in
--   the eclipse evasion, e.g. that a peer was explicitly selected as a big
--   ledger peer, e.g. <a>IsNotBigLedgerPeer</a> does not necessarily mean
--   that the peer isn't a big ledger peer. This is because we select root
--   peers from all ledger peers (including big ones).
data IsBigLedgerPeer
IsBigLedgerPeer :: IsBigLedgerPeer
IsNotBigLedgerPeer :: IsBigLedgerPeer
instance Control.DeepSeq.NFData Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Num.Num Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Real.Fractional Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.Type.PoolStake
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.Type.AccPoolStake
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.LedgerPeers.Type.AccPoolStake
instance GHC.Num.Num Ouroboros.Network.PeerSelection.LedgerPeers.Type.AccPoolStake
instance GHC.Real.Fractional Ouroboros.Network.PeerSelection.LedgerPeers.Type.AccPoolStake
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.Type.AccPoolStake
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.Type.IsBigLedgerPeer

module Ouroboros.Network.PeerSelection.PeerAdvertise

-- | Should this peer be advertised to other peers asking for known peers?
--   For certain peers specified by configuration it would be an
--   appropriate policy to keep them private.
data PeerAdvertise
DoNotAdvertisePeer :: PeerAdvertise
DoAdvertisePeer :: PeerAdvertise
instance GHC.Generics.Generic Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.PeerAdvertise.PeerAdvertise

module Ouroboros.Network.PeerSelection.PeerSharing

-- | Is a peer willing to participate in Peer Sharing? If yes are others
--   allowed to share this peer's address? Information about the node comes
--   from the configuration file, while information about other nodes is
--   received via handshake.
--   
--   NOTE: This information is only useful if P2P flag is enabled.
data PeerSharing

-- | Peer does not participate in Peer Sharing at all
PeerSharingDisabled :: PeerSharing

-- | Peer participates in Peer Sharing
PeerSharingEnabled :: PeerSharing
instance GHC.Generics.Generic Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing
instance GHC.Read.Read Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing
instance GHC.Base.Semigroup Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing
instance GHC.Base.Monoid Ouroboros.Network.PeerSelection.PeerSharing.PeerSharing

module Ouroboros.Network.PeerSelection.RelayAccessPoint

-- | A product of a <a>Domain</a> and <a>PortNumber</a>. After resolving
--   the domain we will use the <a>PortNumber</a> to form <a>SockAddr</a>.
data DomainAccessPoint
DomainAccessPoint :: !Domain -> !PortNumber -> DomainAccessPoint
[dapDomain] :: DomainAccessPoint -> !Domain
[dapPortNumber] :: DomainAccessPoint -> !PortNumber

-- | A relay can have either an IP address and a port number or a domain
--   with a port number
data RelayAccessPoint
RelayAccessDomain :: !Domain -> !PortNumber -> RelayAccessPoint
RelayAccessAddress :: !IP -> !PortNumber -> RelayAccessPoint

-- | <a>RelayDomainAccessPoint</a> a bidirectional pattern which links
--   <a>RelayAccessDomain</a> and <a>DomainAccessPoint</a>.
pattern RelayDomainAccessPoint :: DomainAccessPoint -> RelayAccessPoint
data () => IP
IPv4 :: IPv4 -> IP
[ipv4] :: IP -> IPv4
IPv6 :: IPv6 -> IP
[ipv6] :: IP -> IPv6
data () => PortNumber
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Control.DeepSeq.NFData Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint

module Ouroboros.Network.Point
data () => WithOrigin t
Origin :: WithOrigin t
At :: !t -> WithOrigin t
data Block slot hash
Block :: !slot -> !hash -> Block slot hash
[blockPointSlot] :: Block slot hash -> !slot
[blockPointHash] :: Block slot hash -> !hash
origin :: WithOrigin t
at :: t -> WithOrigin t
block :: slot -> hash -> WithOrigin (Block slot hash)
fromWithOrigin :: t -> WithOrigin t -> t
withOrigin :: b -> (t -> b) -> WithOrigin t -> b
withOriginToMaybe :: WithOrigin t -> Maybe t
withOriginFromMaybe :: Maybe t -> WithOrigin t
instance (NoThunks.Class.NoThunks slot, NoThunks.Class.NoThunks hash) => NoThunks.Class.NoThunks (Ouroboros.Network.Point.Block slot hash)
instance GHC.Generics.Generic (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Show.Show slot, GHC.Show.Show hash) => GHC.Show.Show (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Classes.Ord slot, GHC.Classes.Ord hash) => GHC.Classes.Ord (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Classes.Eq slot, GHC.Classes.Eq hash) => GHC.Classes.Eq (Ouroboros.Network.Point.Block slot hash)

module Ouroboros.Network.SizeInBytes
newtype SizeInBytes
SizeInBytes :: Word32 -> SizeInBytes
[getSizeInBytes] :: SizeInBytes -> Word32
instance Control.DeepSeq.NFData Ouroboros.Network.SizeInBytes.SizeInBytes
instance NoThunks.Class.NoThunks Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Real.Integral Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Real.Real Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Num.Num Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Enum.Enum Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Classes.Ord Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Classes.Eq Ouroboros.Network.SizeInBytes.SizeInBytes
instance GHC.Show.Show Ouroboros.Network.SizeInBytes.SizeInBytes

module Ouroboros.Network.PeerSelection.PeerMetric.Type

-- | Report arrival time of a header for a given slot.
type HeaderMetricsTracer m = Tracer (STM m) (SlotNo, Time)

-- | Report block arrival of given size for some slot at a given time.
type FetchedMetricsTracer m = Tracer (STM m) (SizeInBytes, SlotNo, Time)
data ReportPeerMetrics m peerAddr
ReportPeerMetrics :: Tracer (STM m) (TraceLabelPeer peerAddr (SlotNo, Time)) -> Tracer (STM m) (TraceLabelPeer peerAddr (SizeInBytes, SlotNo, Time)) -> ReportPeerMetrics m peerAddr
[reportHeader] :: ReportPeerMetrics m peerAddr -> Tracer (STM m) (TraceLabelPeer peerAddr (SlotNo, Time))
[reportFetch] :: ReportPeerMetrics m peerAddr -> Tracer (STM m) (TraceLabelPeer peerAddr (SizeInBytes, SlotNo, Time))
data () => TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a

module Ouroboros.Network.Util.ShowProxy
class ShowProxy p
showProxy :: ShowProxy p => Proxy p -> String
showProxy :: (ShowProxy p, Typeable p) => Proxy p -> String

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy GHC.Types.Int

module Ouroboros.Network.Protocol.Limits
data ProtocolSizeLimits ps bytes
ProtocolSizeLimits :: (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Word) -> (bytes -> Word) -> ProtocolSizeLimits ps bytes
[sizeLimitForState] :: ProtocolSizeLimits ps bytes -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Word
[dataSize] :: ProtocolSizeLimits ps bytes -> bytes -> Word
data ProtocolTimeLimits ps
ProtocolTimeLimits :: (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Maybe DiffTime) -> ProtocolTimeLimits ps
[timeLimitForState] :: ProtocolTimeLimits ps -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Maybe DiffTime
data ProtocolLimitFailure
[ExceededSizeLimit] :: forall (pr :: PeerRole) ps (st :: ps). (forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => PeerHasAgency pr st -> ProtocolLimitFailure
[ExceededTimeLimit] :: forall (pr :: PeerRole) ps (st :: ps). (forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => PeerHasAgency pr st -> ProtocolLimitFailure
largeByteLimit :: Word
smallByteLimit :: Word
shortWait :: Maybe DiffTime
longWait :: Maybe DiffTime
waitForever :: Maybe DiffTime
instance GHC.Show.Show Ouroboros.Network.Protocol.Limits.ProtocolLimitFailure
instance GHC.Exception.Type.Exception Ouroboros.Network.Protocol.Limits.ProtocolLimitFailure


-- | Abstract view over blocks
--   
--   The network layer does not make any concrete assumptions about what
--   blocks look like.
module Ouroboros.Network.Block
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64

-- | Header hash
type family HeaderHash (b :: k) :: Type

-- | Header fields we expect to be present in a block
--   
--   These fields are lazy because they are extracted from a block or block
--   header; this type is not intended for storage.
data HeaderFields (b :: k)
HeaderFields :: SlotNo -> BlockNo -> HeaderHash b -> HeaderFields (b :: k)
[headerFieldSlot] :: HeaderFields (b :: k) -> SlotNo
[headerFieldBlockNo] :: HeaderFields (b :: k) -> BlockNo

-- | NOTE: this field is last so that the derived <a>Eq</a> and <a>Ord</a>
--   instances first compare the slot and block numbers, which is cheaper
--   than comparing hashes.
[headerFieldHash] :: HeaderFields (b :: k) -> HeaderHash b
castHeaderFields :: HeaderHash b ~ HeaderHash b' => HeaderFields b -> HeaderFields b'

-- | Abstract over the shape of blocks (or indeed just block headers)
class (StandardHash b, Typeable b) => HasHeader b
getHeaderFields :: HasHeader b => b -> HeaderFields b
blockNo :: HasHeader b => b -> BlockNo
blockSlot :: HasHeader b => b -> SlotNo
blockHash :: HasHeader b => b -> HeaderHash b

-- | Extension of <a>HasHeader</a> with some additional information
--   
--   Used in tests and assertions only.
class HasHeader b => HasFullHeader b
blockPrevHash :: HasFullHeader b => b -> ChainHash b
blockInvariant :: HasFullHeader b => b -> Bool

-- | <a>StandardHash</a> summarises the constraints we want header hashes
--   to have
--   
--   Without this class we would need to write
--   
--   <pre>
--   deriving instance Eq (HeaderHash block) =&gt; Eq (ChainHash block)
--   </pre>
--   
--   That requires <tt>UndecidableInstances</tt>; not a problem by itself,
--   but it also means that we can then not use <tt>deriving Eq</tt>
--   anywhere else for datatypes that reference <tt>Hash</tt>, which is
--   very frustrating; see
--   
--   
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/exts/deriving_inferred.html</a>
--   
--   Introducing the <a>StandardHash</a> class avoids this problem.
--   
--   Having these constraints directly as part of the <a>HasHeader</a>
--   class is possible but libraries that <i>use</i> the networking layer
--   may wish to be able to talk about <a>StandardHash</a> independently of
--   <a>HasHeader</a> since the latter may impose yet further constraints.
class (Eq (HeaderHash b), Ord (HeaderHash b), Show (HeaderHash b), Typeable (HeaderHash b), NoThunks (HeaderHash b)) => StandardHash (b :: k)
data ChainHash b
GenesisHash :: ChainHash b
BlockHash :: !HeaderHash b -> ChainHash b
castHash :: Coercible (HeaderHash b) (HeaderHash b') => ChainHash b -> ChainHash b'

-- | A point on the chain is identified by its <tt>Slot</tt> and
--   <a>HeaderHash</a>.
--   
--   The <tt>Slot</tt> tells us where to look and the <a>HeaderHash</a>
--   either simply serves as a check, or in some contexts it disambiguates
--   blocks from different forks that were in the same slot.
--   
--   It's a newtype rather than a type synonym, because using a type
--   synonym would lead to ambiguity, since HeaderHash is a non-injective
--   type family.
newtype Point block
Point :: WithOrigin (Block SlotNo (HeaderHash block)) -> Point block
[getPoint] :: Point block -> WithOrigin (Block SlotNo (HeaderHash block))
pointSlot :: Point block -> WithOrigin SlotNo
pointHash :: Point block -> ChainHash block
castPoint :: Coercible (HeaderHash b) (HeaderHash b') => Point b -> Point b'
blockPoint :: HasHeader block => block -> Point block
pattern GenesisPoint :: Point block
pattern BlockPoint :: SlotNo -> HeaderHash block -> Point block
atSlot :: forall {k} (block :: k). Point block -> SlotNo
withHash :: forall {k} (block :: k). Point block -> HeaderHash block

-- | Used in chain-sync protocol to advertise the tip of the server's
--   chain.
data Tip b

-- | The tip is genesis
TipGenesis :: Tip b

-- | The tip is not genesis
Tip :: !SlotNo -> !HeaderHash b -> !BlockNo -> Tip b

-- | The equivalent of <a>castPoint</a> for <a>Tip</a>
castTip :: HeaderHash a ~ HeaderHash b => Tip a -> Tip b
getTipPoint :: Tip b -> Point b
getTipBlockNo :: Tip b -> WithOrigin BlockNo
getTipSlotNo :: Tip b -> WithOrigin SlotNo

-- | Get the block number associated with a <a>Tip</a>, or
--   <tt>genesisBlockNo</tt> otherwise
--   
--   TODO: This is <i>wrong</i>. There <i>is</i> no block number if we are
--   at genesis (<tt>genesisBlockNo</tt> is the block number of the first
--   block on the chain). Usage of this function should be phased out.

-- | <i>Deprecated: Use getTipBlockNo</i>
getLegacyTipBlockNo :: Tip b -> BlockNo
tipFromHeader :: HasHeader a => a -> Tip a

-- | Inverse of <a>toLegacyTip</a>
--   
--   TODO: This should be phased out, since it makes no sense to have a
--   <a>BlockNo</a> for the genesis point.

-- | <i>Deprecated: Use tipFromHeader instead</i>
legacyTip :: Point b -> BlockNo -> Tip b

-- | Translate to the format it was before (to maintain binary
--   compatibility)

-- | <i>Deprecated: Use getTipPoint and getTipBlockNo</i>
toLegacyTip :: Tip b -> (Point b, BlockNo)
encodeTip :: (HeaderHash blk -> Encoding) -> Tip blk -> Encoding
decodeTip :: forall blk. (forall s. Decoder s (HeaderHash blk)) -> forall s. Decoder s (Tip blk)

-- | A representation of two actions to update a chain: add a block or roll
--   back to a previous point.
--   
--   The type parameter <tt>a</tt> is there to allow a <a>Functor</a>
--   instance. Typically, it will be instantiated with <tt>block</tt>
--   itself.
data ChainUpdate block a
AddBlock :: a -> ChainUpdate block a
RollBack :: Point block -> ChainUpdate block a

-- | The highest slot number seen.
data MaxSlotNo

-- | No block/header has been seen yet, so we don't have a highest slot
--   number.
NoMaxSlotNo :: MaxSlotNo

-- | The highest slot number seen.
MaxSlotNo :: !SlotNo -> MaxSlotNo
maxSlotNoFromMaybe :: Maybe SlotNo -> MaxSlotNo
maxSlotNoToMaybe :: MaxSlotNo -> Maybe SlotNo
maxSlotNoFromWithOrigin :: WithOrigin SlotNo -> MaxSlotNo
genesisPoint :: Point block
encodePoint :: (HeaderHash block -> Encoding) -> Point block -> Encoding
encodeChainHash :: (HeaderHash block -> Encoding) -> ChainHash block -> Encoding
decodePoint :: (forall s. Decoder s (HeaderHash block)) -> forall s. Decoder s (Point block)
decodeChainHash :: (forall s. Decoder s (HeaderHash block)) -> forall s. Decoder s (ChainHash block)

-- | An already serialised value
--   
--   When streaming blocks/header from disk to the network, there is often
--   no need to deserialise them, as we'll just end up serialising them
--   again when putting them on the wire.
newtype Serialised a
Serialised :: ByteString -> Serialised a
[unSerialised] :: Serialised a -> ByteString

-- | Wrap CBOR-in-CBOR
--   
--   This is primarily useful for the <i>decoder</i>; see
--   <a>unwrapCBORinCBOR</a>
wrapCBORinCBOR :: (a -> Encoding) -> a -> Encoding

-- | Unwrap CBOR-in-CBOR
--   
--   The CBOR-in-CBOR encoding gives us the <tt>ByteString</tt> we need in
--   order to to construct annotations.
unwrapCBORinCBOR :: (forall s. Decoder s (ByteString -> a)) -> forall s. Decoder s a

-- | Construct <a>Serialised</a> value from an unserialised value
mkSerialised :: (a -> Encoding) -> a -> Serialised a

-- | Decode a <a>Serialised</a> value
--   
--   Unlike a regular <a>Decoder</a>, which has an implicit input stream,
--   <a>fromSerialised</a> takes the <a>Serialised</a> value as an
--   argument.
fromSerialised :: (forall s. Decoder s (ByteString -> a)) -> Serialised a -> forall s. Decoder s a
instance forall k (b :: k). GHC.Generics.Generic (Ouroboros.Network.Block.HeaderFields b)
instance forall k (b :: k). GHC.Generics.Generic (Ouroboros.Network.Block.ChainHash b)
instance forall k (block :: k). GHC.Generics.Generic (Ouroboros.Network.Block.Point block)
instance forall k (b :: k). GHC.Generics.Generic (Ouroboros.Network.Block.Tip b)
instance forall k (block :: k). Data.Traversable.Traversable (Ouroboros.Network.Block.ChainUpdate block)
instance forall k (block :: k). Data.Foldable.Foldable (Ouroboros.Network.Block.ChainUpdate block)
instance forall k (block :: k). GHC.Base.Functor (Ouroboros.Network.Block.ChainUpdate block)
instance forall k (block :: k) a. (Ouroboros.Network.Block.StandardHash block, GHC.Show.Show a) => GHC.Show.Show (Ouroboros.Network.Block.ChainUpdate block a)
instance forall k (block :: k) a. (Ouroboros.Network.Block.StandardHash block, GHC.Classes.Eq a) => GHC.Classes.Eq (Ouroboros.Network.Block.ChainUpdate block a)
instance NoThunks.Class.NoThunks Ouroboros.Network.Block.MaxSlotNo
instance GHC.Generics.Generic Ouroboros.Network.Block.MaxSlotNo
instance GHC.Show.Show Ouroboros.Network.Block.MaxSlotNo
instance GHC.Classes.Eq Ouroboros.Network.Block.MaxSlotNo
instance forall k (a :: k). GHC.Classes.Eq (Ouroboros.Network.Block.Serialised a)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => GHC.Show.Show (Ouroboros.Network.Block.HeaderFields b)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => GHC.Classes.Eq (Ouroboros.Network.Block.HeaderFields b)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => GHC.Classes.Ord (Ouroboros.Network.Block.HeaderFields b)
instance forall k (b :: k). Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash b) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderFields b)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.Block.ChainHash block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Classes.Ord (Ouroboros.Network.Block.ChainHash block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.Block.ChainHash block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.Block.Point block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Classes.Ord (Ouroboros.Network.Block.Point block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.Block.Point block)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => NoThunks.Class.NoThunks (Ouroboros.Network.Block.Point block)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => GHC.Classes.Eq (Ouroboros.Network.Block.Tip b)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => GHC.Show.Show (Ouroboros.Network.Block.Tip b)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => NoThunks.Class.NoThunks (Ouroboros.Network.Block.Tip b)
instance forall k (a :: k). GHC.Show.Show (Ouroboros.Network.Block.Serialised a)
instance forall k (a :: k). Ouroboros.Network.Util.ShowProxy.ShowProxy a => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Serialised a)
instance forall k (block :: k). Ouroboros.Network.Block.StandardHash block => Ouroboros.Network.Block.StandardHash (Ouroboros.Network.Block.Serialised block)
instance forall k (a :: k). Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.Serialised a)
instance GHC.Classes.Ord Ouroboros.Network.Block.MaxSlotNo
instance GHC.Base.Semigroup Ouroboros.Network.Block.MaxSlotNo
instance GHC.Base.Monoid Ouroboros.Network.Block.MaxSlotNo
instance forall k (b :: k). Ouroboros.Network.Util.ShowProxy.ShowProxy b => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Tip b)
instance forall k (block :: k). Ouroboros.Network.Util.ShowProxy.ShowProxy block => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Point block)
instance forall k (block :: k). Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash block) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.Point block)
instance forall k (block :: k). (Ouroboros.Network.Block.StandardHash block, Data.Typeable.Internal.Typeable block) => NoThunks.Class.NoThunks (Ouroboros.Network.Block.ChainHash block)
instance forall k (b :: k). Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash b) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.ChainHash b)
instance forall k (b :: k). (Ouroboros.Network.Block.StandardHash b, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable k) => Ouroboros.Network.Block.HasHeader (Ouroboros.Network.Block.HeaderFields b)
instance forall k (b :: k). Ouroboros.Network.Block.StandardHash b => Ouroboros.Network.Block.StandardHash (Ouroboros.Network.Block.HeaderFields b)

module Ouroboros.Network.AnchoredFragment

-- | An <a>AnchoredFragment</a> is a fragment of a chain that is anchored
--   somewhere in that chain. The <a>Anchor</a> corresponds to the block
--   immediately before the first, leftmost block in the fragment. The
--   block corresponding to the anchor is not present in the fragment. The
--   anchor can be thought of as a left exclusive bound.
--   
--   For example, the following fragment is anchored at <tt>a</tt> and
--   contains <tt>b1</tt>, <tt>b2</tt>, and <tt>b3</tt>, which is the head
--   of the fragment.
--   
--   <pre>
--   a ] b1 &gt;: b2 &gt;: b3
--   </pre>
--   
--   The fact that it is an <i>exclusive</i> bound is particularly
--   convenient when dealing with Genesis. Genesis is the start of the
--   chain, but not an actual block, so we cannot use it an inclusive
--   bound. However, there <i>is</i> an <a>Anchor</a> that refers to
--   Genesis (<a>AnchorGenesis</a>), which can be used as the anchor,
--   acting as an exclusive bound.
--   
--   An <a>AnchoredFragment</a> anchored at Genesis can thus be converted
--   to a <a>Chain</a> (<tt>fromAnchoredFragment</tt>), containing all
--   blocks starting from Genesis.
--   
--   Without an anchor point, an empty fragment wouldn't give us much more
--   information: is it empty because the whole chain is empty? Or, did we
--   just get an empty fragment that was split off from some later part of
--   the chain?
type AnchoredFragment block = AnchoredSeq (WithOrigin SlotNo) (Anchor block) block

-- | Generalisation of a <tt>Sequence</tt> with elements of type <tt>b</tt>
--   with a custom measure <tt>v</tt> and an anchor <tt>a</tt>.
--   
--   This type is strict in the elements, but not strict in the spine.
--   
--   For example, an <a>AnchoredSeq</a> can represent a fragment of a chain
--   containing blocks that is anchored at a certain point. It can also
--   represent a history of ledger states with the anchor being the
--   "immutable" ledger state.
--   
--   NOTE: there might be multiple elements with the same measure, e.g.,
--   multiple blocks with the same <tt>WithOrigin SlotNo</tt>. That is why
--   functions operating on an <a>AnchoredSeq</a> often take a predicate in
--   addition to a measure. At most one element should satisfy that
--   predicate, e.g., the block must have a certain hash. The behaviour is
--   undefined when multiple elements satisfy the predicate.
data AnchoredSeq v a b

-- | &lt;math&gt;. Pattern for matching on or creating an empty
--   <a>AnchoredSeq</a>. An empty sequence has/needs an anchor.
pattern Empty :: Anchorable v a b => a -> AnchoredSeq v a b

-- | &lt;math&gt;. Add an element to the right of the anchored sequence.
pattern (:>) :: Anchorable v a b => AnchoredSeq v a b -> b -> AnchoredSeq v a b

-- | &lt;math&gt;. View the first, leftmost block of the anchored sequence.
--   
--   Note that the anchor shifts, i.e., the anchor of the second argument
--   will correspond to the first argument.
--   
--   This is only a view, not a constructor, as adding a block to the left
--   would change the anchor of the sequence, but we have no information
--   about the predecessor of the block we'd be prepending.
pattern (:<) :: Anchorable v a b => b -> AnchoredSeq v a b -> AnchoredSeq v a b
infixl 5 :<
infixl 5 :>
anchor :: AnchoredSeq v a b -> a

-- | Return the <a>Point</a> corresponding to the anchor.
anchorPoint :: AnchoredFragment block -> Point block

-- | Return the <tt>BlocKno</tt> corresponding to the anchor.
anchorBlockNo :: AnchoredFragment block -> WithOrigin BlockNo

-- | Anchor of an <a>AnchoredFragment</a>
data Anchor block

-- | The fragment is anchored at genesis
AnchorGenesis :: Anchor block

-- | The fragment is anchored after genesis
--   
--   We don't use the <a>Point</a> type directly as that has its <i>own</i>
--   use of <a>WithOrigin</a>, and we want to enforce here that we have a
--   block number if and only if the point is not <a>Origin</a>.
--   
--   Note that we don't use <a>HeaderFields</a> here because that is a view
--   of a header with lazy fields and thus unfit for long-term in-memory
--   storage.
--   
--   Moreover, we don't reuse the <a>Tip</a> type, because that type is
--   sent across the network, while this type is not. This means we can
--   freely change this type to suit our needs without worrying about
--   binary compatibility.
Anchor :: !SlotNo -> !HeaderHash block -> !BlockNo -> Anchor block

-- | Construct anchor from a block
--   
--   In other words, this would be the block immediately <i>before</i> the
--   other blocks in the fragment.
anchorFromBlock :: HasHeader block => block -> Anchor block

-- | Construct an anchor <i>from</i> a point
--   
--   In this case, we must also be given the <a>BlockNo</a>. This only
--   makes sense for points that aren't genesis.
anchorFromPoint :: Point block -> BlockNo -> Anchor block

-- | Compute which <a>Point</a> this anchor corresponds to
anchorToPoint :: Anchor block -> Point block

-- | Extract the <a>SlotNo</a> from the anchor
anchorToSlotNo :: Anchor block -> WithOrigin SlotNo

-- | Extract the <a>BlockNo</a> from the anchor
--   
--   NOTE: When the <a>Anchor</a> is <a>AnchorGenesis</a>, this returns
--   <a>Origin</a>. It does <i>not</i> return <tt>genesisBlockNo</tt>,
--   which is badly named, and is instead the block number of the first
--   block on the chain (i.e., <a>genesisPoint</a> and
--   <tt>genesisBlockNo</tt> don't go hand in hand!)
anchorToBlockNo :: Anchor block -> WithOrigin BlockNo

-- | Extract the hash from the anchor
--   
--   Returns <a>GenesisHash</a> if the anchor is <a>AnchorGenesis</a>.
anchorToHash :: Anchor block -> ChainHash block

-- | Does this anchor represent genesis (i.e., empty chain)?
anchorIsGenesis :: Anchor block -> Bool
anchorToHeaderFields :: Anchor block -> WithOrigin (HeaderFields block)

-- | Translate <a>Anchor</a> to <a>Tip</a>
--   
--   Right now this is in fact an isomorphism, but these two types are
--   logically independent.
anchorToTip :: HeaderHash a ~ HeaderHash b => Anchor a -> Tip b

-- | The equivalent of <a>castPoint</a> for <a>Anchor</a>
castAnchor :: HeaderHash a ~ HeaderHash b => Anchor a -> Anchor b

-- | &lt;math&gt;.
valid :: HasFullHeader block => AnchoredFragment block -> Bool

-- | &lt;math&gt;.
validExtension :: HasFullHeader block => AnchoredFragment block -> block -> Bool

-- | Abstract over the shape of blocks (or indeed just block headers)
class (StandardHash b, Typeable b) => HasHeader b
getHeaderFields :: HasHeader b => b -> HeaderFields b

-- | A point on the chain is identified by its <tt>Slot</tt> and
--   <a>HeaderHash</a>.
--   
--   The <tt>Slot</tt> tells us where to look and the <a>HeaderHash</a>
--   either simply serves as a check, or in some contexts it disambiguates
--   blocks from different forks that were in the same slot.
--   
--   It's a newtype rather than a type synonym, because using a type
--   synonym would lead to ambiguity, since HeaderHash is a non-injective
--   type family.
newtype Point block
Point :: WithOrigin (Block SlotNo (HeaderHash block)) -> Point block
[getPoint] :: Point block -> WithOrigin (Block SlotNo (HeaderHash block))
castPoint :: Coercible (HeaderHash b) (HeaderHash b') => Point b -> Point b'
blockPoint :: HasHeader block => block -> Point block

-- | &lt;math&gt;. When the fragment is empty, the anchor point is
--   returned.
headPoint :: HasHeader block => AnchoredFragment block -> Point block

-- | &lt;math&gt;. The anchor corresponding to the most recently added
--   element (i.e., the anchor that would be needed for a sequence starting
--   <i>after</i> this). When the anchored sequence is empty, the anchor is
--   returned.
headAnchor :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the fragment is empty, the slot of the anchor point
--   is returned, which may be origin (no slot).
headSlot :: HasHeader block => AnchoredFragment block -> WithOrigin SlotNo

-- | &lt;math&gt;. When the fragment is empty, the hash of the anchor point
--   is returned.
headHash :: HasHeader block => AnchoredFragment block -> ChainHash block

-- | &lt;math&gt;. When the fragment is empty, the block number of the
--   anchor point is returned.
headBlockNo :: HasHeader block => AnchoredFragment block -> WithOrigin BlockNo

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the most recently added element.
head :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the leftmost element.
last :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. When the fragment is empty, the anchor point is
--   returned.
lastPoint :: HasHeader block => AnchoredFragment block -> Point block

-- | &lt;math&gt;. When the fragment is empty, the slot of the anchor point
--   is returned, which may be the origin and therefore have no slot.
lastSlot :: HasHeader block => AnchoredFragment block -> WithOrigin SlotNo

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   newest-to-oldest order.
toNewestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   oldest-to-newest order.
toOldestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   newest-to-oldest order. The last element in the list will be the one
--   after the given anchor.
fromNewestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   oldest-to-newest order. The first element in the list will be the one
--   after the given anchor.
fromOldestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> at a given position.
--   
--   POSTCONDITION: <tt>(before, after) = splitAt i s</tt>, then:
--   
--   <pre>
--   anchor      before == anchor s
--   headAnchor  before == anchor after
--   headAnchor  after  == headAnchor s
--   join before after  == Just s
--   </pre>
splitAt :: Anchorable v a b => Int -> AnchoredSeq v a b -> (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Drop the newest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
dropNewest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
takeOldest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Drop the newest elements that satisfy the predicate,
--   keeping the remainder. The anchor does not change.
dropWhileNewest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest elements that satisfy the predicate. The
--   anchor does not change.
takeWhileOldest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Return the number of elements. The anchor is not
--   counted.
length :: Anchorable v a b => AnchoredSeq v a b -> Int

-- | &lt;math&gt;. The anchor is not counted.
null :: AnchoredSeq v a b -> Bool

-- | A representation of two actions to update a chain: add a block or roll
--   back to a previous point.
--   
--   The type parameter <tt>a</tt> is there to allow a <a>Functor</a>
--   instance. Typically, it will be instantiated with <tt>block</tt>
--   itself.
data ChainUpdate block a
AddBlock :: a -> ChainUpdate block a
RollBack :: Point block -> ChainUpdate block a

-- | &lt;math&gt;. Add a block to the right of the anchored fragment.
--   
--   Synonym for <a>:&gt;</a>.
addBlock :: HasHeader block => block -> AnchoredFragment block -> AnchoredFragment block

-- | &lt;math&gt;. If the <a>Point</a> is within the bounds of the
--   <a>AnchoredFragment</a> (see <a>withinFragmentBounds</a>), roll back
--   the anchored fragment such that its head is the given point. In case
--   the given point was the anchor point, the returned anchored fragment
--   will be empty.
--   
--   In other words, remove blocks from the end of the
--   <a>AnchoredFragment</a> until the given <a>Point</a> is the head. If
--   the given <a>Point</a> is not within the bounds of the
--   <a>AnchoredFragment</a>, return <a>Nothing</a>.
rollback :: HasHeader block => Point block -> AnchoredFragment block -> Maybe (AnchoredFragment block)
applyChainUpdate :: HasHeader block => ChainUpdate block block -> AnchoredFragment block -> Maybe (AnchoredFragment block)
applyChainUpdates :: HasHeader block => [ChainUpdate block block] -> AnchoredFragment block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Does the fragment contain a block with the given point?
--   The anchor point is ignored.
pointOnFragment :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Is the point within the fragment bounds? Either the
--   point is the anchor point, or it corresponds to a block "on" the
--   fragment.
withinFragmentBounds :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Find the first <a>Point</a> in the list of points that
--   is within the fragment bounds. Return <a>Nothing</a> if none of them
--   are.
findFirstPoint :: HasHeader block => [Point block] -> AnchoredFragment block -> Maybe (Point block)

-- | &lt;math&gt;. Find the block after the given point. If the given point
--   is the anchor point, then the first block is returned (if there is
--   one).
successorBlock :: HasHeader block => Point block -> AnchoredFragment block -> Maybe block

-- | &lt;math&gt;. Select a bunch of <a>Point</a>s based on offsets from
--   the head of the anchored fragment. This is used in the chain consumer
--   protocol as part of finding the intersection between a local and
--   remote chain.
--   
--   The list of offsets must be increasing monotonically.
--   
--   The typical pattern is to use a selection of offsets covering the last
--   K blocks, biased towards more recent blocks. For example:
--   
--   <pre>
--   selectPoints (0 : [ fib n | n &lt;- [1 .. 17] ])
--   </pre>
--   
--   Only for offsets within the bounds of the anchored fragment will there
--   be points in the returned list.
--   
--   <b>Note</b>: offset <tt>n</tt>, where <tt>n</tt> equals the length of
--   the anchored fragment, corresponds to the anchor point. When the
--   fragment is empty, offset 0 will thus correspond to the anchor point.
selectPoints :: forall block. HasHeader block => [Int] -> AnchoredFragment block -> [Point block]

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the <a>Eq</a> instances.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOf :: forall v a b. (Eq a, Eq b) => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Split the <a>AnchoredFragment</a> after the given
--   <a>Point</a>. Return <a>Nothing</a> if given <a>Point</a> is not
--   within the fragment bounds (<a>withinFragmentBounds</a>).
--   
--   The given <a>Point</a> may be the anchor point of the fragment, in
--   which case the empty fragment with the given anchor point and the
--   original fragment are returned.
--   
--   POSTCONDITION: when <tt>Just (before, after) = splitAfterPoint f
--   pt</tt>, then:
--   
--   <ul>
--   <li><pre>anchorPoint before == anchorPoint f</pre></li>
--   <li><pre>headPoint before == pt</pre></li>
--   <li><pre>anchorPoint after == pt</pre></li>
--   <li><pre>headPoint after == headPoint f</pre></li>
--   <li><pre>join before after == Just f</pre></li>
--   </ul>
splitAfterPoint :: forall block1 block2. (HasHeader block1, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> Point block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block1)

-- | &lt;math&gt;. Split the <a>AnchoredFragment</a> before the given
--   <a>Point</a>. Return <a>Nothing</a> if given <a>Point</a> is not on
--   the fragment (<a>pointOnFragment</a>).
--   
--   This means that <a>Nothing</a> is returned if the given <a>Point</a>
--   is the anchor point of the fragment.
--   
--   POSTCONDITION: joining (<a>join</a>) the two fragments gives back the
--   original fragment.
--   
--   POSTCONDITION: the last block (oldest) on the second fragment
--   corresponds to the given point.
splitBeforePoint :: forall block1 block2. (HasHeader block1, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> Point block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block1)

-- | Select a slice of an anchored fragment between two points, inclusive.
--   
--   Both points must exist on the chain, in order, or the result is
--   <tt>Nothing</tt>.
sliceRange :: HasHeader block => AnchoredFragment block -> Point block -> Point block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Join two anchored fragments if the anchor of the second
--   fragment is the head (newest block) of the first fragment.
--   
--   If the first fragment is empty, it can be joined if its anchor is the
--   same as the second fragment's anchor.
--   
--   The returned fragment will have the same anchor as the first fragment.
join :: HasHeader block => AnchoredFragment block -> AnchoredFragment block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Look for the most recent intersection of two
--   <a>AnchoredFragment</a>s <tt>c1</tt> and <tt>c2</tt>.
--   
--   The fragments need not have the same anchor point.
--   
--   If they intersect, i.e., share a common <a>Point</a> (possibly the
--   anchor point), then return a tuple of:
--   
--   <ul>
--   <li><tt>p1</tt>: the prefix of the first fragment</li>
--   <li><tt>p2</tt>: the prefix of the second fragment</li>
--   <li><tt>s1</tt>: the suffix of the first fragment</li>
--   <li><tt>s2</tt>: the suffix of the second fragment</li>
--   </ul>
--   
--   <tt>p1</tt> and <tt>p2</tt> will have the same <i>head</i> (possibly
--   an anchor point), namely the intersection point <tt>i</tt>. The
--   original chain <tt>c1</tt> can be obtained by putting <tt>s1</tt>
--   after <tt>p1</tt>, similarly for <tt>c2</tt>: by putting <tt>s2</tt>
--   after <tt>p2</tt>:
--   
--   <pre>
--   Just c1 = <a>join</a> p1 s1
--   Just c2 = <a>join</a> p2 s2
--   </pre>
--   
--   Take for example the following two fragments that share blocks 4 and
--   5. The two fragments are fragments of the same chain, but don't
--   contain all blocks of the original chain. The anchor points of the
--   fragments are indicated with an asterisk (*). The <tt>-A</tt> and
--   <tt>-B</tt> suffixes denote that blocks are part of a fork of the
--   chain.
--   
--   <pre>
--        1*
--       
--        2       2*
--            
--        4       4 
--            
--        5       5 
--   
--        6A      6B
--            
--                  8B
--                 
--         c1        c2
--   </pre>
--   
--   The intersection of <tt>c1</tt> and <tt>c2</tt> is block 5 (the last
--   <a>Point</a> the two fragments have in common) and we return the
--   following fragments:
--   
--   <pre>
--        1*
--       
--        2       2*
--            
--        4       4 
--            
--        5       5        5*      5*
--   
--                             6A      6B
--                                 
--                                       8B
--                                      
--   Just (p1,       p2,        s1,       s2)
--   </pre>
--   
--   The intersection point will be the anchor point of fragments
--   <tt>s1</tt> and <tt>s2</tt>. Fragment <tt>p1</tt> will have the same
--   anchor as <tt>c1</tt> and <tt>p2</tt> will have the same anchor as
--   <tt>c2</tt>.
--   
--   Note that an empty fragment can still intersect another fragment, as
--   its anchor point can still intersect the other fragment. In that case
--   the respective prefix and suffix are both equal to original empty
--   fragment. Additionally, two empty fragments intersect if their anchor
--   points are equal, in which case all prefixes and suffixes are equal to
--   the empty fragment with the anchor point in question.
intersect :: forall block1 block2. (HasHeader block1, HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> AnchoredFragment block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block2, AnchoredFragment block1, AnchoredFragment block2)

-- | &lt;math&gt;. Look for the most recent intersection point of two
--   <a>AnchoredFragment</a>s
--   
--   The fragments need not have the same anchor point.
--   
--   Reusing the example in the docstring of <a>intersect</a>: this
--   function will return the anchor point <tt>5*</tt>.
intersectionPoint :: (HasHeader block1, HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> AnchoredFragment block2 -> Maybe (Point block1)

-- | &lt;math&gt;. Maps over the chain's blocks. This is not allowed to
--   change the block <a>Point</a>s, or it would create an invalid chain.
--   The <a>anchorPoint</a> is not affected.
mapAnchoredFragment :: (HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => (block1 -> block2) -> AnchoredFragment block1 -> AnchoredFragment block2

-- | Take the <tt>n</tt> newest elements from the anchored sequence.
--   
--   WARNING: this may change the anchor
--   
--   When the anchored sequence contains fewer than <tt>n</tt> elements,
--   the anchored sequence will be returned unmodified.
anchorNewest :: forall v a b. Anchorable v a b => Word64 -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Variation on <a>filterWithStop</a> without a stop
--   condition.
filter :: forall v a b. Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]

-- | &lt;math&gt; where <i>r</i> is the number of consecutive ranges of
--   elements to be included in the result.
--   
--   Filter out elements that don't match the predicate.
--   
--   As filtering removes elements the result is a sequence of disconnected
--   sequences. The sequences are in the original order and are of maximum
--   size.
--   
--   As soon as the stop condition is true, the filtering stops and the
--   remaining sequence (starting with the first element for which the stop
--   condition is true) is the final sequence in the returned list.
--   
--   The stop condition wins from the filtering predicate: if the stop
--   condition is true for an element, but the filter predicate not, then
--   the element still ends up in final sequence.
--   
--   For example, given the sequence containing <tt>[0: 1, 2, 3, 4, 5,
--   6]</tt> where the anchor is separated from the elements by <tt>:</tt>:
--   
--   <pre>
--   filter         odd        -&gt; [[0: 1], [2: 3], [4: 5]]
--   filterWithStop odd (&gt;= 4) -&gt; [[0: 1], [2: 3], [3: 4, 5, 6]]
--   </pre>
filterWithStop :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
prettyPrint :: String -> (Point block -> String) -> (block -> String) -> AnchoredFragment block -> String

-- | &lt;math&gt;. Specification of <a>pointOnFragment</a>.
--   
--   Use <a>pointOnFragment</a>, as it should be faster.
--   
--   This function is used to verify whether <a>pointOnFragment</a> behaves
--   as expected.
pointOnFragmentSpec :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Specification of <a>selectPoints</a>.
--   
--   Use <a>selectPoints</a>, as it should be faster.
--   
--   This function is used to verify whether <a>selectPoints</a> behaves as
--   expected.
selectPointsSpec :: HasHeader block => [Int] -> AnchoredFragment block -> [Point block]

-- | &lt;math&gt;. Naive reference implementation of <a>filterWithStop</a>.
--   
--   While the asymptotic complexity of this function is better than that
--   of <a>filterWithStop</a>, the allocation cost is high. This function
--   deconstructs and reconstructs the anchored sequence (until the stop
--   condition is reached), even when no elements are removed.
filterWithStopSpec :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.HasHeader block => Ouroboros.Network.AnchoredSeq.Anchorable (Cardano.Slotting.Slot.WithOrigin Cardano.Slotting.Slot.SlotNo) (Ouroboros.Network.AnchoredFragment.Anchor block) block

module Ouroboros.Network.BlockFetch.ConsensusInterface
data FetchMode

-- | Use this mode when we are catching up on the chain but are stil well
--   behind. In this mode the fetch logic will optimise for throughput
--   rather than latency.
FetchModeBulkSync :: FetchMode

-- | Use this mode for block-producing nodes that have a known deadline to
--   produce a block and need to get the best chain before that. In this
--   mode the fetch logic will optimise for picking the best chain within
--   the given deadline.
FetchModeDeadline :: FetchMode

-- | The consensus layer functionality that the block fetch logic requires.
--   
--   These are provided as input to the block fetch by the consensus layer.
data BlockFetchConsensusInterface peer header block m
BlockFetchConsensusInterface :: STM m (Map peer (AnchoredFragment header)) -> STM m (AnchoredFragment header) -> STM m FetchMode -> STM m (Point block -> Bool) -> (WhetherReceivingTentativeBlocks -> STM m (Point block -> block -> m ())) -> STM m MaxSlotNo -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool) -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering) -> (header -> SizeInBytes) -> (header -> block -> Bool) -> (FromConsensus header -> STM m UTCTime) -> (FromConsensus block -> STM m UTCTime) -> BlockFetchConsensusInterface peer header block m

-- | Read the K-suffixes of the candidate chains.
--   
--   Assumptions: * Their headers must be already validated. * They may
--   contain <i>fewer</i> than <tt>K</tt> blocks. * Their anchor does not
--   have to intersect with the current chain.
[readCandidateChains] :: BlockFetchConsensusInterface peer header block m -> STM m (Map peer (AnchoredFragment header))

-- | Read the K-suffix of the current chain.
--   
--   This must contain info on the last <tt>K</tt> blocks (unless we're
--   near the chain genesis of course).
[readCurrentChain] :: BlockFetchConsensusInterface peer header block m -> STM m (AnchoredFragment header)

-- | Read the current fetch mode that the block fetch logic should use.
--   
--   The fetch mode is a dynamic part of the block fetch policy. In
--   <a>FetchModeBulkSync</a> it follows a policy that optimises for
--   expected bandwidth over latency to fetch any particular block, whereas
--   in <a>FetchModeDeadline</a> it follows a policy optimises for the
--   latency to fetch blocks, at the expense of wasting bandwidth.
--   
--   This mode should be set so that when the node's current chain is near
--   to "now" it uses the deadline mode, and when it is far away it uses
--   the bulk sync mode.
[readFetchMode] :: BlockFetchConsensusInterface peer header block m -> STM m FetchMode

-- | Recent, only within last K
[readFetchedBlocks] :: BlockFetchConsensusInterface peer header block m -> STM m (Point block -> Bool)

-- | This method allocates an <tt>addFetchedBlock</tt> function per client.
--   That function and <a>readFetchedBlocks</a> are required to be linked.
--   Upon successful completion of <tt>addFetchedBlock</tt> it must be the
--   case that <a>readFetchedBlocks</a> reports the block.
[mkAddFetchedBlock] :: BlockFetchConsensusInterface peer header block m -> WhetherReceivingTentativeBlocks -> STM m (Point block -> block -> m ())

-- | The highest stored/downloaded slot number.
--   
--   This is used to optimise the filtering of fragments in the block fetch
--   logic: when removing already downloaded blocks from a fragment, the
--   filtering (with a linear cost) is stopped as soon as a block has a
--   slot number higher than this slot number, as it cannot have been
--   downloaded anyway.
[readFetchedMaxSlotNo] :: BlockFetchConsensusInterface peer header block m -> STM m MaxSlotNo

-- | Given the current chain, is the given chain plausible as a candidate
--   chain. Classically for Ouroboros this would simply check if the
--   candidate is strictly longer, but for Ouroboros with operational key
--   certificates there are also cases where we would consider a chain of
--   equal length to the current chain.
[plausibleCandidateChain] :: BlockFetchConsensusInterface peer header block m -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool

-- | Compare two candidate chains and return a preference ordering. This is
--   used as part of selecting which chains to prioritise for downloading
--   block bodies.
[compareCandidateChains] :: BlockFetchConsensusInterface peer header block m -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering

-- | Much of the logic for deciding which blocks to download from which
--   peer depends on making estimates based on recent performance metrics.
--   These estimates of course depend on the amount of data we will be
--   downloading.
[blockFetchSize] :: BlockFetchConsensusInterface peer header block m -> header -> SizeInBytes

-- | Given a block header, validate the supposed corresponding block body.
[blockMatchesHeader] :: BlockFetchConsensusInterface peer header block m -> header -> block -> Bool

-- | Calculate when a header's block was forged.
--   
--   PRECONDITION: This function will succeed and give a _correct_ result
--   when applied to headers obtained via this interface (ie via Consensus,
--   ie via <a>readCurrentChain</a> or <a>readCandidateChains</a>).
--   
--   WARNING: This function may fail or, worse, __give an incorrect result
--   (!!)__ if applied to headers obtained from sources outside of this
--   interface. The <a>FromConsensus</a> newtype wrapper is intended to
--   make it difficult to make that mistake, so please pay that syntactic
--   price and consider its meaning at each call to this function.
--   Relatedly, preserve that argument wrapper as much as possible when
--   deriving ancillary functions/interfaces from this function.
[headerForgeUTCTime] :: BlockFetchConsensusInterface peer header block m -> FromConsensus header -> STM m UTCTime

-- | Calculate when a block was forged.
--   
--   PRECONDITION: Same as <a>headerForgeUTCTime</a>.
--   
--   WARNING: Same as <a>headerForgeUTCTime</a>.
[blockForgeUTCTime] :: BlockFetchConsensusInterface peer header block m -> FromConsensus block -> STM m UTCTime

-- | Whether the block fetch peer is sending tentative blocks, which are
--   understood to possibly be invalid
data WhetherReceivingTentativeBlocks
ReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks
NotReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks

-- | A new type used to emphasize the precondition of
--   <a>headerForgeUTCTime</a> and <a>blockForgeUTCTime</a> at each call
--   site.
--   
--   At time of writing, the <tt>a</tt> is either a header or a block. The
--   headers are literally from Consensus (ie provided by ChainSync).
--   Blocks, on the other hand, are indirectly from Consensus: they were
--   fetched only because we favored the corresponding header that
--   Consensus provided.
newtype FromConsensus a
FromConsensus :: a -> FromConsensus a
[unFromConsensus] :: FromConsensus a -> a
instance GHC.Show.Show Ouroboros.Network.BlockFetch.ConsensusInterface.FetchMode
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.ConsensusInterface.FetchMode
instance GHC.Base.Functor Ouroboros.Network.BlockFetch.ConsensusInterface.FromConsensus
instance GHC.Base.Applicative Ouroboros.Network.BlockFetch.ConsensusInterface.FromConsensus

module Ouroboros.Network.NodeToNode.Version

-- | Enumeration of node to node protocol versions.
data NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>new <tt>KeepAlive</tt> codec</li>
--   <li>Enable <tt>CardanoNodeToNodeVersion5</tt>, i.e., Alonzo</li>
--   </ul>
NodeToNodeV_7 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable block diffusion pipelining in ChainSync and BlockFetch
--   logic.</li>
--   </ul>
NodeToNodeV_8 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable <tt>CardanoNodeToNodeVersion6</tt>, i.e., Babbage</li>
--   </ul>
NodeToNodeV_9 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable full duplex connections.</li>
--   </ul>
NodeToNodeV_10 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Adds a new extra parameter to handshake: PeerSharing This version
--   is needed to support the new Peer Sharing miniprotocol older versions
--   that are negotiated will appear as not participating in Peer Sharing
--   to newer versions.</li>
--   <li>Adds <a>query</a> to NodeToClientVersionData.</li>
--   </ul>
NodeToNodeV_11 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable <tt>CardanoNodeToNodeVersion7</tt>, i.e., Conway</li>
--   </ul>
NodeToNodeV_12 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Removed PeerSharingPrivate constructor</li>
--   <li>Fixed Codec to disable PeerSharing with buggy versions 11 and
--   12.</li>
--   <li>Disable PeerSharing with InitiatorOnly nodes, since they do not
--   run peer sharing server side and can not reply to requests.</li>
--   </ul>
NodeToNodeV_13 :: NodeToNodeVersion

-- | Version data for NodeToNode protocol
data NodeToNodeVersionData
NodeToNodeVersionData :: !NetworkMagic -> !DiffusionMode -> !PeerSharing -> !Bool -> NodeToNodeVersionData
[networkMagic] :: NodeToNodeVersionData -> !NetworkMagic
[diffusionMode] :: NodeToNodeVersionData -> !DiffusionMode
[peerSharing] :: NodeToNodeVersionData -> !PeerSharing
[query] :: NodeToNodeVersionData -> !Bool

-- | The flag which indicates whether the node runs only initiator or both
--   initiator or responder node.
--   
--   This data structure has two proposes:
--   
--   <ul>
--   <li>instruct the diffusion layer if it should listen on incoming
--   connections;</li>
--   <li>it is communicated via <a>NodeToNodeVersionData</a> during
--   handshake negotiation. In non-p2p mode we always send
--   <a>InitiatorOnlyDiffusionMode</a>, in p2p mode we send exactly what
--   the diffusion is given. In non-p2p mode every connection outbound port
--   is ephemeral, the remote side cannot connect to it, however in p2p
--   mode the outbound port is actually the port on which the node is
--   listening (if it runs in
--   <a>InitiatorAndResponderDiffusionMode</a>).</li>
--   </ul>
data DiffusionMode
InitiatorOnlyDiffusionMode :: DiffusionMode
InitiatorAndResponderDiffusionMode :: DiffusionMode
data ConnectionMode
UnidirectionalMode :: ConnectionMode
DuplexMode :: ConnectionMode
nodeToNodeVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToNodeVersion
nodeToNodeCodecCBORTerm :: NodeToNodeVersion -> CodecCBORTerm Text NodeToNodeVersionData

-- | Check whether a version enabling diffusion pipelining has been
--   negotiated.
--   
--   TODO: this ought to be defined in `ouroboros-consensus` or
--   `ouroboros-consensus-diffusion`
isPipeliningEnabled :: NodeToNodeVersion -> WhetherReceivingTentativeBlocks
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.DiffusionMode
instance GHC.Classes.Ord Ouroboros.Network.NodeToNode.Version.DiffusionMode
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.DiffusionMode
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData
instance Ouroboros.Network.Handshake.Acceptable.Acceptable Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData
instance Ouroboros.Network.Handshake.Queryable.Queryable Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData

module Ouroboros.Network.PeerSelection.PeerSharing.Codec
encodePortNumber :: PortNumber -> Encoding
decodePortNumber :: Decoder s PortNumber

-- | This encoder should be faithful to the PeerSharing CDDL Specification.
--   
--   See the network design document for more details
encodeRemoteAddress :: NodeToNodeVersion -> SockAddr -> Encoding

-- | This decoder should be faithful to the PeerSharing CDDL Specification.
--   
--   See the network design document for more details
decodeRemoteAddress :: NodeToNodeVersion -> Decoder s SockAddr
