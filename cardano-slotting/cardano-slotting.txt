-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Key slotting types for cardano libraries
--   
--   Key slotting types for cardano libraries
@package cardano-slotting
@version 0.1.2.0

module Cardano.Slotting.Block

-- | The 0-based index of the block in the blockchain. BlockNo is &lt;=
--   SlotNo and is only equal at slot N if there is a block for every slot
--   where N &lt;= SlotNo.
newtype BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Block.BlockNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Block.BlockNo
instance Control.DeepSeq.NFData Cardano.Slotting.Block.BlockNo
instance NoThunks.Class.NoThunks Cardano.Slotting.Block.BlockNo
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Block.BlockNo
instance GHC.Num.Num Cardano.Slotting.Block.BlockNo
instance GHC.Enum.Bounded Cardano.Slotting.Block.BlockNo
instance GHC.Enum.Enum Cardano.Slotting.Block.BlockNo
instance GHC.Show.Show Cardano.Slotting.Block.BlockNo
instance GHC.Generics.Generic Cardano.Slotting.Block.BlockNo
instance GHC.Classes.Ord Cardano.Slotting.Block.BlockNo
instance GHC.Classes.Eq Cardano.Slotting.Block.BlockNo
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Block.BlockNo
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Block.BlockNo

module Cardano.Slotting.Slot

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
data WithOrigin t
Origin :: WithOrigin t
At :: !t -> WithOrigin t
at :: t -> WithOrigin t
origin :: WithOrigin t
fromWithOrigin :: t -> WithOrigin t -> t
withOrigin :: b -> (t -> b) -> WithOrigin t -> b
withOriginToMaybe :: WithOrigin t -> Maybe t
withOriginFromMaybe :: Maybe t -> WithOrigin t

-- | An epoch, i.e. the number of the epoch.
newtype EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Slot.SlotNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Slot.SlotNo
instance NoThunks.Class.NoThunks Cardano.Slotting.Slot.SlotNo
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Slot.SlotNo
instance Control.DeepSeq.NFData Cardano.Slotting.Slot.SlotNo
instance GHC.Num.Num Cardano.Slotting.Slot.SlotNo
instance GHC.Enum.Bounded Cardano.Slotting.Slot.SlotNo
instance GHC.Enum.Enum Cardano.Slotting.Slot.SlotNo
instance GHC.Show.Show Cardano.Slotting.Slot.SlotNo
instance GHC.Generics.Generic Cardano.Slotting.Slot.SlotNo
instance GHC.Classes.Ord Cardano.Slotting.Slot.SlotNo
instance GHC.Classes.Eq Cardano.Slotting.Slot.SlotNo
instance NoThunks.Class.NoThunks t => NoThunks.Class.NoThunks (Cardano.Slotting.Slot.WithOrigin t)
instance Codec.Serialise.Class.Serialise t => Codec.Serialise.Class.Serialise (Cardano.Slotting.Slot.WithOrigin t)
instance Data.Traversable.Traversable Cardano.Slotting.Slot.WithOrigin
instance Data.Foldable.Foldable Cardano.Slotting.Slot.WithOrigin
instance GHC.Base.Functor Cardano.Slotting.Slot.WithOrigin
instance GHC.Generics.Generic (Cardano.Slotting.Slot.WithOrigin t)
instance GHC.Show.Show t => GHC.Show.Show (Cardano.Slotting.Slot.WithOrigin t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Cardano.Slotting.Slot.WithOrigin t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Cardano.Slotting.Slot.WithOrigin t)
instance Control.DeepSeq.NFData Cardano.Slotting.Slot.EpochNo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Slot.EpochNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Slot.EpochNo
instance NoThunks.Class.NoThunks Cardano.Slotting.Slot.EpochNo
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Slot.EpochNo
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Slot.EpochNo
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Slot.EpochNo
instance GHC.Num.Num Cardano.Slotting.Slot.EpochNo
instance GHC.Enum.Enum Cardano.Slotting.Slot.EpochNo
instance GHC.Show.Show Cardano.Slotting.Slot.EpochNo
instance GHC.Generics.Generic Cardano.Slotting.Slot.EpochNo
instance GHC.Classes.Ord Cardano.Slotting.Slot.EpochNo
instance GHC.Classes.Eq Cardano.Slotting.Slot.EpochNo
instance Control.DeepSeq.NFData Cardano.Slotting.Slot.EpochSize
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Slot.EpochSize
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Slot.EpochSize
instance NoThunks.Class.NoThunks Cardano.Slotting.Slot.EpochSize
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Slot.EpochSize
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Slot.EpochSize
instance GHC.Real.Integral Cardano.Slotting.Slot.EpochSize
instance GHC.Real.Real Cardano.Slotting.Slot.EpochSize
instance GHC.Num.Num Cardano.Slotting.Slot.EpochSize
instance GHC.Enum.Enum Cardano.Slotting.Slot.EpochSize
instance GHC.Show.Show Cardano.Slotting.Slot.EpochSize
instance GHC.Generics.Generic Cardano.Slotting.Slot.EpochSize
instance GHC.Classes.Ord Cardano.Slotting.Slot.EpochSize
instance GHC.Classes.Eq Cardano.Slotting.Slot.EpochSize
instance (Codec.Serialise.Class.Serialise t, Data.Typeable.Internal.Typeable t) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Slotting.Slot.WithOrigin t)
instance (Codec.Serialise.Class.Serialise t, Data.Typeable.Internal.Typeable t) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Slotting.Slot.WithOrigin t)
instance GHC.Enum.Bounded t => GHC.Enum.Bounded (Cardano.Slotting.Slot.WithOrigin t)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Slotting.Slot.WithOrigin a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Slotting.Slot.WithOrigin a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Slotting.Slot.WithOrigin a)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Slot.SlotNo
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Slot.SlotNo

module Cardano.Slotting.Time

-- | System start
--   
--   Slots are counted from the system start.
newtype SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime

-- | <a>RelativeTime</a> is time relative to the <a>SystemStart</a>
--   
--   Precision is in picoseconds
newtype RelativeTime
RelativeTime :: NominalDiffTime -> RelativeTime
[getRelativeTime] :: RelativeTime -> NominalDiffTime
addRelativeTime :: NominalDiffTime -> RelativeTime -> RelativeTime
diffRelativeTime :: RelativeTime -> RelativeTime -> NominalDiffTime
fromRelativeTime :: SystemStart -> RelativeTime -> UTCTime
multRelativeTime :: Integral f => RelativeTime -> f -> RelativeTime
toRelativeTime :: SystemStart -> UTCTime -> RelativeTime
multNominalDiffTime :: Integral f => NominalDiffTime -> f -> NominalDiffTime
getSlotLength :: SlotLength -> NominalDiffTime

-- | Constructor for <a>SlotLength</a>
mkSlotLength :: NominalDiffTime -> SlotLength
slotLengthFromMillisec :: Integer -> SlotLength
slotLengthFromSec :: Integer -> SlotLength
slotLengthToMillisec :: SlotLength -> Integer
slotLengthToSec :: SlotLength -> Integer

-- | Slot length
--   
--   Precision is in milliseconds
data SlotLength
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Time.SystemStart
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Time.SystemStart
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Time.SystemStart
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Time.SystemStart
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Time.SystemStart
instance GHC.Show.Show Cardano.Slotting.Time.SystemStart
instance NoThunks.Class.NoThunks Cardano.Slotting.Time.SystemStart
instance GHC.Generics.Generic Cardano.Slotting.Time.SystemStart
instance GHC.Classes.Eq Cardano.Slotting.Time.SystemStart
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Time.RelativeTime
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Time.RelativeTime
instance GHC.Show.Show Cardano.Slotting.Time.RelativeTime
instance NoThunks.Class.NoThunks Cardano.Slotting.Time.RelativeTime
instance GHC.Generics.Generic Cardano.Slotting.Time.RelativeTime
instance GHC.Classes.Ord Cardano.Slotting.Time.RelativeTime
instance GHC.Classes.Eq Cardano.Slotting.Time.RelativeTime
instance GHC.Show.Show Cardano.Slotting.Time.SlotLength
instance NoThunks.Class.NoThunks Cardano.Slotting.Time.SlotLength
instance GHC.Generics.Generic Cardano.Slotting.Time.SlotLength
instance GHC.Classes.Eq Cardano.Slotting.Time.SlotLength
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Time.SlotLength
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Time.SlotLength
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Time.SlotLength
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Slotting.Time.RelativeTime
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Slotting.Time.RelativeTime
instance Codec.Serialise.Class.Serialise Cardano.Slotting.Time.RelativeTime

module Cardano.Slotting.EpochInfo.API

-- | Information about epochs
--   
--   Different epochs may have different sizes and different slot lengths.
--   This information is encapsulated by <a>EpochInfo</a>. It is
--   parameterized over a monad <tt>m</tt> because the information about
--   how long each epoch is may depend on information derived from the
--   blockchain itself. It ultimately requires acess to state, and so
--   either uses the monad for that or uses the monad to reify failure due
--   to cached state information being too stale for the current query.
data EpochInfo m
EpochInfo :: (HasCallStack => EpochNo -> m EpochSize) -> (HasCallStack => EpochNo -> m SlotNo) -> (HasCallStack => SlotNo -> m EpochNo) -> (HasCallStack => SlotNo -> m RelativeTime) -> (HasCallStack => SlotNo -> m SlotLength) -> EpochInfo m

-- | Return the size of the given epoch as a number of slots
--   
--   Note that the number of slots does <i>not</i> bound the number of
--   blocks, since the EBB and a regular block share a slot number.
[epochInfoSize_] :: EpochInfo m -> HasCallStack => EpochNo -> m EpochSize

-- | First slot in the specified epoch
--   
--   See also <a>epochInfoRange</a>
[epochInfoFirst_] :: EpochInfo m -> HasCallStack => EpochNo -> m SlotNo

-- | Epoch containing the given slot
--   
--   We should have the property that
--   
--   <pre>
--   s `inRange` epochInfoRange (epochInfoEpoch s)
--   </pre>
[epochInfoEpoch_] :: EpochInfo m -> HasCallStack => SlotNo -> m EpochNo

-- | The <a>RelativeTime</a> of the start of the given slot
--   
--   This calculation depends on the varying slot lengths of the relevant
--   epochs.
--   
--   See also <a>epochInfoSlotToUTCTime</a>.
[epochInfoSlotToRelativeTime_] :: EpochInfo m -> HasCallStack => SlotNo -> m RelativeTime

-- | Return the length of the specified slot.
[epochInfoSlotLength_] :: EpochInfo m -> HasCallStack => SlotNo -> m SlotLength
epochInfoSize :: HasCallStack => EpochInfo m -> EpochNo -> m EpochSize
epochInfoFirst :: HasCallStack => EpochInfo m -> EpochNo -> m SlotNo
epochInfoEpoch :: HasCallStack => EpochInfo m -> SlotNo -> m EpochNo
epochInfoRange :: Monad m => EpochInfo m -> EpochNo -> m (SlotNo, SlotNo)
epochInfoSlotToRelativeTime :: HasCallStack => EpochInfo m -> SlotNo -> m RelativeTime

-- | The start of the given slot
epochInfoSlotToUTCTime :: (HasCallStack, Monad m) => EpochInfo m -> SystemStart -> SlotNo -> m UTCTime
epochInfoSlotLength :: HasCallStack => EpochInfo m -> SlotNo -> m SlotLength
hoistEpochInfo :: (forall a. m a -> n a) -> EpochInfo m -> EpochInfo n
generalizeEpochInfo :: Monad m => EpochInfo Identity -> EpochInfo m
instance NoThunks.Class.NoThunks (Cardano.Slotting.EpochInfo.API.EpochInfo m)
instance GHC.Show.Show (Cardano.Slotting.EpochInfo.API.EpochInfo f)


-- | For use in trivial cases, such as in mocks, tests, etc.
module Cardano.Slotting.EpochInfo.Impl

-- | The <a>EpochInfo</a> induced by assuming the epoch size and slot
--   length are fixed for the entire system lifetime
fixedEpochInfo :: Monad m => EpochSize -> SlotLength -> EpochInfo m

-- | The pure computation underlying <a>epochInfoEpoch</a> applied to
--   <a>fixedEpochInfo</a>
--   
--   You don't need a <a>SlotLength</a> for this.
fixedEpochInfoEpoch :: EpochSize -> SlotNo -> EpochNo

-- | The pure computation underlying <a>epochInfoFirst</a> applied to
--   <a>fixedEpochInfo</a>
--   
--   You don't need a <a>SlotLength</a> for this.
fixedEpochInfoFirst :: EpochSize -> EpochNo -> SlotNo

module Cardano.Slotting.EpochInfo.Extend

-- | Given a basis point, use it and its slot length to impute a linear
--   relationship between slots and time in order to extend an
--   <a>EpochInfo</a> to infinity.
--   
--   The returned <a>EpochInfo</a> may still fail (according to the
--   semantics of the specified monad) if any of the underlying operations
--   fail. For example, if we cannot translate the basis point.
unsafeLinearExtendEpochInfo :: Monad m => SlotNo -> EpochInfo m -> EpochInfo m

module Cardano.Slotting.EpochInfo
