-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Specialized data for Cardano project
--   
--   Specialized data for Cardano project
@package cardano-data
@version 1.2.0.0

module Data.CanonicalMaps
class Eq t => CanonicalZero t
zeroC :: CanonicalZero t => t
joinC :: CanonicalZero t => t -> t -> t
canonicalInsert :: (Ord k, CanonicalZero a) => (a -> a -> a) -> k -> a -> Map k a -> Map k a
canonicalMapUnion :: (Ord k, CanonicalZero a) => (a -> a -> a) -> Map k a -> Map k a -> Map k a
canonicalMap :: (Ord k, CanonicalZero a) => (a -> a) -> Map k a -> Map k a
pointWise :: (Ord k, CanonicalZero v) => (v -> v -> Bool) -> Map k v -> Map k v -> Bool

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data () => Map k a
instance Data.CanonicalMaps.CanonicalZero GHC.Num.Integer.Integer
instance (GHC.Classes.Ord k, Data.CanonicalMaps.CanonicalZero v) => Data.CanonicalMaps.CanonicalZero (Data.Map.Internal.Map k v)

module Data.ListMap

-- | ListMap is a wrapper around an associative list. It is encoded in CBOR
--   and JSON as an object/map.
newtype ListMap k v
ListMap :: [(k, v)] -> ListMap k v
[unListMap] :: ListMap k v -> [(k, v)]
foldrWithKey :: ((k, a) -> b -> b) -> b -> ListMap k a -> b
keys :: ListMap k a -> [k]
keysSet :: Ord k => ListMap k a -> Set k
elems :: ListMap k a -> [a]
lookup :: Eq k => k -> ListMap k v -> Maybe v
filter :: (k -> v -> Bool) -> ListMap k v -> ListMap k v
toMap :: Ord k => ListMap k v -> Map k v
fromMap :: Map k v -> ListMap k v
mapKeys :: (k1 -> k2) -> ListMap k1 a -> ListMap k2 a
map :: (a -> v) -> ListMap k a -> ListMap k v
empty :: ListMap k a
fromList :: [(k, v)] -> ListMap k v
toList :: ListMap k v -> [(k, v)]
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.ListMap.ListMap k v)
instance GHC.Generics.Generic1 (Data.ListMap.ListMap k)
instance GHC.Generics.Generic (Data.ListMap.ListMap k v)
instance GHC.Base.Functor (Data.ListMap.ListMap k)
instance Data.Foldable.Foldable (Data.ListMap.ListMap k)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.ListMap.ListMap k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Eq (Data.ListMap.ListMap k v)
instance GHC.Base.Semigroup (Data.ListMap.ListMap k v)
instance GHC.Base.Monoid (Data.ListMap.ListMap k v)
instance (NoThunks.Class.NoThunks k, NoThunks.Class.NoThunks v) => NoThunks.Class.NoThunks (Data.ListMap.ListMap k v)
instance (Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR k, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR v) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Data.ListMap.ListMap k v)
instance (Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR k, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR v) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Data.ListMap.ListMap k v)
instance Data.Aeson.Types.ToJSON.ToJSONKey k => Data.Aeson.Types.ToJSON.ToJSON1 (Data.ListMap.ListMap k)
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSONKey k) => Data.Aeson.Types.ToJSON.ToJSON (Data.ListMap.ListMap k v)
instance (Data.Aeson.Types.FromJSON.FromJSON k, Data.Aeson.Types.FromJSON.FromJSONKey k) => Data.Aeson.Types.FromJSON.FromJSON1 (Data.ListMap.ListMap k)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON k, Data.Aeson.Types.FromJSON.FromJSONKey k) => Data.Aeson.Types.FromJSON.FromJSON (Data.ListMap.ListMap k v)
instance Control.DeepSeq.NFData k => Control.DeepSeq.NFData1 (Data.ListMap.ListMap k)
instance Data.Bifunctor.Bifunctor Data.ListMap.ListMap


-- | Sometimes we need to write our own version of functions over
--   <a>Map</a> that do not appear in the "containers" library. This module
--   is for such functions.
--   
--   For example:
--   
--   <ol>
--   <li>Version of <a>withoutKeys</a> where both arguments are
--   <a>Map</a></li>
--   <li>Comparing that two maps have exactly the same set of keys</li>
--   <li>The intersection of two maps guarded by a predicate.</li>
--   </ol>
--   
--   <pre>
--   ((dom stkcred) ◁ deleg) ▷ (dom stpool)) ==&gt;
--   intersectDomP (\ k v -&gt; Map.member v stpool) stkcred deleg
--   </pre>
module Data.MapExtras
data StrictTriple a b c
StrictTriple :: !a -> !b -> !c -> StrictTriple a b c

-- | Just like <a>delete</a>, but also returns the value if it was indeed
--   deleted from the map.
extract :: Ord k => k -> Map k b -> (Maybe b, Map k b)
noKeys :: Ord k => Map k a -> Map k b -> Map k a
keysEqual :: Ord k => Map k v1 -> Map k v2 -> Bool

-- | A variant of <tt>splitLookup</tt> that indicates only whether the key
--   was present, rather than producing its value. This is used to
--   implement <a>keysEqual</a> to avoid allocating unnecessary <a>Just</a>
--   constructors.
--   
--   <i>Note</i> - this is a copy pasted internal function from
--   "containers" package adjusted to return <a>StrictTriple</a>
splitMemberMap :: Ord k => k -> Map k a -> StrictTriple (Map k a) Bool (Map k a)

-- | <i>O(log n)</i>. Performs a <tt>split</tt> but also returns whether
--   the pivot element was found in the original set.
--   
--   This is a modified version of <a>splitMember</a>, where
--   <a>StrictTriple</a> is used instead of a lazy one for minor
--   performance gain.
splitMemberSet :: Ord a => a -> Set a -> StrictTriple (Set a) Bool (Set a)

-- | intersetDomP p m1 m2 == Keep the key and value from m2, iff (the key
--   is in the dom of m1) &amp;&amp; ((p key value) is true)
intersectDomP :: Ord k => (k -> v2 -> Bool) -> Map k v1 -> Map k v2 -> Map k v2

-- | <ul>
--   <li>Similar to intersectDomP, except the Map returned has the same key
--   as the first input map, rather than the second input map.</li>
--   </ul>
intersectDomPLeft :: Ord k => (k -> v2 -> Bool) -> Map k v1 -> Map k v2 -> Map k v1

-- | <ul>
--   <li>fold over the intersection of a Map and a Set</li>
--   </ul>
intersectMapSetFold :: Ord k => (k -> v -> ans -> ans) -> Map k v -> Set k -> ans -> ans

-- | Fold with <tt>accum</tt> all those pairs in the map, not appearing in
--   the set.
disjointMapSetFold :: Ord k => (k -> v -> ans -> ans) -> Map k v -> Set k -> ans -> ans

-- | Partition the <a>Map</a> according to keys in the <a>Set</a>. This is
--   equivalent to:
--   
--   <pre>
--   extractKeys m s === (withoutKeys m s, restrictKeys m s)
--   </pre>
extractKeys :: Ord k => Map k a -> Set k -> (Map k a, Map k a)

-- | It has been discovered expirementally through benchmarks that for
--   small Set size of under around 6 elements this function performs
--   faster than <a>extractKeys#</a>
extractKeysSmallSet :: Ord k => Map k a -> Set k -> (Map k a, Map k a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Data.MapExtras.StrictTriple a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Data.MapExtras.StrictTriple a b c)

module Data.OMap.Strict

-- | Class of types that can be mapped by a lens or a projection to an Ord
--   type.
--   
--   For a type <tt>V</tt>, defines a lens from <tt>V</tt> to and Ord type
--   <tt>K</tt>.
class Ord k => HasOKey k v | v -> k
okeyL :: HasOKey k v => Lens' v k

-- | A general-purpose finite, insert-ordered, map that is strict in its
--   keys and values.
--   
--   The strictness is enforced by the underlying strict <tt>Map</tt> that
--   can be looked-up by a projection or lens. and the ordering is
--   maintained by the constructing functions, leveraging
--   <tt>StrictSeq</tt> to hold the insert-order of the keys.
--   
--   TODO: DecShareCBOR instance
data OMap k v

-- | &lt;math&gt;
pattern Empty :: OMap k v

-- | &lt;math&gt;.
pattern (:<|:) :: (HasOKey k v, Ord k) => v -> OMap k v -> OMap k v

-- | &lt;math&gt;.
pattern (:|>:) :: (HasOKey k v, Ord k) => OMap k v -> v -> OMap k v
infixl 5 :|>:
infixr 5 :<|:

-- | &lt;math&gt;.
null :: OMap k v -> Bool

-- | &lt;math&gt;.
size :: OMap k v -> Int

-- | &lt;math&gt;.
empty :: OMap k v

-- | &lt;math&gt;. Strict in its arguments.
singleton :: HasOKey k v => v -> OMap k v

-- | &lt;math&gt;. If the key is not present <a>lookup</a> returns
--   <a>Nothing</a>.
lookup :: Ord k => k -> OMap k v -> Maybe v

-- | &lt;math&gt;. Key membership check.
member :: Ord k => k -> OMap k v -> Bool

-- | <a>flip</a>ed version of <a>lookup</a>
(!?) :: Ord k => OMap k v -> k -> Maybe v

-- | &lt;math&gt;.
fromSet :: HasOKey k v => Set v -> OMap k v

-- | &lt;math&gt;. Checks membership before snoc'ing. De-duplicates the
--   StrictSeq without overwriting. Starts from the left or head, using
--   <tt>foldl'</tt>
fromFoldable :: (Foldable f, HasOKey k v) => f v -> OMap k v

-- | &lt;math&gt;. Checks membership before snoc'ing. De-duplicates the
--   StrictSeq and collects and returns the duplicates found. Starts from
--   the left or head, using <tt>foldl'</tt>
fromFoldableDuplicates :: (Foldable f, HasOKey k v, Ord v) => f v -> (Set v, OMap k v)

-- | &lt;math&gt;.
toMap :: OMap k v -> Map k v

-- | &lt;math&gt;.
toStrictSeq :: Ord k => OMap k v -> StrictSeq v

-- | &lt;math&gt;.
toStrictSeqOKeys :: OMap k v -> StrictSeq k

-- | &lt;math&gt;.
toStrictSeqOfPairs :: Ord k => OMap k v -> StrictSeq (k, v)

-- | &lt;math&gt;. Shallow invariant using just <a>length</a> and
--   <a>size</a>.
invariantHolds :: OMap k v -> Bool

-- | &lt;math&gt;. Deep, costly invariant using membership check for each
--   value. By the pigeon-hole principle, this check is exhaustive.
invariantHolds' :: Ord k => OMap k v -> Bool

-- | &lt;math&gt;. Checks membership before snoc'ing.
(|>) :: HasOKey k v => OMap k v -> v -> OMap k v
infixl 5 |>

-- | &lt;math&gt;. Checks membership before cons'ing.
(<|) :: HasOKey k v => v -> OMap k v -> OMap k v
infixr 5 <|

-- | &lt;math&gt;. Checks membership before cons'ing. Overwrites a
--   duplicate.
(<||) :: HasOKey k v => v -> OMap k v -> OMap k v
infixr 5 <||

-- | &lt;math&gt;. Checks membership before snoc'ing. Overwrites a
--   duplicate.
(||>) :: HasOKey k v => OMap k v -> v -> OMap k v
infixl 5 ||>

-- | &lt;math&gt;. For every uncons-ed element from the sequence on the
--   right, check its membership in the sequence on the left, before
--   snoc'ing it. Preserve order. Remove duplicates from sequence on the
--   right.
(|><) :: HasOKey k v => OMap k v -> OMap k v -> OMap k v
infixl 5 |><

-- | &lt;math&gt;. For every unsnoc-ed element from the sequence on the
--   left, check its membership in the sequence on the right, before
--   cons'ing it. Preserve order. Remove duplicates from sequence on the
--   left.
(><|) :: HasOKey k v => OMap k v -> OMap k v -> OMap k v
infixr 5 ><|

-- | &lt;math&gt;. Value membership check.
elem :: (HasOKey k v, Eq v) => v -> OMap k v -> Bool

-- | &lt;math&gt;. Given a <tt>Set</tt> of <tt>k</tt>s, and an <a>OMap</a>
--   <tt>k</tt> <tt>v</tt> return a pair of <tt>Map</tt> and <a>OMap</a>
--   where the <tt>k</tt>s in the <tt>Set</tt> have been removed from the
--   <a>OMap</a> and presented as a separate <tt>Map</tt>.
extractKeys :: Ord k => Set k -> OMap k v -> (OMap k v, Map k v)

-- | &lt;math&gt;. Like <a>adjust</a>.
--   
--   Returns the original <a>OMap</a> unaltered when the key does not
--   exist.
--   
--   If the key exists, then the function is applied to the value, but we
--   need to consider three possible cases:
--   
--   <ol>
--   <li>The modified value's <a>okeyL</a> is unaltered - we return omap
--   with the adjusted value,</li>
--   <li>The modified value's <a>okeyL</a> is altered, but not a duplicate
--   - we return the omap with adjusted key (in place) and value</li>
--   <li>The modified value's <a>okeyL</a> is altered and is a duplicate -
--   we return the omap with the old key deleted from the sequence but
--   without inserting the new key since it is a duplicate, and deleting
--   old value and inserting the new value in place of its duplicate.</li>
--   </ol>
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.OMap.Strict
--   
--   &gt;&gt;&gt; import Lens.Micro
--   
--   &gt;&gt;&gt; instance HasOKey Int (Int, Char) where okeyL = _1
--   
--   &gt;&gt;&gt; let m = fromFoldable $ zip [1,2] ['a','b'] :: OMap Int (Int, Char)
--   
--   &gt;&gt;&gt; m
--   StrictSeq {fromStrict = fromList [(1,(1,'a')),(2,(2,'b'))]}
--   
--   &gt;&gt;&gt; let adjustingFn (k, v) = (k, succ v) -- Changes the value
--   
--   &gt;&gt;&gt; let overwritingAdjustingFn (k,v) = (succ k, v) -- Changes the `okeyL`.
--   
--   &gt;&gt;&gt; adjust adjustingFn 1 m
--   StrictSeq {fromStrict = fromList [(1,(1,'b')),(2,(2,'b'))]}
--   
--   &gt;&gt;&gt; adjust overwritingAdjustingFn  1 m
--   StrictSeq {fromStrict = fromList [(2,(2,'a'))]}
--   </pre>
adjust :: HasOKey k v => (v -> v) -> k -> OMap k v -> OMap k v

-- | &lt;math&gt;
filter :: Ord k => (v -> Bool) -> OMap k v -> OMap k v
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.OMap.Strict.OMap k v)
instance GHC.Generics.Generic (Data.OMap.Strict.OMap k v)
instance (NoThunks.Class.NoThunks k, NoThunks.Class.NoThunks v) => NoThunks.Class.NoThunks (Data.OMap.Strict.OMap k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.OMap.Strict.OMap k v)
instance (GHC.Show.Show v, GHC.Classes.Ord k, GHC.Show.Show k) => GHC.Show.Show (Data.OMap.Strict.OMap k v)
instance Data.Default.Class.Default (Data.OMap.Strict.OMap k v)
instance Data.OMap.Strict.HasOKey k v => GHC.IsList.IsList (Data.OMap.Strict.OMap k v)
instance (Data.OMap.Strict.HasOKey k v, Data.Aeson.Types.ToJSON.ToJSON v) => Data.Aeson.Types.ToJSON.ToJSON (Data.OMap.Strict.OMap k v)
instance Data.OMap.Strict.HasOKey k v => GHC.Base.Semigroup (Data.OMap.Strict.OMap k v)
instance Data.OMap.Strict.HasOKey k v => GHC.Base.Monoid (Data.OMap.Strict.OMap k v)
instance GHC.Classes.Ord k => Data.Foldable.Foldable (Data.OMap.Strict.OMap k)
instance (Data.Typeable.Internal.Typeable k, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR v, GHC.Classes.Ord k) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Data.OMap.Strict.OMap k v)
instance (Data.Typeable.Internal.Typeable k, Data.OMap.Strict.HasOKey k v, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR v, GHC.Classes.Eq v) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Data.OMap.Strict.OMap k v)

module Data.OSet.Strict

-- | A general-purpose finite, ordered, set that is strict in its values.
--   
--   The strictness is enforced by the underlying <tt>StrictSeq</tt> from
--   base, and the uniqueness of the values is enforced in this module, by
--   the constructing functions by leveraging an accompanying <tt>Set</tt>.
--   
--   TODO: @aniketd Implement DecShareCBOR
data OSet a
pattern Empty :: OSet a

-- | &lt;math&gt;.
pattern (:<|:) :: Ord a => a -> OSet a -> OSet a

-- | &lt;math&gt;.
pattern (:|>:) :: Ord a => OSet a -> a -> OSet a
infixl 5 :|>:
infixr 5 :<|:

-- | &lt;math&gt;.
null :: OSet a -> Bool

-- | &lt;math&gt;.
size :: OSet a -> Int

-- | &lt;math&gt;.
empty :: OSet a

-- | &lt;math&gt;. Strict in its argument.
singleton :: a -> OSet a

-- | &lt;math&gt;. The element at the specified position, counting from 0.
--   If the specified position is negative or at least the length of the
--   sequence, <a>lookup</a> returns <a>Nothing</a>.
lookup :: Int -> OSet a -> Maybe a

-- | &lt;math&gt;. Membership check.
member :: Ord a => a -> OSet a -> Bool

-- | <a>flip</a>ed version of <a>lookup</a>
(!?) :: OSet a -> Int -> Maybe a

-- | &lt;math&gt;. Checks membership before snoc-ing. De-duplicates the
--   StrictSeq without overwriting. Starts from the left or head, using
--   <tt>foldl'</tt>
fromStrictSeq :: Ord a => StrictSeq a -> OSet a

-- | &lt;math&gt;. Checks membership before snoc-ing. Returns a 2-tuple,
--   with <a>fst</a> as a <tt>Set</tt> of duplicates found and the
--   <a>snd</a> as the de-duplicated <a>OSet</a> without overwriting.
--   Starts from the left or head, using <tt>foldl'</tt>
fromStrictSeqDuplicates :: Ord a => StrictSeq a -> (Set a, OSet a)

-- | &lt;math&gt; - Extract underlying strict sequence
toStrictSeq :: OSet a -> StrictSeq a

-- | &lt;math&gt; - Extract underlying Set
toSet :: OSet a -> Set a

-- | &lt;math&gt;.
fromSet :: Set a -> OSet a

-- | Using a <a>Foldable</a> instance of the source data structure convert
--   it to an <a>OSet</a>
fromFoldable :: (Foldable f, Ord a) => f a -> OSet a

-- | &lt;math&gt;. Shallow invariant using just <a>length</a> and
--   <a>size</a>.
invariantHolds :: OSet a -> Bool

-- | &lt;math&gt;. Deep invariant using set membership check for each
--   value. By the pigeon-hole principle, this check is exhaustive.
invariantHolds' :: Ord a => OSet a -> Bool
(|>) :: Ord a => OSet a -> a -> OSet a
infixl 5 |>
(<|) :: Ord a => a -> OSet a -> OSet a
infixr 5 <|

-- | &lt;math&gt;. For every uncons-ed element from the sequence on the
--   right, checks its membership in the sequence on the left, before
--   snoc'ing it. Preserves order. Remove duplicates from sequence on the
--   right.
(|><) :: Ord a => OSet a -> OSet a -> OSet a
infixl 5 |><

-- | &lt;math&gt;. For every unsnoc-ed element from the sequence on the
--   left, checks its membership in the sequence on the right, before
--   cons'ing it. Preserves order. Remove duplicates from sequence on the
--   left.
(><|) :: Ord a => OSet a -> OSet a -> OSet a
infixr 5 ><|

-- | &lt;math&gt;
filter :: Ord a => (a -> Bool) -> OSet a -> OSet a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.OSet.Strict.OSet a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Data.OSet.Strict.OSet a)
instance GHC.Generics.Generic (Data.OSet.Strict.OSet a)
instance GHC.Show.Show a => GHC.Show.Show (Data.OSet.Strict.OSet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.OSet.Strict.OSet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OSet.Strict.OSet a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.OSet.Strict.OSet a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.OSet.Strict.OSet a)
instance GHC.Classes.Ord a => GHC.IsList.IsList (Data.OSet.Strict.OSet a)
instance Data.Foldable.Foldable Data.OSet.Strict.OSet
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR a => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Data.OSet.Strict.OSet a)
instance (GHC.Show.Show a, GHC.Classes.Ord a, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR a) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Data.OSet.Strict.OSet a)

module Data.Pulse

-- | let T be a Pulse structure. A Pulse struture is abstracted over a
--   monad: m, and an answer type: t, so the concrete type of a pulse
--   structure is written: (T m a). The Pulsable class supplies operations
--   on the structure that allow its computation to be split into many
--   discrete steps. One does this by running: "pulse p" or "pulseM p",
--   depending upon whether the computation is monadic or not, to run a
--   discrete step. The scheduling infrastructure needs to know nothing
--   about what is going on inside the pulse structure.
class Pulsable (pulse :: (Type -> Type) -> Type -> Type)
done :: Pulsable pulse => pulse m ans -> Bool
current :: Pulsable pulse => pulse m ans -> ans
pulseM :: (Pulsable pulse, Monad m) => pulse m ans -> m (pulse m ans)
completeM :: (Pulsable pulse, Monad m) => pulse m ans -> m ans

-- | A Map based pulser.
data PulseMapM m ans
[PulseMap] :: !Int -> !ans -> k -> v -> m ans -> !Map k v -> !ans -> PulseMapM m ans

-- | A List based pulser
data PulseListM m ans
[PulseList] :: !Int -> !ans -> a -> m ans -> ![a] -> !ans -> PulseListM m ans

-- | Type of a Map based pulser in the Identity monad.
type PulseMap ans = PulseListM Identity ans

-- | Type of a List based pulser in the Identity monad.
type PulseList ans = PulseListM Identity ans

-- | Create List pulser structure in the Identity monad, a pure accumulator
--   is lifted to a monadic one.
pulseList :: Int -> (t1 -> t2 -> t1) -> [t2] -> t1 -> PulseListM Identity t1

-- | Create Map pulser structure in the Identity monad, a pure accumulator
--   is lifted to a monadic one.
pulseMap :: Int -> (a -> k -> v -> a) -> Map k v -> a -> PulseMapM Identity a

-- | Pulse a structure in the Identity monad
pulse :: Pulsable p => p Identity ans -> p Identity ans

-- | Complete a structure in the Identity monad
complete :: Pulsable p => p Identity ans -> ans

-- | A strict, monadic, version of <a>foldl</a>. It associates to the left.
foldlM' :: (Foldable t, Monad m) => (ans -> k -> m ans) -> ans -> t k -> m ans

-- | <i>O(n)</i>. A strict, monadic, version of <tt>foldlWithKey</tt>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
--   Associates to the left.
foldlWithKeyM' :: Monad m => (a -> k -> b -> m a) -> a -> Map k b -> m a
instance GHC.Show.Show ans => GHC.Show.Show (Data.Pulse.PulseMapM m ans)
instance Data.Pulse.Pulsable Data.Pulse.PulseMapM
instance GHC.Show.Show ans => GHC.Show.Show (Data.Pulse.PulseListM m ans)
instance Data.Pulse.Pulsable Data.Pulse.PulseListM


-- | The idea is to create a world of Haskell types, called a Universe.
--   Then to define a 'class' whose methods are only applicable to that set
--   of types. We define a closed set by defining an indexed type
--   constructor Rep. If (Singleton Rep), then it must be that every value
--   of type (Rep t) has exactly 0 or 1 inhabitants. (Rep t) has exactly 1
--   inhabitant if <tt>t</tt> is in the universe, and 0 inhabitants if it
--   is not in the universe. A closely related class is (Indexed s t). We
--   would like a total ordering on (t i) and (t j), where the indices, i
--   and j, are different. We do this by ensuring every value of type (t i)
--   has a unique Shape, and that the type Shape has a total order. Every
--   closed singleton can be totally ordered this way. Other indexed types
--   are used to make well-type terms. I.e. Indexed s t =&gt; Exp t,
--   denotes a Haskell data type Exp, related to the type t. Note, unlike
--   singletons, there may not be a unique value of type (Exp t), but there
--   may be a unique Shape for every value.
module Data.Universe

-- | For some indexed types, we can assign a unique Shape to each type,
--   using: <a>shape</a> :: t i -&gt; Shape s (where s is some Singleton
--   type) the class (Shaped t s) means we can assign a unique Shape to
--   each value of type (t i). Not quite as strong as having a unique
--   inhabitant. Every closed singleton type can be shaped, and many other
--   indexed types can be shaped as well.
class Shaped t rep
shape :: Shaped t rep => t i -> Shape rep

-- | Given (Singleton T), a value of type (T i) has exactly 0 or 1
--   inhabitants, so we can compare the structure of the type to get proofs
--   that the indexes (i and j) are the same type, using testEql, at
--   runtime. <a>cmpIndex</a>, it is like <a>compare</a> except we can have
--   two different indexes (<tt>a</tt> and <tt>b</tt>).
class Singleton t
testEql :: Singleton t => t i -> t j -> Maybe (i :~: j)
cmpIndex :: Singleton t => t a -> t b -> Ordering

-- | A minimal class of operations defined on the universe described by
--   <tt>rep</tt> . Feel free to make your own Universe classes with
--   additional methods
class Singleton rep => Universe rep t
repOf :: Universe rep t => rep t

-- | Hide the index for any indexed type <tt>t</tt>
data Any t
[Any] :: t i -> Any t

-- | Hide the index for a singleton type <tt>t</tt>
data Some t
[Some] :: Singleton t => t i -> Some t
data Dyn rep
[Dyn] :: Singleton t => t i -> i -> Dyn t
data Shape rep
[Nullary] :: Int -> Shape rep
[Nary] :: Int -> [Shape rep] -> Shape rep
[Esc] :: (Singleton rep, Ord t) => rep t -> t -> Shape rep

-- | Type synonym, so we can use ( :~: ) without TypeOperators
type Eql x y = x :~: y

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | TypeRep is a concrete representation of a (monomorphic) type.
--   <a>TypeRep</a> supports reasonably efficient equality. See Note [Grand
--   plan for Typeable] in GHC.Tc.Instance.Typeable
data () => TypeRep (a :: k)

-- | Order two indexed types by their Shape. This is usefull for making
--   (Singleton t) instances when we have (Shaped t r) instances, as
--   cmpIndex can be compareByShape.
compareByShape :: forall (rep :: Type -> Type) (t :: Type -> Type) (i :: Type) (j :: Type). Shaped t rep => t i -> t j -> Ordering
instance forall k (t :: k -> *). (forall (i :: k). GHC.Show.Show (t i)) => GHC.Show.Show (Data.Universe.Any t)
instance Data.Universe.Shaped Data.Universe.R any
instance Data.Universe.Singleton Data.Universe.R
instance GHC.Classes.Ord (Data.Universe.Shape rep)
instance GHC.Classes.Eq (Data.Universe.Shape rep)
instance forall k (r :: k -> *). GHC.Classes.Ord (Data.Universe.Some r)
instance forall k (r :: k -> *). GHC.Classes.Eq (Data.Universe.Some r)
instance Data.Universe.Singleton Data.Typeable.Internal.TypeRep
