-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Auto-generate a command-line parser for your datatype
--   
--   This library auto-generates an
--   <tt>optparse-applicative</tt>-compatible <tt>Parser</tt> from any data
--   type that derives the <tt>Generic</tt> interface.
--   
--   See the documentation in <a>Options.Generic</a> for an example of how
--   to use this library
@package optparse-generic
@version 1.5.2


-- | This library auto-generates command-line parsers for data types using
--   Haskell's built-in support for generic programming. The best way to
--   understand how this library works is to walk through a few examples.
--   
--   For example, suppose that you want to parse a record with named fields
--   like this:
--   
--   <pre>
--   -- Example.hs
--   
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Options.Generic
--   
--   data Example = Example { foo :: Int, bar :: Double }
--       deriving (Generic, Show)
--   
--   instance ParseRecord Example
--   
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Example)
--   </pre>
--   
--   Named fields translate to flags which you can provide in any order:
--   
--   <pre>
--   $ stack build optparse-generic
--   $ stack runghc Example.hs -- --bar 2.5 --foo 1
--   Example {foo = 1, bar = 2.5}
--   </pre>
--   
--   This also auto-generates <tt>--help</tt> output:
--   
--   <pre>
--   $ stack runghc Example.hs -- --help
--   Test program
--   
--   Usage: Example.hs --foo INT --bar DOUBLE
--   
--   Available options:
--     -h,--help                Show this help text
--   </pre>
--   
--   You can also add help descriptions to each field, like this:
--   
--   <pre>
--   {-# LANGUAGE DataKinds         #-}
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE TypeOperators     #-}
--   
--   import Options.Generic
--   
--   data Example = Example
--       { foo :: Int    &lt;?&gt; "Documentation for the foo flag"
--       , bar :: Double &lt;?&gt; "Documentation for the bar flag"
--       } deriving (Generic, Show)
--   
--   instance ParseRecord Example
--   
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Example)
--   </pre>
--   
--   ... which produces the following <tt>--help</tt> output:
--   
--   <pre>
--   $ stack runghc Example.hs -- --help
--   Test program
--   
--   Usage: Example.hs --foo INT --bar DOUBLE
--   
--   Available options:
--     -h,--help                Show this help text
--     --foo INT                Documentation for the foo flag
--     --bar DOUBLE             Documentation for the bar flag
--   </pre>
--   
--   However, any fields you document will be wrapped in the <a>Helpful</a>
--   constructor:
--   
--   <pre>
--   $ stack runghc Example.hs -- --foo 1 --bar 2.5
--   Example {foo = Helpful {unHelpful = 1}, bar = Helpful {unHelpful = 2.5}}
--   </pre>
--   
--   To avoid this, while still being able to document your fields, you may
--   generalize the definition of your record with a parameter <tt>w</tt>,
--   and use <a>unwrapRecord</a>.
--   
--   <pre>
--   {-# LANGUAGE DataKinds          #-}
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE FlexibleInstances  #-}  -- One more extension.
--   {-# LANGUAGE OverloadedStrings  #-}
--   {-# LANGUAGE StandaloneDeriving #-}  -- To derive Show
--   {-# LANGUAGE TypeOperators      #-}
--   
--   import Options.Generic
--   
--   data Example w = Example
--       { foo :: w ::: Int    &lt;?&gt; "Documentation for the foo flag"
--       , bar :: w ::: Double &lt;?&gt; "Documentation for the bar flag"
--       } deriving (Generic)
--   
--   instance ParseRecord (Example Wrapped)
--   deriving instance Show (Example Unwrapped)
--   
--   main = do
--       x &lt;- unwrapRecord "Test program"
--       print (x :: Example Unwrapped)
--   </pre>
--   
--   <tt>Example Unwrapped</tt> is equivalent to a record type with simple
--   fields:
--   
--   <pre>
--   $ stack runghc Example.hs -- --foo 1 --bar 2.5
--   Example {foo = 1, bar = 2.5}
--   </pre>
--   
--   You can also add default values to each <a>Read</a>able field, like
--   this:
--   
--   <pre>
--   {-# LANGUAGE DataKinds         #-}
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE TypeOperators     #-}
--   
--   import Options.Generic
--   
--   data Example = Example
--       { foo :: Int    &lt;!&gt; "1"
--       , bar :: String &lt;!&gt; "hello"
--       } deriving (Generic, Show)
--   
--   instance ParseRecord Example
--   
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Example)
--   </pre>
--   
--   Default values will work alongside help descriptions and unwrapping.
--   
--   For the following examples I encourage you to test what
--   <tt>--help</tt> output they generate.
--   
--   This library will also do the right thing if the fields have no
--   labels:
--   
--   <pre>
--   data Example = Example Int Double deriving (Generic, Show)
--   </pre>
--   
--   Fields without labels translate into positional command-line
--   arguments:
--   
--   <pre>
--   $ stack runghc Example.hs -- 1 2.5
--   Example 1 2.5
--   </pre>
--   
--   Certain types of fields are given special treatment, such as in this
--   example:
--   
--   <pre>
--   data Example = Example
--       { switch   :: Bool
--       , list     :: [Int]
--       , optional :: Maybe   Int
--       , first    :: First   Int
--       , last     :: Last    Int
--       , sum      :: Sum     Int
--       , product  :: Product Int
--       } deriving (Generic, Show)
--   </pre>
--   
--   This gives the following behavior:
--   
--   <pre>
--   $ stack runghc Example.hs --
--         --switch
--         --optional 1
--         --list    1 --list    2
--         --first   1 --first   2
--         --last    1 --last    2
--         --sum     1 --sum     2
--         --product 1 --product 2
--   Example {switch = True, list = [1,2], optional = Just 1, first = First 
--   {getFirst = Just 1}, last = Last {getLast = Just 2}, sum = Sum {getSum =
--   3}, product = Product {getProduct = 2}}
--   
--   $ stack runghc Example.hs
--   Example {switch = False, list = [], optional = Nothing, first = First
--   {getFirst = Nothing}, second = Last {getLast = Nothing}, sum = Sum {getSum
--   = 0}, product = Product {getProduct = 1}}
--   </pre>
--   
--   If a datatype has multiple constructors:
--   
--   <pre>
--   data Example
--       = Create { name :: Text, duration :: Maybe Int }
--       | Kill   { name :: Text }
--       deriving (Generic, Show)
--   </pre>
--   
--   ... then they will translate into subcommands named after each
--   constructor:
--   
--   <pre>
--   $ stack runghc Example.hs -- create --name foo --duration=60
--   Create {name = "foo", duration = Just 60}
--   $ stack runghc Example.hs -- kill --name foo
--   Kill {name = "foo"}
--   </pre>
--   
--   This library also provides out-of-the-box support for many existing
--   types, like tuples and <a>Either</a>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Options.Generic
--   
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Either Double Int)
--   </pre>
--   
--   <pre>
--   $ stack runghc Example.hs -- left 1.0
--   Left 1.0
--   $ stack runghc Example.hs -- right 2
--   Right 2
--   </pre>
--   
--   <pre>
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: (Double, Int))
--   </pre>
--   
--   <pre>
--   $ stack runghc Example.hs -- 1.0 2
--   (1.0,2)
--   </pre>
--   
--   ... and you can also just parse a single value:
--   
--   <pre>
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Int)
--   </pre>
--   
--   <pre>
--   $ stack runghc Example.hs -- 2
--   2
--   </pre>
--   
--   However, there are some types that this library cannot generate
--   sensible command-line parsers for, such as:
--   
--   <ul>
--   <li>recursive types:<pre>data Example = Example { foo :: Example
--   }</pre></li>
--   <li>records whose fields are other records<pre>data Outer = Outer {
--   foo :: Inner } deriving (Show, Generic) data Inner = Inner { bar ::
--   Int } deriving (Show, Generic)</pre></li>
--   <li>record fields with nested <a>Maybe</a>s or nested lists<pre>data
--   Example = Example { foo :: Maybe (Maybe Int) } data Example = Example
--   { foo :: [[Int]] }</pre></li>
--   </ul>
--   
--   If you try to auto-generate a parser for these types you will get an
--   error at compile time that will look something like this:
--   
--   <pre>
--   No instance for (ParseFields TheTypeOfYourField)
--     arising from a use of ‘Options.Generic.$gdmparseRecord’
--   In the expression: Options.Generic.$gdmparseRecord
--   In an equation for ‘parseRecord’:
--       parseRecord = Options.Generic.$gdmparseRecord
--   In the instance declaration for ‘ParseRecord TheTypeOfYourRecord’
--   </pre>
--   
--   You can customize the library's default behavior using the
--   <a>parseRecordWithModifiers</a> utility, like this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Options.Generic
--   
--   data Example = Example { foo :: Int, bar :: Double }
--       deriving (Generic, Show)
--   
--   modifiers :: Modifiers
--   modifiers = defaultModifiers
--       { shortNameModifier = firstLetter
--       }
--   
--   instance ParseRecord Example where
--       parseRecord = parseRecordWithModifiers modifiers
--   
--   main = do
--       x &lt;- getRecord "Test program"
--       print (x :: Example)
--   </pre>
module Options.Generic

-- | Marshal any value that implements <a>ParseRecord</a> from the command
--   line
--   
--   If you need to modify the top-level <tt>ParserInfo</tt> or
--   <tt>ParserPrefs</tt> use the <a>getRecordWith</a> function.
getRecord :: (MonadIO io, ParseRecord a) => Text -> io a

-- | Marshal any value that implements <a>ParseRecord</a> from the command
--   line
--   
--   This is the lower-level sibling of 'getRecord and lets you modify the
--   <tt>ParserInfo</tt> and <tt>ParserPrefs</tt> records.
getRecordWith :: (MonadIO io, ParseRecord a) => InfoMod a -> PrefsMod -> io a

-- | Marshal any value that implements <a>ParseRecord</a> from the commmand
--   line alongside an io action that prints the help message.
getWithHelpWith :: (MonadIO io, ParseRecord a) => Text -> PrefsMod -> io (a, io ())

-- | Marshal any value that implements <a>ParseRecord</a> from the commmand
--   line alongside an io action that prints the help message.
getWithHelp :: (MonadIO io, ParseRecord a) => Text -> io (a, io ())

-- | Pure version of <a>getRecord</a>
--   
--   If you need to modify the parser's <tt>ParserInfo</tt> or
--   <tt>ParserPrefs</tt>, use <a>getRecordPureWith</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; getRecordPure ["1"] :: Maybe Int
--   Just 1
--   
--   &gt;&gt;&gt; getRecordPure ["1", "2"] :: Maybe [Int]
--   Just [1,2]
--   
--   &gt;&gt;&gt; getRecordPure ["Foo"] :: Maybe Int
--   Nothing
--   </pre>
getRecordPure :: ParseRecord a => [Text] -> Maybe a

-- | Pure version of <a>getRecordWith</a>
--   
--   Like <a>getRecordWith</a>, this is a sibling of 'getRecordPure and
--   exposes the monoidal modifier structures for <tt>ParserInfo</tt> and
--   <tt>ParserPrefs</tt> to you.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; getRecordPureWith ["1"] mempty mempty :: Maybe Int
--   Just 1
--   
--   &gt;&gt;&gt; getRecordPureWith ["1", "2"] mempty mempty :: Maybe [Int]
--   Just [1,2]
--   
--   &gt;&gt;&gt; getRecordPureWith ["Foo"] mempty mempty :: Maybe Int
--   Nothing
--   </pre>
getRecordPureWith :: ParseRecord a => [Text] -> InfoMod a -> PrefsMod -> Maybe a

-- | Marshal any value that implements <a>ParseRecord</a> from the command
--   line and unwrap its fields
unwrapRecord :: (Functor io, MonadIO io, ParseRecord (f Wrapped), Unwrappable f) => Text -> io (f Unwrapped)

-- | Marshal any value that implements <a>ParseRecord</a> from the command
--   line and unwrap its fields alongside an io action to print the help
--   message
unwrapWithHelp :: (MonadIO io, ParseRecord (f Wrapped), Unwrappable f) => Text -> io (f Unwrapped, io ())

-- | Pure version of <a>unwrapRecord</a>
unwrapRecordPure :: (ParseRecord (f Wrapped), Unwrappable f) => [Text] -> Maybe (f Unwrapped)

-- | Unwrap the fields of a constructor
unwrap :: forall f. Unwrappable f => f Wrapped -> f Unwrapped

-- | A class for types that can be parsed from the command line
--   
--   This class has a default implementation for any type that implements
--   <a>Generic</a> and you can derive <a>Generic</a> for many types by
--   enabling the <tt>DeriveGeneric</tt> language extension
--   
--   You can also use <a>getOnly</a> to create a <a>ParseRecord</a>
--   instance from a <a>ParseFields</a> instance:
--   
--   <pre>
--   instance ParseRecord MyType where
--       parseRecord = fmap getOnly parseRecord
--   </pre>
class ParseRecord a
parseRecord :: ParseRecord a => Parser a
parseRecord :: (ParseRecord a, Generic a, GenericParseRecord (Rep a)) => Parser a

-- | A class for all types that can be parsed from zero or more
--   arguments/options on the command line
--   
--   <a>parseFields</a> has a default implementation for any type that
--   implements <a>ParseField</a>
class ParseRecord a => ParseFields a
parseFields :: ParseFields a => Maybe Text -> Maybe Text -> Maybe Char -> Maybe String -> Parser a
parseFields :: (ParseFields a, ParseField a) => Maybe Text -> Maybe Text -> Maybe Char -> Maybe String -> Parser a

-- | A class for all record fields that can be parsed from exactly one
--   option or argument on the command line
--   
--   <a>parseField</a> has a default implementation for any type that
--   implements <a>Read</a> and <a>Typeable</a>. You can derive <a>Read</a>
--   for many types and you can derive <a>Typeable</a> for any type if you
--   enable the <tt>DeriveDataTypeable</tt> language extension
class ParseField a
parseField :: ParseField a => Maybe Text -> Maybe Text -> Maybe Char -> Maybe String -> Parser a
parseField :: ParseField a => Maybe Text -> Maybe Text -> Maybe Char -> Maybe String -> Parser a

-- | The only reason for this method is to provide a special case for
--   handling <a>String</a>s. All other instances should just fall back on
--   the default implementation for <a>parseListOfField</a>
parseListOfField :: ParseField a => Maybe Text -> Maybe Text -> Maybe Char -> Maybe String -> Parser [a]
readField :: ParseField a => ReadM a
readField :: (ParseField a, Read a) => ReadM a
metavar :: ParseField a => proxy a -> String
metavar :: (ParseField a, Typeable a) => proxy a -> String
newtype () => Only a
Only :: a -> Only a
[fromOnly] :: Only a -> a

-- | This is a convenience function that you can use if you want to create
--   a <a>ParseRecord</a> instance that just defers to the
--   <a>ParseFields</a> instance for the same type:
--   
--   <pre>
--   instance ParseRecord MyType where
--       parseRecord = fmap getOnly parseRecord
--   </pre>
getOnly :: Only a -> a
readIntegralBounded :: forall a. (Integral a, Bounded a, Typeable a, ParseField a) => ReadM a

-- | Options for customizing derived <a>ParseRecord</a> implementations for
--   <a>Generic</a> types
--   
--   You can either create the <a>Modifiers</a> record directly:
--   
--   <pre>
--   modifiers :: Modifiers
--   modifiers = Modifiers
--       { fieldNameModifier       = ...
--       , constructorNameModifier = ...
--       , shortNameModifier       = ...
--       }
--   </pre>
--   
--   ... or you can tweak the <a>defaultModifiers</a>:
--   
--   <pre>
--   modifiers :: Modifiers
--   modifiers = defaultModifiers { fieldNameModifier = ... }
--   </pre>
--   
--   ... or you can use/tweak a predefined <tt>Modifier</tt>, like
--   <a>lispCaseModifiers</a>
--   
--   The <a>parseRecordWithModifiers</a> function uses this
--   <a>Modifiers</a> record when generating a <a>Generic</a>
--   implementation of <a>ParseRecord</a>
data Modifiers
Modifiers :: (String -> String) -> (String -> String) -> (String -> Maybe Char) -> Modifiers

-- | Transform the name of derived fields (Default: <tt>id</tt>)
[fieldNameModifier] :: Modifiers -> String -> String

-- | Transform the name of derived constructors (Default: <tt>map
--   toLower</tt>)
[constructorNameModifier] :: Modifiers -> String -> String

-- | Derives an optional short name from the field name (Default: <tt>\_
--   -&gt; Nothing</tt>)
[shortNameModifier] :: Modifiers -> String -> Maybe Char

-- | Use <a>parseRecordWithModifiers</a> when you want to tweak the
--   behavior of a derived <a>ParseRecord</a> implementation, like this:
--   
--   <pre>
--   myModifiers :: Modifiers
--   myModifiers = defaultModifiers { constructorNameModifier = id }
--   
--   instance ParseRecord MyType where
--       parseRecord = parseRecordWithModifiers myModifiers
--   </pre>
--   
--   This will still require that you derive <a>Generic</a> for your type
--   to automate most of the implementation, but the <a>Modifiers</a> that
--   you pass will change how the implementation generates the command line
--   interface
parseRecordWithModifiers :: (Generic a, GenericParseRecord (Rep a)) => Modifiers -> Parser a

-- | These are the default modifiers used if you derive a <a>Generic</a>
--   implementation. You can customize this and pass the result to
--   <a>parseRecordWithModifiers</a> if you would like to modify the
--   derived implementation:
--   
--   <pre>
--   myModifiers :: Modifiers
--   myModifiers = defaultModifiers { constructorNameModifier = id }
--   
--   instance ParseRecord MyType where
--       parseRecord = parseRecordWithModifiers myModifiers
--   </pre>
defaultModifiers :: Modifiers

-- | Convert field and constructor names from <tt>CamelCase</tt> to
--   <tt>lisp-case</tt>.
--   
--   Leading underscores are dropped, allowing one to use option names
--   which are Haskell keywords or otherwise conflicting identifiers.
--   
--   <pre>
--   BuildCommand -&gt; build-command
--   someFlag -&gt; --some-flag
--   _type -&gt; --type
--   _splitAt -&gt; --split-at
--   </pre>
lispCaseModifiers :: Modifiers

-- | Use this for the <a>shortNameModifier</a> field of the
--   <a>Modifiers</a> record if you want to use the first letter of each
--   option as the short name
firstLetter :: String -> Maybe Char
class GenericParseRecord f
genericParseRecord :: GenericParseRecord f => Modifiers -> Parser (f p)

-- | Use this to annotate a field with a type-level string (i.e. a
--   <a>Symbol</a>) representing the help description for that field:
--   
--   <pre>
--   data Example = Example
--       { foo :: Int    &lt;?&gt; "Documentation for the foo flag"
--       , bar :: Double &lt;?&gt; "Documentation for the bar flag"
--       } deriving (Generic, Show)
--   </pre>
newtype (<?>) field (help :: Symbol)
Helpful :: field -> (<?>) field (help :: Symbol)
[unHelpful] :: (<?>) field (help :: Symbol) -> field

-- | Use this to annotate a field with a type-level string (i.e. a
--   <a>Symbol</a>) representing the default value for that field:
--   
--   <pre>
--   data Example = Example
--       { foo :: Int    &lt;!&gt; "1"
--       , bar :: Double &lt;!&gt; "0.5"
--       } deriving (Generic, Show)
--   </pre>
newtype (<!>) field (value :: Symbol)
DefValue :: field -> (<!>) field (value :: Symbol)
[unDefValue] :: (<!>) field (value :: Symbol) -> field

-- | Use this to annotate a field with a type-level char (i.e. a
--   <a>Symbol</a>) representing the short name of the field (only the
--   first character of the symbol is used):
--   
--   <pre>
--   data Example = Example
--       { foo :: Int    &lt;#&gt; "f"
--       , bar :: Double &lt;#&gt; "b"
--       } deriving (Generic, Show)
--   </pre>
newtype (<#>) field (value :: Symbol)
ShortName :: field -> (<#>) field (value :: Symbol)
[unShortName] :: (<#>) field (value :: Symbol) -> field

-- | A type family to extract fields wrapped using <a>(&lt;?&gt;)</a>
type family (:::) wrap wrapped
infixr 0 :::

-- | Flag to keep fields wrapped
data Wrapped

-- | Flag to unwrap fields annotated using <a>(&lt;?&gt;)</a>
data Unwrapped

-- | Constraint for types whose fields can be unwrapped
type Unwrappable f = (Generic (f Wrapped), Generic (f Unwrapped), GenericUnwrappable (Rep (f Wrapped)) (Rep (f Unwrapped)))

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype () => All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype () => Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Maybe monoid returning the leftmost non-<a>Nothing</a> value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Beware that <tt>Data.Monoid.</tt><a>First</a> is different from
--   <tt>Data.Semigroup.</tt><a>First</a>. The former returns the first
--   non-<a>Nothing</a>, so <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>. The latter simply returns the first value, thus
--   <tt>Data.Semigroup.First Nothing &lt;&gt; x = Data.Semigroup.First
--   Nothing</tt>.
newtype () => First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-<a>Nothing</a> value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
--   
--   Beware that <tt>Data.Monoid.</tt><a>Last</a> is different from
--   <tt>Data.Semigroup.</tt><a>Last</a>. The former returns the last
--   non-<a>Nothing</a>, so <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>. The latter simply returns the last value, thus <tt>x &lt;&gt;
--   Data.Semigroup.Last Nothing = Data.Semigroup.Last Nothing</tt>.
newtype () => Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype () => Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype () => Product a
Product :: a -> Product a
[getProduct] :: Product a -> a
instance GHC.Classes.Eq field => GHC.Classes.Eq (field Options.Generic.<?> help)
instance (GHC.TypeLits.KnownSymbol help, Data.Data.Data field) => Data.Data.Data (field Options.Generic.<?> help)
instance GHC.Show.Show field => GHC.Show.Show (field Options.Generic.<?> help)
instance GHC.Generics.Generic (field Options.Generic.<?> help)
instance GHC.Classes.Eq field => GHC.Classes.Eq (field Options.Generic.<!> value)
instance (GHC.TypeLits.KnownSymbol value, Data.Data.Data field) => Data.Data.Data (field Options.Generic.<!> value)
instance GHC.Show.Show field => GHC.Show.Show (field Options.Generic.<!> value)
instance GHC.Generics.Generic (field Options.Generic.<!> value)
instance GHC.Classes.Eq field => GHC.Classes.Eq (field Options.Generic.<#> value)
instance (GHC.TypeLits.KnownSymbol value, Data.Data.Data field) => Data.Data.Data (field Options.Generic.<#> value)
instance GHC.Show.Show field => GHC.Show.Show (field Options.Generic.<#> value)
instance GHC.Generics.Generic (field Options.Generic.<#> value)
instance GHC.Show.Show a => GHC.Show.Show (Options.Generic.Only_ a)
instance GHC.Generics.Generic (Options.Generic.Only_ a)
instance Data.Data.Data Options.Generic.Unwrapped
instance Options.Generic.GenericUnwrappable GHC.Generics.U1 GHC.Generics.U1
instance Options.Generic.GenericUnwrappable f f' => Options.Generic.GenericUnwrappable (GHC.Generics.M1 i c f) (GHC.Generics.M1 i c f')
instance (Options.Generic.GenericUnwrappable f f', Options.Generic.GenericUnwrappable g g') => Options.Generic.GenericUnwrappable (f GHC.Generics.:+: g) (f' GHC.Generics.:+: g')
instance (Options.Generic.GenericUnwrappable f f', Options.Generic.GenericUnwrappable g g') => Options.Generic.GenericUnwrappable (f GHC.Generics.:*: g) (f' GHC.Generics.:*: g')
instance Options.Generic.GenericUnwrappable (GHC.Generics.K1 i c) (GHC.Generics.K1 i c)
instance Options.Generic.GenericUnwrappable (GHC.Generics.K1 i field) (GHC.Generics.K1 i c) => Options.Generic.GenericUnwrappable (GHC.Generics.K1 i (field Options.Generic.<?> helper)) (GHC.Generics.K1 i c)
instance Options.Generic.GenericUnwrappable (GHC.Generics.K1 i field) (GHC.Generics.K1 i c) => Options.Generic.GenericUnwrappable (GHC.Generics.K1 i (field Options.Generic.<!> defVal)) (GHC.Generics.K1 i c)
instance Options.Generic.GenericUnwrappable (GHC.Generics.K1 i field) (GHC.Generics.K1 i c) => Options.Generic.GenericUnwrappable (GHC.Generics.K1 i (field Options.Generic.<#> defVal)) (GHC.Generics.K1 i c)
instance Options.Generic.ParseFields GHC.Types.Char
instance Options.Generic.ParseFields GHC.Types.Double
instance Options.Generic.ParseFields GHC.Types.Float
instance Options.Generic.ParseFields GHC.Types.Int
instance Options.Generic.ParseFields GHC.Int.Int8
instance Options.Generic.ParseFields GHC.Int.Int16
instance Options.Generic.ParseFields GHC.Int.Int32
instance Options.Generic.ParseFields GHC.Int.Int64
instance Options.Generic.ParseFields GHC.Num.Integer.Integer
instance Options.Generic.ParseFields GHC.Types.Ordering
instance Options.Generic.ParseFields GHC.Base.Void
instance Options.Generic.ParseFields GHC.Word.Word8
instance Options.Generic.ParseFields GHC.Word.Word16
instance Options.Generic.ParseFields GHC.Word.Word32
instance Options.Generic.ParseFields GHC.Word.Word64
instance Options.Generic.ParseFields Data.ByteString.Internal.Type.ByteString
instance Options.Generic.ParseFields Data.ByteString.Lazy.Internal.ByteString
instance Options.Generic.ParseFields Data.Text.Internal.Text
instance Options.Generic.ParseFields Data.Text.Internal.Lazy.Text
instance Options.Generic.ParseFields Data.Time.Calendar.CalendarDiffDays.CalendarDiffDays
instance Options.Generic.ParseFields Data.Time.Calendar.Days.Day
instance Options.Generic.ParseFields Data.Time.Clock.Internal.UTCTime.UTCTime
instance Options.Generic.ParseFields Data.Time.LocalTime.Internal.CalendarDiffTime.CalendarDiffTime
instance Options.Generic.ParseFields Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Options.Generic.ParseFields Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Options.Generic.ParseFields Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Options.Generic.ParseFields Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Options.Generic.ParseFields System.OsString.Internal.Types.OsString
instance Options.Generic.ParseFields GHC.Num.Natural.Natural
instance Options.Generic.ParseFields GHC.Types.Bool
instance Options.Generic.ParseFields ()
instance Options.Generic.ParseFields Data.Semigroup.Internal.Any
instance Options.Generic.ParseFields Data.Semigroup.Internal.All
instance Options.Generic.ParseField a => Options.Generic.ParseFields (GHC.Maybe.Maybe a)
instance Options.Generic.ParseField a => Options.Generic.ParseFields (Data.Monoid.First a)
instance Options.Generic.ParseField a => Options.Generic.ParseFields (Data.Monoid.Last a)
instance (GHC.Num.Num a, Options.Generic.ParseField a) => Options.Generic.ParseFields (Data.Semigroup.Internal.Sum a)
instance (GHC.Num.Num a, Options.Generic.ParseField a) => Options.Generic.ParseFields (Data.Semigroup.Internal.Product a)
instance Options.Generic.ParseField a => Options.Generic.ParseFields [a]
instance Options.Generic.ParseField a => Options.Generic.ParseFields (GHC.Base.NonEmpty a)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol h) => Options.Generic.ParseFields (a Options.Generic.<?> h)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol h) => Options.Generic.ParseRecord (a Options.Generic.<?> h)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol d) => Options.Generic.ParseFields (a Options.Generic.<!> d)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol h) => Options.Generic.ParseRecord (a Options.Generic.<!> h)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol c) => Options.Generic.ParseFields (a Options.Generic.<#> c)
instance (Options.Generic.ParseFields a, GHC.TypeLits.KnownSymbol h) => Options.Generic.ParseRecord (a Options.Generic.<#> h)
instance Options.Generic.ParseFields a => Options.Generic.ParseRecord (Options.Generic.Only_ a)
instance Options.Generic.ParseFields a => Options.Generic.ParseRecord (Data.Tuple.Only.Only a)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b) => Options.Generic.ParseRecord (a, b)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b, Options.Generic.ParseFields c) => Options.Generic.ParseRecord (a, b, c)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b, Options.Generic.ParseFields c, Options.Generic.ParseFields d) => Options.Generic.ParseRecord (a, b, c, d)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b, Options.Generic.ParseFields c, Options.Generic.ParseFields d, Options.Generic.ParseFields e) => Options.Generic.ParseRecord (a, b, c, d, e)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b, Options.Generic.ParseFields c, Options.Generic.ParseFields d, Options.Generic.ParseFields e, Options.Generic.ParseFields f) => Options.Generic.ParseRecord (a, b, c, d, e, f)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b, Options.Generic.ParseFields c, Options.Generic.ParseFields d, Options.Generic.ParseFields e, Options.Generic.ParseFields f, Options.Generic.ParseFields g) => Options.Generic.ParseRecord (a, b, c, d, e, f, g)
instance (Options.Generic.ParseFields a, Options.Generic.ParseFields b) => Options.Generic.ParseRecord (Data.Either.Either a b)
instance (GHC.Generics.Selector s, Options.Generic.ParseFields a) => Options.Generic.GenericParseRecord (GHC.Generics.M1 GHC.Generics.S s (GHC.Generics.K1 i a))
instance Options.Generic.ParseRecord GHC.Types.Char
instance Options.Generic.ParseRecord GHC.Types.Double
instance Options.Generic.ParseRecord GHC.Types.Float
instance Options.Generic.ParseRecord GHC.Types.Int
instance Options.Generic.ParseRecord GHC.Int.Int8
instance Options.Generic.ParseRecord GHC.Int.Int16
instance Options.Generic.ParseRecord GHC.Int.Int32
instance Options.Generic.ParseRecord GHC.Int.Int64
instance Options.Generic.ParseRecord GHC.Types.Ordering
instance Options.Generic.ParseRecord GHC.Base.Void
instance Options.Generic.ParseRecord GHC.Word.Word8
instance Options.Generic.ParseRecord GHC.Word.Word16
instance Options.Generic.ParseRecord GHC.Word.Word32
instance Options.Generic.ParseRecord GHC.Word.Word64
instance Options.Generic.ParseRecord ()
instance Options.Generic.ParseRecord GHC.Num.Natural.Natural
instance Options.Generic.ParseRecord GHC.Types.Bool
instance Options.Generic.ParseRecord GHC.Num.Integer.Integer
instance Options.Generic.ParseRecord Data.Text.Internal.Text
instance Options.Generic.ParseRecord Data.Text.Internal.Lazy.Text
instance Options.Generic.ParseRecord Data.Semigroup.Internal.Any
instance Options.Generic.ParseRecord Data.Semigroup.Internal.All
instance Options.Generic.ParseRecord Data.ByteString.Internal.Type.ByteString
instance Options.Generic.ParseRecord Data.ByteString.Lazy.Internal.ByteString
instance Options.Generic.ParseRecord Data.Time.Calendar.CalendarDiffDays.CalendarDiffDays
instance Options.Generic.ParseRecord Data.Time.Calendar.Days.Day
instance Options.Generic.ParseRecord Data.Time.Clock.Internal.UTCTime.UTCTime
instance Options.Generic.ParseRecord Data.Time.LocalTime.Internal.CalendarDiffTime.CalendarDiffTime
instance Options.Generic.ParseRecord Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Options.Generic.ParseRecord Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Options.Generic.ParseRecord Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Options.Generic.ParseRecord Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Options.Generic.ParseRecord System.OsString.Internal.Types.OsString
instance Options.Generic.ParseField a => Options.Generic.ParseRecord (GHC.Maybe.Maybe a)
instance Options.Generic.ParseField a => Options.Generic.ParseRecord (Data.Monoid.First a)
instance Options.Generic.ParseField a => Options.Generic.ParseRecord (Data.Monoid.Last a)
instance (GHC.Num.Num a, Options.Generic.ParseField a) => Options.Generic.ParseRecord (Data.Semigroup.Internal.Sum a)
instance (GHC.Num.Num a, Options.Generic.ParseField a) => Options.Generic.ParseRecord (Data.Semigroup.Internal.Product a)
instance Options.Generic.ParseField a => Options.Generic.ParseRecord [a]
instance Options.Generic.ParseField a => Options.Generic.ParseRecord (GHC.Base.NonEmpty a)
instance Options.Generic.GenericParseRecord GHC.Generics.U1
instance Options.Generic.GenericParseRecord f => Options.Generic.GenericParseRecord (GHC.Generics.M1 GHC.Generics.C c f)
instance (Options.Generic.GenericParseRecord (f GHC.Generics.:+: g), Options.Generic.GenericParseRecord (h GHC.Generics.:+: i)) => Options.Generic.GenericParseRecord ((f GHC.Generics.:+: g) GHC.Generics.:+: (h GHC.Generics.:+: i))
instance (GHC.Generics.Constructor c, Options.Generic.GenericParseRecord f, Options.Generic.GenericParseRecord (g GHC.Generics.:+: h)) => Options.Generic.GenericParseRecord (GHC.Generics.M1 GHC.Generics.C c f GHC.Generics.:+: (g GHC.Generics.:+: h))
instance (GHC.Generics.Constructor c, Options.Generic.GenericParseRecord (f GHC.Generics.:+: g), Options.Generic.GenericParseRecord h) => Options.Generic.GenericParseRecord ((f GHC.Generics.:+: g) GHC.Generics.:+: GHC.Generics.M1 GHC.Generics.C c h)
instance (GHC.Generics.Constructor c1, GHC.Generics.Constructor c2, Options.Generic.GenericParseRecord f1, Options.Generic.GenericParseRecord f2) => Options.Generic.GenericParseRecord (GHC.Generics.M1 GHC.Generics.C c1 f1 GHC.Generics.:+: GHC.Generics.M1 GHC.Generics.C c2 f2)
instance (Options.Generic.GenericParseRecord f, Options.Generic.GenericParseRecord g) => Options.Generic.GenericParseRecord (f GHC.Generics.:*: g)
instance Options.Generic.GenericParseRecord GHC.Generics.V1
instance Options.Generic.GenericParseRecord f => Options.Generic.GenericParseRecord (GHC.Generics.M1 GHC.Generics.D c f)
instance (Options.Generic.ParseField a, GHC.TypeLits.KnownSymbol c) => Options.Generic.ParseField (a Options.Generic.<#> c)
instance (Options.Generic.ParseField a, GHC.TypeLits.KnownSymbol d) => Options.Generic.ParseField (a Options.Generic.<!> d)
instance (Options.Generic.ParseField a, GHC.TypeLits.KnownSymbol h) => Options.Generic.ParseField (a Options.Generic.<?> h)
instance Options.Generic.ParseField GHC.Types.Bool
instance Options.Generic.ParseField GHC.Types.Double
instance Options.Generic.ParseField GHC.Types.Float
instance Options.Generic.ParseField GHC.Num.Integer.Integer
instance Options.Generic.ParseField GHC.Types.Ordering
instance Options.Generic.ParseField ()
instance Options.Generic.ParseField GHC.Base.Void
instance Options.Generic.ParseField GHC.Types.Int
instance Options.Generic.ParseField GHC.Int.Int8
instance Options.Generic.ParseField GHC.Int.Int16
instance Options.Generic.ParseField GHC.Int.Int32
instance Options.Generic.ParseField GHC.Int.Int64
instance Options.Generic.ParseField GHC.Word.Word8
instance Options.Generic.ParseField GHC.Word.Word16
instance Options.Generic.ParseField GHC.Word.Word32
instance Options.Generic.ParseField GHC.Word.Word64
instance Options.Generic.ParseField GHC.Num.Natural.Natural
instance Options.Generic.ParseField GHC.Base.String
instance Options.Generic.ParseField GHC.Types.Char
instance Options.Generic.ParseField Data.Semigroup.Internal.Any
instance Options.Generic.ParseField Data.Semigroup.Internal.All
instance Options.Generic.ParseField Data.Text.Internal.Text
instance Options.Generic.ParseField Data.ByteString.Internal.Type.ByteString
instance Options.Generic.ParseField Data.Text.Internal.Lazy.Text
instance Options.Generic.ParseField Data.ByteString.Lazy.Internal.ByteString
instance Options.Generic.ParseField Data.Time.Calendar.CalendarDiffDays.CalendarDiffDays
instance Options.Generic.ParseField Data.Time.Calendar.Days.Day
instance Options.Generic.ParseField Data.Time.Clock.Internal.UTCTime.UTCTime
instance Options.Generic.ParseField Data.Time.LocalTime.Internal.CalendarDiffTime.CalendarDiffTime
instance Options.Generic.ParseField Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Options.Generic.ParseField Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Options.Generic.ParseField Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Options.Generic.ParseField Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Options.Generic.ParseField System.OsString.Internal.Types.OsString
