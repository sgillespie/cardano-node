-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A web server for the Snap Framework
--   
--   Snap is a simple and fast web development framework and server written
--   in Haskell. For more information or to download the latest version,
--   you can visit the Snap project website at
--   <a>http://snapframework.com/</a>.
--   
--   The Snap HTTP server is a high performance web server library written
--   in Haskell. Together with the <tt>snap-core</tt> library upon which it
--   depends, it provides a clean and efficient Haskell programming
--   interface to the HTTP protocol.
@package snap-server
@version 1.1.2.1


-- | This module exports the <a>Config</a> datatype, which you can use to
--   configure the Snap HTTP server.
module Snap.Internal.Http.Server.Config

-- | Data type representing the configuration of a logging target
data ConfigLog

-- | no logging
ConfigNoLog :: ConfigLog

-- | log to text file
ConfigFileLog :: FilePath -> ConfigLog

-- | log custom IO handler
ConfigIoLog :: (ByteString -> IO ()) -> ConfigLog

-- | A record type which represents partial configurations (for
--   <tt>httpServe</tt>) by wrapping all of its fields in a <a>Maybe</a>.
--   Values of this type are usually constructed via its <a>Monoid</a>
--   instance by doing something like:
--   
--   <pre>
--   setPort 1234 mempty
--   </pre>
--   
--   Any fields which are unspecified in the <a>Config</a> passed to
--   <tt>httpServe</tt> (and this is the norm) are filled in with default
--   values from <a>defaultConfig</a>.
data Config m a
Config :: Maybe ByteString -> Maybe ConfigLog -> Maybe ConfigLog -> Maybe String -> Maybe Int -> Maybe ByteString -> Maybe Int -> Maybe ByteString -> Maybe FilePath -> Maybe Bool -> Maybe FilePath -> Maybe FilePath -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe (SomeException -> m ()) -> Maybe Int -> Maybe a -> Maybe ProxyType -> Maybe (StartupInfo m a -> IO ()) -> Config m a
[hostname] :: Config m a -> Maybe ByteString
[accessLog] :: Config m a -> Maybe ConfigLog
[errorLog] :: Config m a -> Maybe ConfigLog
[locale] :: Config m a -> Maybe String
[port] :: Config m a -> Maybe Int
[bind] :: Config m a -> Maybe ByteString
[sslport] :: Config m a -> Maybe Int
[sslbind] :: Config m a -> Maybe ByteString
[sslcert] :: Config m a -> Maybe FilePath
[sslchaincert] :: Config m a -> Maybe Bool
[sslkey] :: Config m a -> Maybe FilePath
[unixsocket] :: Config m a -> Maybe FilePath
[unixaccessmode] :: Config m a -> Maybe Int
[compression] :: Config m a -> Maybe Bool
[verbose] :: Config m a -> Maybe Bool
[errorHandler] :: Config m a -> Maybe (SomeException -> m ())
[defaultTimeout] :: Config m a -> Maybe Int
[other] :: Config m a -> Maybe a
[proxyType] :: Config m a -> Maybe ProxyType
[startupHook] :: Config m a -> Maybe (StartupInfo m a -> IO ())

-- | FIXME
--   
--   Note: this type changed in snap-server 1.0.0.0.
data ProxyType
NoProxy :: ProxyType
HaProxy :: ProxyType
X_Forwarded_For :: ProxyType

-- | Returns a completely empty <a>Config</a>. Equivalent to <a>mempty</a>
--   from <tt>Config'</tt>s <a>Monoid</a> instance.
emptyConfig :: Config m a

-- | These are the default values for the options
defaultConfig :: MonadSnap m => Config m a

-- | Returns a <a>Config</a> obtained from parsing command-line options,
--   using the default Snap <a>OptDescr</a> set.
--   
--   On Unix systems, the locale is read from the <tt>LANG</tt> environment
--   variable.
commandLineConfig :: MonadSnap m => Config m a -> IO (Config m a)

-- | Returns a <a>Config</a> obtained from parsing command-line options,
--   using the default Snap <a>OptDescr</a> set as well as a list of user
--   OptDescrs. User OptDescrs use the "other" field (accessible using
--   <a>getOther</a> and <a>setOther</a>) to store additional command-line
--   option state. These are combined using a user-defined combining
--   function.
--   
--   On Unix systems, the locale is read from the <tt>LANG</tt> environment
--   variable.
extendedCommandLineConfig :: MonadSnap m => [OptDescr (Maybe (Config m a))] -> (a -> a -> a) -> Config m a -> IO (Config m a)
completeConfig :: MonadSnap m => Config m a -> IO (Config m a)

-- | Returns a description of the snap command line options suitable for
--   use with <a>System.Console.GetOpt</a>.
optDescrs :: forall m a. MonadSnap m => Config m a -> [OptDescr (Maybe (Config m a))]
fmapOpt :: (a -> b) -> OptDescr a -> OptDescr b

-- | Path to the access log
getAccessLog :: Config m a -> Maybe ConfigLog

-- | Returns the address to bind to (for http)
getBind :: Config m a -> Maybe ByteString

-- | If set and set to True, compression is turned on when applicable
getCompression :: Config m a -> Maybe Bool
getDefaultTimeout :: Config m a -> Maybe Int

-- | A MonadSnap action to handle 500 errors
getErrorHandler :: Config m a -> Maybe (SomeException -> m ())

-- | Path to the error log
getErrorLog :: Config m a -> Maybe ConfigLog

-- | The hostname of the HTTP server. This field has the same format as an
--   HTTP <tt>Host</tt> header; if a <tt>Host</tt> header came in with the
--   request, we use that, otherwise we default to this value specified in
--   the configuration.
getHostname :: Config m a -> Maybe ByteString

-- | Gets the locale to use. Locales are used on Unix only, to set the
--   <tt>LANG</tt>/<tt>LC_ALL</tt>/etc. environment variable. For instance
--   if you set the locale to "<tt>en_US</tt>", we'll set the relevant
--   environment variables to "<tt>en_US.UTF-8</tt>".
getLocale :: Config m a -> Maybe String
getOther :: Config m a -> Maybe a

-- | Returns the port to listen on (for http)
getPort :: Config m a -> Maybe Int
getProxyType :: Config m a -> Maybe ProxyType

-- | Returns the address to bind to (for https)
getSSLBind :: Config m a -> Maybe ByteString

-- | Path to the SSL certificate file
getSSLCert :: Config m a -> Maybe FilePath

-- | Path to the SSL certificate file
getSSLChainCert :: Config m a -> Maybe Bool

-- | Path to the SSL key file
getSSLKey :: Config m a -> Maybe FilePath

-- | Returns the port to listen on (for https)
getSSLPort :: Config m a -> Maybe Int

-- | Whether to write server status updates to stderr
getVerbose :: Config m a -> Maybe Bool

-- | A startup hook is run after the server initializes but before user
--   request processing begins. The server passes, through a
--   <a>StartupInfo</a> object, the startup hook a list of the sockets it
--   is listening on and the final <a>Config</a> object completed after
--   command-line processing.
getStartupHook :: Config m a -> Maybe (StartupInfo m a -> IO ())

-- | File path to unix socket. Must be absolute path, but allows for
--   symbolic links.
getUnixSocket :: Config m a -> Maybe FilePath

-- | Access mode for unix socket, by default is system specific. This
--   should only be used to grant additional permissions to created socket
--   file, and not to remove permissions set by default. The only portable
--   way to limit access to socket is creating it in a directory with
--   proper permissions set.
--   
--   Most BSD systems ignore access permissions on unix sockets.
--   
--   Note: This uses umask. There is a race condition if process creates
--   other files at the same time as opening a unix socket with this option
--   set.
getUnixSocketAccessMode :: Config m a -> Maybe Int
setAccessLog :: ConfigLog -> Config m a -> Config m a
setBind :: ByteString -> Config m a -> Config m a
setCompression :: Bool -> Config m a -> Config m a
setDefaultTimeout :: Int -> Config m a -> Config m a
setErrorHandler :: (SomeException -> m ()) -> Config m a -> Config m a
setErrorLog :: ConfigLog -> Config m a -> Config m a
setHostname :: ByteString -> Config m a -> Config m a
setLocale :: String -> Config m a -> Config m a
setOther :: a -> Config m a -> Config m a
setPort :: Int -> Config m a -> Config m a
setProxyType :: ProxyType -> Config m a -> Config m a
setSSLBind :: ByteString -> Config m a -> Config m a
setSSLCert :: FilePath -> Config m a -> Config m a
setSSLChainCert :: Bool -> Config m a -> Config m a
setSSLKey :: FilePath -> Config m a -> Config m a
setSSLPort :: Int -> Config m a -> Config m a
setVerbose :: Bool -> Config m a -> Config m a
setUnixSocket :: FilePath -> Config m a -> Config m a
setUnixSocketAccessMode :: Int -> Config m a -> Config m a
setStartupHook :: (StartupInfo m a -> IO ()) -> Config m a -> Config m a

-- | Arguments passed to <a>setStartupHook</a>.
data StartupInfo m a
StartupInfo :: Config m a -> [Socket] -> StartupInfo m a
[startupHookConfig] :: StartupInfo m a -> Config m a
[startupHookSockets] :: StartupInfo m a -> [Socket]

-- | The <a>Socket</a>s opened by the server. There will be two
--   <a>Socket</a>s for SSL connections, and one otherwise.
getStartupSockets :: StartupInfo m a -> [Socket]
getStartupConfig :: StartupInfo m a -> Config m a
emptyStartupInfo :: StartupInfo m a
setStartupSockets :: [Socket] -> StartupInfo m a -> StartupInfo m a
setStartupConfig :: Config m a -> StartupInfo m a -> StartupInfo m a
instance GHC.Classes.Eq Snap.Internal.Http.Server.Config.ProxyType
instance GHC.Show.Show Snap.Internal.Http.Server.Config.ProxyType
instance GHC.Show.Show (Snap.Internal.Http.Server.Config.Config m a)
instance GHC.Base.Semigroup (Snap.Internal.Http.Server.Config.Config m a)
instance GHC.Base.Monoid (Snap.Internal.Http.Server.Config.Config m a)
instance GHC.Show.Show Snap.Internal.Http.Server.Config.ConfigLog


-- | This module exports the <a>Config</a> datatype, which you can use to
--   configure the Snap HTTP server.
module Snap.Http.Server.Config

-- | A record type which represents partial configurations (for
--   <tt>httpServe</tt>) by wrapping all of its fields in a <a>Maybe</a>.
--   Values of this type are usually constructed via its <a>Monoid</a>
--   instance by doing something like:
--   
--   <pre>
--   setPort 1234 mempty
--   </pre>
--   
--   Any fields which are unspecified in the <a>Config</a> passed to
--   <tt>httpServe</tt> (and this is the norm) are filled in with default
--   values from <a>defaultConfig</a>.
data Config m a

-- | Data type representing the configuration of a logging target
data ConfigLog

-- | no logging
ConfigNoLog :: ConfigLog

-- | log to text file
ConfigFileLog :: FilePath -> ConfigLog

-- | log custom IO handler
ConfigIoLog :: (ByteString -> IO ()) -> ConfigLog

-- | FIXME
--   
--   Note: this type changed in snap-server 1.0.0.0.
data ProxyType

-- | Returns a completely empty <a>Config</a>. Equivalent to <a>mempty</a>
--   from <tt>Config'</tt>s <a>Monoid</a> instance.
emptyConfig :: Config m a

-- | These are the default values for the options
defaultConfig :: MonadSnap m => Config m a

-- | Returns a <a>Config</a> obtained from parsing command-line options,
--   using the default Snap <a>OptDescr</a> set.
--   
--   On Unix systems, the locale is read from the <tt>LANG</tt> environment
--   variable.
commandLineConfig :: MonadSnap m => Config m a -> IO (Config m a)

-- | Returns a <a>Config</a> obtained from parsing command-line options,
--   using the default Snap <a>OptDescr</a> set as well as a list of user
--   OptDescrs. User OptDescrs use the "other" field (accessible using
--   <a>getOther</a> and <a>setOther</a>) to store additional command-line
--   option state. These are combined using a user-defined combining
--   function.
--   
--   On Unix systems, the locale is read from the <tt>LANG</tt> environment
--   variable.
extendedCommandLineConfig :: MonadSnap m => [OptDescr (Maybe (Config m a))] -> (a -> a -> a) -> Config m a -> IO (Config m a)
completeConfig :: MonadSnap m => Config m a -> IO (Config m a)

-- | Returns a description of the snap command line options suitable for
--   use with <a>System.Console.GetOpt</a>.
optDescrs :: forall m a. MonadSnap m => Config m a -> [OptDescr (Maybe (Config m a))]
fmapOpt :: (a -> b) -> OptDescr a -> OptDescr b

-- | Path to the access log
getAccessLog :: Config m a -> Maybe ConfigLog

-- | Returns the address to bind to (for http)
getBind :: Config m a -> Maybe ByteString

-- | If set and set to True, compression is turned on when applicable
getCompression :: Config m a -> Maybe Bool
getDefaultTimeout :: Config m a -> Maybe Int

-- | A MonadSnap action to handle 500 errors
getErrorHandler :: Config m a -> Maybe (SomeException -> m ())

-- | Path to the error log
getErrorLog :: Config m a -> Maybe ConfigLog

-- | The hostname of the HTTP server. This field has the same format as an
--   HTTP <tt>Host</tt> header; if a <tt>Host</tt> header came in with the
--   request, we use that, otherwise we default to this value specified in
--   the configuration.
getHostname :: Config m a -> Maybe ByteString

-- | Gets the locale to use. Locales are used on Unix only, to set the
--   <tt>LANG</tt>/<tt>LC_ALL</tt>/etc. environment variable. For instance
--   if you set the locale to "<tt>en_US</tt>", we'll set the relevant
--   environment variables to "<tt>en_US.UTF-8</tt>".
getLocale :: Config m a -> Maybe String
getOther :: Config m a -> Maybe a

-- | Returns the port to listen on (for http)
getPort :: Config m a -> Maybe Int
getProxyType :: Config m a -> Maybe ProxyType

-- | Returns the address to bind to (for https)
getSSLBind :: Config m a -> Maybe ByteString

-- | Path to the SSL certificate file
getSSLCert :: Config m a -> Maybe FilePath

-- | Path to the SSL key file
getSSLKey :: Config m a -> Maybe FilePath

-- | Path to the SSL certificate file
getSSLChainCert :: Config m a -> Maybe Bool

-- | Returns the port to listen on (for https)
getSSLPort :: Config m a -> Maybe Int

-- | Whether to write server status updates to stderr
getVerbose :: Config m a -> Maybe Bool

-- | A startup hook is run after the server initializes but before user
--   request processing begins. The server passes, through a
--   <a>StartupInfo</a> object, the startup hook a list of the sockets it
--   is listening on and the final <a>Config</a> object completed after
--   command-line processing.
getStartupHook :: Config m a -> Maybe (StartupInfo m a -> IO ())

-- | File path to unix socket. Must be absolute path, but allows for
--   symbolic links.
getUnixSocket :: Config m a -> Maybe FilePath

-- | Access mode for unix socket, by default is system specific. This
--   should only be used to grant additional permissions to created socket
--   file, and not to remove permissions set by default. The only portable
--   way to limit access to socket is creating it in a directory with
--   proper permissions set.
--   
--   Most BSD systems ignore access permissions on unix sockets.
--   
--   Note: This uses umask. There is a race condition if process creates
--   other files at the same time as opening a unix socket with this option
--   set.
getUnixSocketAccessMode :: Config m a -> Maybe Int
setAccessLog :: ConfigLog -> Config m a -> Config m a
setBind :: ByteString -> Config m a -> Config m a
setCompression :: Bool -> Config m a -> Config m a
setDefaultTimeout :: Int -> Config m a -> Config m a
setErrorHandler :: (SomeException -> m ()) -> Config m a -> Config m a
setErrorLog :: ConfigLog -> Config m a -> Config m a
setHostname :: ByteString -> Config m a -> Config m a
setLocale :: String -> Config m a -> Config m a
setOther :: a -> Config m a -> Config m a
setPort :: Int -> Config m a -> Config m a
setProxyType :: ProxyType -> Config m a -> Config m a
setSSLBind :: ByteString -> Config m a -> Config m a
setSSLCert :: FilePath -> Config m a -> Config m a
setSSLKey :: FilePath -> Config m a -> Config m a
setSSLChainCert :: Bool -> Config m a -> Config m a
setSSLPort :: Int -> Config m a -> Config m a
setVerbose :: Bool -> Config m a -> Config m a
setUnixSocket :: FilePath -> Config m a -> Config m a
setUnixSocketAccessMode :: Int -> Config m a -> Config m a
setStartupHook :: (StartupInfo m a -> IO ()) -> Config m a -> Config m a

-- | Arguments passed to <a>setStartupHook</a>.
data StartupInfo m a

-- | The <a>Socket</a>s opened by the server. There will be two
--   <a>Socket</a>s for SSL connections, and one otherwise.
getStartupSockets :: StartupInfo m a -> [Socket]
getStartupConfig :: StartupInfo m a -> Config m a

-- | Configure Snap in direct / non-proxying mode.
noProxy :: ProxyType

-- | Assert that Snap is running behind an HTTP proxy, and that the proxied
--   connection information will be stored in the "X-Forwarded-For" or
--   "Forwarded-For" HTTP headers.
xForwardedFor :: ProxyType

-- | Assert that Snap is running behind a proxy running the HaProxy
--   protocol (see
--   <a>http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt</a>). In
--   this mode connections that don't obey the proxy protocol are rejected.
haProxy :: ProxyType


-- | Types internal to the implementation of the Snap HTTP server.
module Snap.Internal.Http.Server.Types

-- | Data and services that all HTTP response handlers share.
data ServerConfig hookState
ServerConfig :: !Request -> Response -> Word64 -> IO () -> !Builder -> IO () -> !NewRequestHook hookState -> !ParseHook hookState -> !UserHandlerFinishedHook hookState -> !DataFinishedHook hookState -> !ExceptionHook hookState -> !EscapeSnapHook hookState -> !ByteString -> {-# UNPACK #-} !Int -> !Bool -> {-# UNPACK #-} !Int -> ServerConfig hookState
[_logAccess] :: ServerConfig hookState -> !Request -> Response -> Word64 -> IO ()
[_logError] :: ServerConfig hookState -> !Builder -> IO ()
[_onNewRequest] :: ServerConfig hookState -> !NewRequestHook hookState
[_onParse] :: ServerConfig hookState -> !ParseHook hookState
[_onUserHandlerFinished] :: ServerConfig hookState -> !UserHandlerFinishedHook hookState
[_onDataFinished] :: ServerConfig hookState -> !DataFinishedHook hookState
[_onException] :: ServerConfig hookState -> !ExceptionHook hookState
[_onEscape] :: ServerConfig hookState -> !EscapeSnapHook hookState

-- | will be overridden by a <tt>Host</tt> header if it appears.
[_localHostname] :: ServerConfig hookState -> !ByteString
[_defaultTimeout] :: ServerConfig hookState -> {-# UNPACK #-} !Int
[_isSecure] :: ServerConfig hookState -> !Bool

-- | Number of accept loops to spawn.
[_numAcceptLoops] :: ServerConfig hookState -> {-# UNPACK #-} !Int

-- | All of the things a session needs to service a single HTTP request.
data PerSessionData
PerSessionData :: {-# UNPACK #-} !IORef Bool -> !(Int -> Int) -> IO () -> !IORef Bool -> !SendFileHandler -> !ByteString -> {-# UNPACK #-} !Int -> !ByteString -> {-# UNPACK #-} !Int -> !InputStream ByteString -> !OutputStream ByteString -> PerSessionData

-- | If the bool stored in this IORef becomes true, the server will close
--   the connection after the current request is processed.
[_forceConnectionClose] :: PerSessionData -> {-# UNPACK #-} !IORef Bool

-- | An IO action to modify the current request timeout.
[_twiddleTimeout] :: PerSessionData -> !(Int -> Int) -> IO ()

-- | The value stored in this IORef is True if this request is the first on
--   a new connection, and False if it is a subsequent keep-alive request.
[_isNewConnection] :: PerSessionData -> !IORef Bool

-- | The function called when we want to use <tt>sendfile().</tt>
[_sendfileHandler] :: PerSessionData -> !SendFileHandler

-- | The server's idea of its local address.
[_localAddress] :: PerSessionData -> !ByteString

-- | The listening port number.
[_localPort] :: PerSessionData -> {-# UNPACK #-} !Int

-- | The address of the remote user.
[_remoteAddress] :: PerSessionData -> !ByteString

-- | The remote user's port.
[_remotePort] :: PerSessionData -> {-# UNPACK #-} !Int

-- | The read end of the socket connection.
[_readEnd] :: PerSessionData -> !InputStream ByteString

-- | The write end of the socket connection.
[_writeEnd] :: PerSessionData -> !OutputStream ByteString

-- | The <a>DataFinishedHook</a> is called once the server has finished
--   sending the HTTP response to the client.
type DataFinishedHook hookState = IORef hookState -> Request -> Response -> IO ()

-- | The <a>EscapeSnapHook</a> is called if the user handler escapes the
--   HTTP session, e.g. for websockets.
type EscapeSnapHook hookState = IORef hookState -> IO ()

-- | The <a>ExceptionHook</a> is called if an exception reaches the
--   toplevel of the server, i.e. if an exception leaks out of the user
--   handler or if an exception is raised during the sending of the HTTP
--   response data.
type ExceptionHook hookState = IORef hookState -> SomeException -> IO ()

-- | The <a>ParseHook</a> is called after the HTTP Request has been parsed
--   by the server, but before the user handler starts running.
type ParseHook hookState = IORef hookState -> Request -> IO ()

-- | The <a>NewRequestHook</a> is called once processing for an HTTP
--   request begins, i.e. after the connection has been accepted and we
--   know that there's data available to read from the socket. The IORef
--   passed to the hook initially contains a bottom value that will throw
--   an exception if evaluated.
type NewRequestHook hookState = PerSessionData -> IO hookState

-- | The <a>UserHandlerFinishedHook</a> is called once the user handler has
--   finished running, but before the data for the HTTP response starts
--   being sent to the client.
type UserHandlerFinishedHook hookState = IORef hookState -> Request -> Response -> IO ()

-- | A <a>SendFileHandler</a> is called if the user handler requests that a
--   file be sent using <tt>sendfile()</tt> on systems that support it
--   (Linux, Mac OSX, and FreeBSD).
type SendFileHandler = -- | builder buffer Buffer -> -- | status line and headers Builder -> -- | file to send FilePath -> -- | start offset Word64 -> -- | number of bytes Word64 -> IO ()

-- | This function, provided to the web server internals from the outside,
--   is responsible for producing a <a>Response</a> once the server has
--   parsed the <a>Request</a>.
type ServerHandler hookState = -- | global server config ServerConfig hookState -> -- | per-connection data PerSessionData -> -- | HTTP request object Request -> IO (Request, Response)
newtype AcceptFunc
AcceptFunc :: ((forall a. IO a -> IO a) -> IO (SendFileHandler, ByteString, Int, ByteString, Int, InputStream ByteString, OutputStream ByteString, IO ())) -> AcceptFunc
[runAcceptFunc] :: AcceptFunc -> (forall a. IO a -> IO a) -> IO (SendFileHandler, ByteString, Int, ByteString, Int, InputStream ByteString, OutputStream ByteString, IO ())

-- | Either the server should start listening on the given interface / port
--   combination, or the server should start up with a <a>Socket</a> that
--   has already had <tt>bind()</tt> and <tt>listen()</tt> called on it.
data SocketConfig
StartListening :: ByteString -> Int -> SocketConfig
PreBound :: Socket -> SocketConfig


-- | Types used by the Snap HTTP Server.
module Snap.Http.Server.Types

-- | Data and services that all HTTP response handlers share.
data ServerConfig hookState

-- | All of the things a session needs to service a single HTTP request.
data PerSessionData
emptyServerConfig :: ServerConfig a
getDefaultTimeout :: ServerConfig hookState -> Int
getIsSecure :: ServerConfig hookState -> Bool
getLocalHostname :: ServerConfig hookState -> ByteString
getLogAccess :: ServerConfig hookState -> Request -> Response -> Word64 -> IO ()
getLogError :: ServerConfig hookState -> Builder -> IO ()
getNumAcceptLoops :: ServerConfig hookState -> Int
getOnDataFinished :: ServerConfig hookState -> DataFinishedHook hookState
getOnEscape :: ServerConfig hookState -> EscapeSnapHook hookState
getOnException :: ServerConfig hookState -> ExceptionHook hookState
getOnNewRequest :: ServerConfig hookState -> NewRequestHook hookState
getOnParse :: ServerConfig hookState -> ParseHook hookState
getOnUserHandlerFinished :: ServerConfig hookState -> UserHandlerFinishedHook hookState
setDefaultTimeout :: Int -> ServerConfig hookState -> ServerConfig hookState
setIsSecure :: Bool -> ServerConfig hookState -> ServerConfig hookState
setLocalHostname :: ByteString -> ServerConfig hookState -> ServerConfig hookState
setLogAccess :: (Request -> Response -> Word64 -> IO ()) -> ServerConfig hookState -> ServerConfig hookState
setLogError :: (Builder -> IO ()) -> ServerConfig hookState -> ServerConfig hookState
setNumAcceptLoops :: Int -> ServerConfig hookState -> ServerConfig hookState
setOnDataFinished :: DataFinishedHook hookState -> ServerConfig hookState -> ServerConfig hookState
setOnEscape :: EscapeSnapHook hookState -> ServerConfig hookState -> ServerConfig hookState
setOnException :: ExceptionHook hookState -> ServerConfig hookState -> ServerConfig hookState
setOnNewRequest :: NewRequestHook hookState -> ServerConfig hookState -> ServerConfig hookState
setOnParse :: ParseHook hookState -> ServerConfig hookState -> ServerConfig hookState
setOnUserHandlerFinished :: UserHandlerFinishedHook hookState -> ServerConfig hookState -> ServerConfig hookState
getTwiddleTimeout :: PerSessionData -> (Int -> Int) -> IO ()
isNewConnection :: PerSessionData -> IO Bool
getLocalAddress :: PerSessionData -> ByteString
getLocalPort :: PerSessionData -> Int
getRemoteAddress :: PerSessionData -> ByteString
getRemotePort :: PerSessionData -> Int

-- | The <a>DataFinishedHook</a> is called once the server has finished
--   sending the HTTP response to the client.
type DataFinishedHook hookState = IORef hookState -> Request -> Response -> IO ()

-- | The <a>EscapeSnapHook</a> is called if the user handler escapes the
--   HTTP session, e.g. for websockets.
type EscapeSnapHook hookState = IORef hookState -> IO ()

-- | The <a>ExceptionHook</a> is called if an exception reaches the
--   toplevel of the server, i.e. if an exception leaks out of the user
--   handler or if an exception is raised during the sending of the HTTP
--   response data.
type ExceptionHook hookState = IORef hookState -> SomeException -> IO ()

-- | The <a>ParseHook</a> is called after the HTTP Request has been parsed
--   by the server, but before the user handler starts running.
type ParseHook hookState = IORef hookState -> Request -> IO ()

-- | The <a>NewRequestHook</a> is called once processing for an HTTP
--   request begins, i.e. after the connection has been accepted and we
--   know that there's data available to read from the socket. The IORef
--   passed to the hook initially contains a bottom value that will throw
--   an exception if evaluated.
type NewRequestHook hookState = PerSessionData -> IO hookState

-- | The <a>UserHandlerFinishedHook</a> is called once the user handler has
--   finished running, but before the data for the HTTP response starts
--   being sent to the client.
type UserHandlerFinishedHook hookState = IORef hookState -> Request -> Response -> IO ()

-- | A <a>SendFileHandler</a> is called if the user handler requests that a
--   file be sent using <tt>sendfile()</tt> on systems that support it
--   (Linux, Mac OSX, and FreeBSD).
type SendFileHandler = -- | builder buffer Buffer -> -- | status line and headers Builder -> -- | file to send FilePath -> -- | start offset Word64 -> -- | number of bytes Word64 -> IO ()

-- | This function, provided to the web server internals from the outside,
--   is responsible for producing a <a>Response</a> once the server has
--   parsed the <a>Request</a>.
type ServerHandler hookState = -- | global server config ServerConfig hookState -> -- | per-connection data PerSessionData -> -- | HTTP request object Request -> IO (Request, Response)
data AcceptFunc

-- | Either the server should start listening on the given interface / port
--   combination, or the server should start up with a <a>Socket</a> that
--   has already had <tt>bind()</tt> and <tt>listen()</tt> called on it.
data SocketConfig
StartListening :: ByteString -> Int -> SocketConfig
PreBound :: Socket -> SocketConfig

module System.FastLogger

-- | Holds the state for a logger.
data Logger

-- | Prepares a log message with the time prepended.
timestampedLogEntry :: ByteString -> IO ByteString

-- | Prepares a log message in "combined" format.
combinedLogEntry :: ByteString -> Maybe ByteString -> ByteString -> Int -> Word64 -> Maybe ByteString -> ByteString -> IO ByteString

-- | Creates a new logger, logging to the given file. If the file argument
--   is "-", then log to stdout; if it's "stderr" then we log to stderr,
--   otherwise we log to a regular file in append mode. The file is closed
--   and re-opened every 15 minutes to facilitate external log rotation.
newLogger :: FilePath -> IO Logger

-- | Like <a>newLogger</a>, but uses a custom error action if the logger
--   needs to print an error message of its own (for instance, if it can't
--   open the output file.)
newLoggerWithCustomErrorFunction :: (ByteString -> IO ()) -> FilePath -> IO Logger

-- | Creates a Logger and passes it into the given function, cleaning up
--   with "stopLogger" afterwards.
withLogger :: FilePath -> (Logger -> IO a) -> IO a

-- | Creates a Logger with "newLoggerWithCustomErrorFunction" and passes it
--   into the given function, cleaning up with "stopLogger" afterwards.
withLoggerWithCustomErrorFunction :: (ByteString -> IO ()) -> FilePath -> (Logger -> IO a) -> IO a

-- | Kills a logger thread, causing any unwritten contents to be flushed
--   out to disk
stopLogger :: Logger -> IO ()

-- | Sends out a log message verbatim with a newline appended. Note: if you
--   want a fancy log message you'll have to format it yourself (or use
--   <a>combinedLogEntry</a>).
logMsg :: Logger -> ByteString -> IO ()


-- | The Snap HTTP server is a high performance web server library written
--   in Haskell. Together with the <tt>snap-core</tt> library upon which it
--   depends, it provides a clean and efficient Haskell programming
--   interface to the HTTP protocol.
module Snap.Http.Server

-- | Starts serving HTTP requests using the given handler. This function
--   never returns; to shut down the HTTP server, kill the controlling
--   thread.
--   
--   This function is like <a>httpServe</a> except it doesn't setup
--   compression, reverse proxy address translation (via
--   <a>behindProxy</a>), or the error handler; this allows it to be used
--   from <a>MonadSnap</a>.
simpleHttpServe :: MonadSnap m => Config m a -> Snap () -> IO ()

-- | Starts serving HTTP requests using the given handler, with settings
--   from the <a>Config</a> passed in. This function never returns; to shut
--   down the HTTP server, kill the controlling thread.
httpServe :: Config Snap a -> Snap () -> IO ()

-- | Starts serving HTTP using the given handler. The configuration is read
--   from the options given on the command-line, as returned by
--   <a>commandLineConfig</a>. This function never returns; to shut down
--   the HTTP server, kill the controlling thread.
quickHttpServe :: Snap () -> IO ()

-- | A short string describing the Snap server version
snapServerVersion :: ByteString

-- | Given a string like "en_US", this sets the locale to "en_US.UTF-8".
--   This doesn't work on Windows.
setUnicodeLocale :: String -> IO ()
rawHttpServe :: ServerHandler s -> ServerConfig s -> [AcceptFunc] -> IO ()
