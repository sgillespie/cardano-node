-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core components of Cardano ledgers from the Shelley release on.
--   
--   Cardano ledgers from the Shelley release onwards share a core basis
--   rooted in the Shelley ledger specification. This package abstracts a
--   number of components which we expect to be shared amongst all future
--   ledgers implemented around this base.
@package cardano-ledger-core
@version 1.10.0.0


-- | This is taken from Edward Kmett's <tt>free</tt> library See:
--   <a>https://hackage.haskell.org/package/free-5.2</a>

-- | <i>Deprecated: Because it is no longer used in Ledger</i>
module Cardano.Ledger.Ap

-- | The faster free <a>Applicative</a>.
newtype Ap f a
Ap :: (forall u y z. (forall x. (x -> y) -> ASeq f x -> z) -> (u -> a -> y) -> ASeq f u -> z) -> Ap f a
[unAp] :: Ap f a -> forall u y z. (forall x. (x -> y) -> ASeq f x -> z) -> (u -> a -> y) -> ASeq f u -> z

-- | Given a natural transformation from <tt>f</tt> to <tt>g</tt> this
--   gives a monoidal natural transformation from <tt>Ap f</tt> to <tt>Ap
--   g</tt>.
hoistAp :: (forall x. f x -> g x) -> Ap f a -> Ap g a

-- | Given a natural transformation from <tt>f</tt> to <tt>g</tt>, this
--   gives a canonical monoidal natural transformation from <tt><a>Ap</a>
--   f</tt> to <tt>g</tt>.
--   
--   <pre>
--   runAp t == retractApp . hoistApp t
--   </pre>
runAp :: Applicative g => (forall x. f x -> g x) -> Ap f a -> g a

-- | Perform a monoidal analysis over free applicative value.
--   
--   Example:
--   
--   <pre>
--   count :: Ap f a -&gt; Int
--   count = getSum . runAp_ (\_ -&gt; Sum 1)
--   </pre>
runAp_ :: Monoid m => (forall a. f a -> m) -> Ap f b -> m
instance GHC.Base.Functor (Cardano.Ledger.Ap.Ap f)
instance GHC.Base.Applicative (Cardano.Ledger.Ap.Ap f)

module Cardano.Ledger.Compactible
class (Show (CompactForm a), Eq (CompactForm a), EncCBOR (CompactForm a), NoThunks (CompactForm a)) => Compactible a where {
    data CompactForm a :: Type;
}
toCompact :: Compactible a => a -> Maybe (CompactForm a)
fromCompact :: Compactible a => CompactForm a -> a


-- | Package all the crypto constraints into one place.
module Cardano.Ledger.Crypto
class (HashAlgorithm (HASH c), HashAlgorithm (ADDRHASH c), DSIGNAlgorithm (DSIGN c), KESAlgorithm (KES c), VRFAlgorithm (VRF c), ContextDSIGN (DSIGN c) ~ (), ContextKES (KES c) ~ (), ContextVRF (VRF c) ~ (), Typeable c) => Crypto c where {
    type HASH c :: Type;
    type ADDRHASH c :: Type;
    type DSIGN c :: Type;
    type KES c :: Type;
    type VRF c :: Type;
}

-- | The same crypto used on the net
data StandardCrypto
instance Cardano.Ledger.Crypto.Crypto Cardano.Ledger.Crypto.StandardCrypto


-- | This module contains just the type of protocol parameters.
module Cardano.Ledger.HKD

-- | Higher Kinded Data
type family HKD f a
type family HKDNoUpdate f a
class HKDFunctor f
hkdMap :: HKDFunctor f => proxy f -> (a -> b) -> HKD f a -> HKD f b
toNoUpdate :: HKDFunctor f => HKD f a -> HKDNoUpdate f a
fromNoUpdate :: HKDFunctor f => HKDNoUpdate f a -> HKD f a
data NoUpdate a
NoUpdate :: NoUpdate a
instance GHC.Generics.Generic (Cardano.Ledger.HKD.NoUpdate a)
instance GHC.Show.Show (Cardano.Ledger.HKD.NoUpdate a)
instance GHC.Classes.Ord (Cardano.Ledger.HKD.NoUpdate a)
instance GHC.Classes.Eq (Cardano.Ledger.HKD.NoUpdate a)
instance Cardano.Ledger.HKD.HKDFunctor Data.Functor.Identity.Identity
instance Cardano.Ledger.HKD.HKDFunctor GHC.Maybe.Maybe
instance Cardano.Ledger.HKD.HKDFunctor Data.Maybe.Strict.StrictMaybe
instance NoThunks.Class.NoThunks (Cardano.Ledger.HKD.NoUpdate a)
instance Control.DeepSeq.NFData (Cardano.Ledger.HKD.NoUpdate a)

module Cardano.Ledger.Orphans
instance NoThunks.Class.NoThunks (Data.Fixed.Fixed p)
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IPv4
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IPv4
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IPv6
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IPv6
instance NoThunks.Class.NoThunks Data.IP.Addr.IPv4
instance NoThunks.Class.NoThunks Data.IP.Addr.IPv6
instance Control.DeepSeq.NFData Data.IP.Addr.IPv4
instance Control.DeepSeq.NFData Data.IP.Addr.IPv6
instance NoThunks.Class.NoThunks Cardano.Crypto.Wallet.XSignature
instance Cardano.Crypto.Util.SignableRepresentation (Cardano.Crypto.Hash.Class.Hash a b)
instance Data.Default.Class.Default (Data.Sequence.Strict.StrictSeq t)
instance Data.Default.Class.Default Data.ByteString.Short.Internal.ShortByteString
instance Data.Default.Class.Default Data.ByteString.Internal.Type.ByteString
instance Data.Default.Class.Default Data.ByteString.Lazy.Internal.ByteString
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Default.Class.Default (Cardano.Crypto.Hash.Class.Hash h b)
instance Data.Default.Class.Default GHC.Types.Bool


-- | In cardano-ledger, hashing a type <tt>X</tt> is based upon the
--   serialization of <tt>X</tt>. Serialization is based upon the
--   <a>EncCBOR</a> and DecCBOR type classes, and the values produced by
--   <a>EncCBOR</a> instances for a particular type, are not necessarily
--   unique. For this reason, when an <tt>X</tt> object comes over the
--   network in serialized form, we must preserve the original bytes that
--   arrived over the network, otherwise when the system hashes that
--   object, the hash in the ledger, and the hash of that object from the
--   other side of the network may not agree. The module <a>SafeHash</a>
--   introduces the <a>SafeToHash</a> type class that ensures that types
--   with a <tt>(SafeToHash X)</tt> instance store the original bytes that
--   arrived over the network for the value of <tt>X</tt>. The recommended
--   way to store the original bytes is to use the type <tt>MemoBytes</tt>,
--   although there are a few types that store their original bytes in
--   other ways. In order to encourage the use of <tt>MemoBytes</tt>
--   newtypes defined as a <tt>MemoBytes</tt> get the to derive
--   <a>SafeToHash</a> instances for free.
module Cardano.Ledger.SafeHash

-- | A <a>SafeHash</a> is a hash of something that is safe to hash. Such
--   types store their own serialisation bytes. The prime example is
--   <tt>(<tt>MemoBytes</tt> t)</tt>, but other examples are things that
--   consist of only ByteStrings (i.e. they are their own serialization) or
--   for some other reason store their original bytes.
--   
--   We do NOT export the constructor <a>SafeHash</a>, but instead export
--   other functions such as 'hashWithCrypto, <a>hashAnnotated</a> and
--   <a>extractHash</a> which have constraints that limit their application
--   to types which preserve their original serialization bytes.
data SafeHash c index

-- | Only Types that preserve their serialisation bytes are members of the
--   class <a>SafeToHash</a>. There are only a limited number of primitive
--   direct instances of <a>SafeToHash</a>, all but two of them are present
--   in this file. Instead of making explicit instances, we almost always
--   use a newtype (around a type <tt>S</tt>) where their is already an
--   instance <tt>(SafeToHash S)</tt>. In that case the newtype has its
--   SafeToHash instance derived using newtype deriving. The prime example
--   of <tt>s</tt> is <tt>MemoBytes</tt>. The only exceptions are the
--   legacy Shelley types: <tt>Metadata</tt> and <tt>ShelleyTx</tt>, that
--   preserve their serialization bytes using a different mechanism than
--   the use of <tt>MemoBytes</tt>. <a>SafeToHash</a> is a superclass
--   requirement of the classes <a>HashAnnotated</a> and
--   <a>HashWithCrypto</a> (below) which provide more convenient ways to
--   construct SafeHashes than using <a>makeHashWithExplicitProxys</a>.
class SafeToHash t

-- | Extract the original bytes from <tt>t</tt>
originalBytes :: SafeToHash t => t -> ByteString
makeHashWithExplicitProxys :: (SafeToHash t, HashAlgorithm (HASH c)) => Proxy c -> Proxy index -> t -> SafeHash c index

-- | Types that are <a>SafeToHash</a>, AND have both of the following two
--   invariants, are made members of the HashAnnotated class. The
--   preconditions are:
--   
--   <ol>
--   <li>The type uniquely determines the <tt>index</tt> type tag of
--   (SafeHash crypto index)</li>
--   <li>The type uniquely determines the <tt>crypto</tt> type of (SafeHash
--   crytop index)</li>
--   </ol>
--   
--   The <a>SafeToHash</a> and the <a>HashAnnotated</a> classes are
--   designed so that their instances can be easily derived (because their
--   methods have default methods when the type is a newtype around a type
--   that is <a>SafeToHash</a>). For example,
--   
--   <pre>
--   newtype T era = T S
--      deriving Eq
--      deriving newtype SafeToHash -- Uses {-# LANGUAGE DerivingStrategies #-}
--   
--   instance HashAnnotated (T era) Index (Crypto era)
--   </pre>
--   
--   After these declarations. One specialization of <a>hashAnnotated</a>
--   is <tt>(hashAnnotated :: Era e =&gt; T e -&gt; SafeHash (Crypto e)
--   Index)</tt>
class SafeToHash x => HashAnnotated x index c | x -> index c

-- | Create a <tt>(<a>SafeHash</a> i crypto)</tt>, given
--   <tt>(Hash.HashAlgorithm (HASH crypto))</tt> and <tt>(HashAnnotated x i
--   crypto)</tt> instances.
hashAnnotated :: (HashAnnotated x index c, HashAlgorithm (HASH c)) => x -> SafeHash c index

-- | Create <tt>(<a>SafeHash</a> index crypto)</tt> values, used when the
--   type being hashed: <tt>x</tt> determines the <tt>index</tt> tag but
--   not the <tt>crypto</tt> tag of <tt>x</tt>
class SafeToHash x => HashWithCrypto x index | x -> index

-- | Create a <tt>(<a>SafeHash</a> index crypto)</tt> value from
--   <tt>x</tt>, the <tt>proxy</tt> determines the crypto.
hashWithCrypto :: forall c. (HashWithCrypto x index, HashAlgorithm (HASH c)) => Proxy c -> x -> SafeHash c index

-- | Don't use this except in Testing to make Arbitrary instances, etc.
--   Defined here, only because the Constructor is in scope here.
unsafeMakeSafeHash :: Hash (HASH c) index -> SafeHash c index

-- | To change the index parameter of SafeHash (which is a phantom type)
--   use castSafeHash
castSafeHash :: forall i j c. SafeHash c i -> SafeHash c j

-- | Extract the hash out of a <a>SafeHash</a>
extractHash :: SafeHash c i -> Hash (HASH c) i
indexProxy :: HashAnnotated x index c => x -> Proxy index

-- | Sometimes one wants to hash multiple things, simply by concatenating
--   all the bytes. This abstraction allows one to do that safely.
data Safe
[Safe] :: SafeToHash x => x -> Safe
hashSafeList :: HashAlgorithm (HASH c) => Proxy c -> Proxy index -> [Safe] -> SafeHash c index

-- | <i>Deprecated: Use `Hash.HashAlgorithm (HASH c)` instead</i>
type HasAlgorithm c = HashAlgorithm (HASH c)
instance Control.DeepSeq.NFData (Cardano.Ledger.SafeHash.SafeHash c index)
instance NoThunks.Class.NoThunks (Cardano.Ledger.SafeHash.SafeHash c index)
instance GHC.Classes.Ord (Cardano.Ledger.SafeHash.SafeHash c index)
instance GHC.Classes.Eq (Cardano.Ledger.SafeHash.SafeHash c index)
instance GHC.Show.Show (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH c) => Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.HeapWords.HeapWords (Cardano.Ledger.SafeHash.SafeHash c i)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.Ledger.SafeHash.SafeToHash Cardano.Ledger.SafeHash.Safe
instance Cardano.Ledger.SafeHash.SafeToHash Data.ByteString.Short.Internal.ShortByteString
instance Cardano.Ledger.SafeHash.SafeToHash Data.ByteString.Internal.Type.ByteString
instance Cardano.Crypto.Hash.Class.HashAlgorithm c => Cardano.Ledger.SafeHash.SafeToHash (Cardano.Crypto.Hash.Class.Hash c i)
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.SafeHash.SafeHash c i)


-- | This module provides data structures and operations for talking about
--   Non-native Script languages. It is expected that new languages (or new
--   versions of old languages) will be added here.
module Cardano.Ledger.Plutus.Language

-- | Serialized representation of a Plutus script that distinguishes the
--   language version at the type level. When encoded in CBOR language
--   version is also encoded.
newtype Plutus (l :: Language)
Plutus :: PlutusBinary -> Plutus (l :: Language)
[plutusBinary] :: Plutus (l :: Language) -> PlutusBinary

-- | Verify that the binary version of the Plutus script is deserializable.
isValidPlutus :: PlutusLanguage l => Version -> Plutus l -> Bool

-- | Binary representation of a Plutus script.
newtype PlutusBinary
PlutusBinary :: ShortByteString -> PlutusBinary
[unPlutusBinary] :: PlutusBinary -> ShortByteString

-- | This is a deserialized version of the <a>Plutus</a> type that can be
--   used directly with evaluation functions that rely on
--   <a>evaluatePlutusRunnable</a>.
--   
--   The only way to obtain this type is by the means of deserializing
--   <a>Plutus</a> with <a>decodePlutusRunnable</a>
newtype PlutusRunnable (l :: Language)
PlutusRunnable :: ScriptForEvaluation -> PlutusRunnable (l :: Language)
[plutusRunnable] :: PlutusRunnable (l :: Language) -> ScriptForEvaluation

-- | Serialize the runnable version of the plutus script
--   
--   <pre>
--   decodePlutusRunnable majVer (plutusFromRunnable pr) == Right pr
--   </pre>
plutusFromRunnable :: PlutusRunnable l -> Plutus l

-- | Plutus script decoder that will enforce the type level language equals
--   the one included in the serialization
decodeWithPlutus :: (forall si l. PlutusLanguage l => Plutus l -> Decoder si a) -> Decoder so a

-- | Non-Native Plutus Script language. This is expected to be an open
--   type. We will add new Constuctors to this type as additional Plutus
--   language versions as are added. We use an enumerated type for two
--   reasons.
--   
--   <ol>
--   <li>We can write total functions by case analysis over the
--   constructors</li>
--   <li>We use DataKinds to make some datatypes indexed by Language.</li>
--   </ol>
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language
PlutusV3 :: Language

-- | Make a language from its <a>Enum</a> index.
mkLanguageEnum :: Int -> Maybe Language
languageToText :: Language -> Text
languageFromText :: MonadFail m => Text -> m Language
nonNativeLanguages :: [Language]

-- | Prevent decoding a version of Plutus until the appropriate protocol
--   version.
guardPlutus :: Language -> Decoder s ()

-- | Singleton for '<tt>Language</tt>'
data SLanguage (l :: Language)
[SPlutusV1] :: SLanguage 'PlutusV1
[SPlutusV2] :: SLanguage 'PlutusV2
[SPlutusV3] :: SLanguage 'PlutusV3

-- | For implicit reflection on '<tt>SLanguage</tt>' See
--   <a>Cardano.Ledger.Alonzo.Plutus.TxInfo</a> for example usage
class Typeable l => PlutusLanguage (l :: Language)
isLanguage :: PlutusLanguage l => SLanguage l
decodePlutusRunnable :: PlutusLanguage l => Version -> Plutus l -> Either ScriptDecodeError (PlutusRunnable l)
evaluatePlutusRunnable :: PlutusLanguage l => Version -> VerboseMode -> EvaluationContext -> ExBudget -> PlutusRunnable l -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Similar to <a>evaluatePlutusRunnable</a>, except does not require
--   <a>ExBudget</a> to be provided as input and instead computes it as
--   output. This function is meant to be used for testing.
evaluatePlutusRunnableBudget :: PlutusLanguage l => Version -> VerboseMode -> EvaluationContext -> PlutusRunnable l -> [Data] -> (LogOutput, Either EvaluationError ExBudget)

-- | Construct value level laguage version from the type level
plutusLanguage :: forall l proxy. PlutusLanguage l => proxy l -> Language
plutusSLanguage :: PlutusLanguage l => proxy l -> SLanguage l

-- | Reflection for '<tt>SLanguage</tt>'

-- | <i>Deprecated: In favor of <a>plutusLanguage</a></i>
fromSLanguage :: PlutusLanguage l => SLanguage l -> Language
toSLanguage :: forall l m. (PlutusLanguage l, MonadFail m) => Language -> m (SLanguage l)
withSLanguage :: Language -> (forall l. PlutusLanguage l => SLanguage l -> a) -> a
asSLanguage :: SLanguage l -> proxy l -> proxy l
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.Language.PlutusBinary
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.Language.PlutusBinary
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.Language.PlutusBinary
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.Language.PlutusBinary
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Plutus.Language.PlutusBinary
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Plutus.Language.PlutusBinary
instance GHC.Generics.Generic Cardano.Ledger.Plutus.Language.PlutusBinary
instance GHC.Classes.Ord Cardano.Ledger.Plutus.Language.PlutusBinary
instance GHC.Classes.Eq Cardano.Ledger.Plutus.Language.PlutusBinary
instance GHC.Ix.Ix Cardano.Ledger.Plutus.Language.Language
instance GHC.Enum.Bounded Cardano.Ledger.Plutus.Language.Language
instance GHC.Enum.Enum Cardano.Ledger.Plutus.Language.Language
instance GHC.Classes.Ord Cardano.Ledger.Plutus.Language.Language
instance GHC.Show.Show Cardano.Ledger.Plutus.Language.Language
instance GHC.Generics.Generic Cardano.Ledger.Plutus.Language.Language
instance GHC.Classes.Eq Cardano.Ledger.Plutus.Language.Language
instance Control.DeepSeq.NFData (Cardano.Ledger.Plutus.Language.Plutus l)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Language.Plutus l)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Plutus.Language.Plutus l)
instance GHC.Classes.Ord (Cardano.Ledger.Plutus.Language.Plutus l)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Language.Plutus l)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Language.Plutus l)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Language.Plutus l)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance Control.DeepSeq.NFData (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Language.SLanguage l)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Language.SLanguage l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Language.PlutusRunnable l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.Language.Plutus l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Language.Plutus l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Plutus.Language.SLanguage l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Plutus.Language.SLanguage l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Language.SLanguage l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage l => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.Language.SLanguage l)
instance Cardano.Ledger.Plutus.Language.PlutusLanguage 'Cardano.Ledger.Plutus.Language.PlutusV1
instance Cardano.Ledger.Plutus.Language.PlutusLanguage 'Cardano.Ledger.Plutus.Language.PlutusV2
instance Cardano.Ledger.Plutus.Language.PlutusLanguage 'Cardano.Ledger.Plutus.Language.PlutusV3
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.Language.Language
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.Language.Language
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Plutus.Language.Language
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.Language.Language
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Ledger.Plutus.Language.Language
instance Data.Aeson.Types.FromJSON.FromJSONKey Cardano.Ledger.Plutus.Language.Language
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Plutus.Language.Language
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Plutus.Language.Language
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.Language.Language
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.Language.Language
instance GHC.Show.Show Cardano.Ledger.Plutus.Language.PlutusBinary
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator Cardano.Ledger.Plutus.Language.PlutusBinary)
instance Cardano.Ledger.SafeHash.SafeToHash Cardano.Ledger.Plutus.Language.PlutusBinary

module Cardano.Ledger.Plutus.CostModels

-- | A language dependent cost model for the Plutus evaluator. Note that
--   the <a>EvaluationContext</a> is entirely dependent on the cost model
--   parameters (ie the <a>Decode</a> <a>Text</a> <a>Integer</a>) and that
--   this type uses the smart constructor <a>mkCostModel</a> to hide the
--   evaluation context.
data CostModel

-- | See <a>CostModels</a> for an explanation of how <a>CostModelError</a>
--   is used.
newtype CostModelError
CostModelError :: CostModelApplyError -> CostModelError
data () => CostModelApplyError
CMUnknownParamError :: !Text -> CostModelApplyError
CMInternalReadError :: CostModelApplyError
CMInternalWriteError :: !String -> CostModelApplyError
CMTooFewParamsError :: !Int -> !Int -> CostModelApplyError
[cmTooFewExpected] :: CostModelApplyError -> !Int
[cmTooFewActual] :: CostModelApplyError -> !Int

-- | Convert cost model parameters to a cost model, making use of the
--   conversion function mkEvaluationContext from the Plutus API.
mkCostModel :: Language -> [Integer] -> Either CostModelApplyError CostModel

-- | This function attempts to convert a Map with potential cost models to
--   into validated <a>CostModels</a>. If it is a valid cost model for a
--   known version of Plutus, it is added to <a>costModelsValid</a>. If it
--   is an invalid cost model for a known version of Plutus, the error is
--   stored in <a>costModelsErrors</a> and the cost model is stored in
--   <a>costModelsUnknown</a>. Lastly, if the Plutus version is unknown,
--   the cost model is also stored in <a>costModelsUnknown</a>.
mkCostModelsLenient :: Map Word8 [Integer] -> CostModels

-- | Encoding for the <a>CostModel</a>. Important to note that it differs
--   from <a>Encoding</a> used by <a>getLanguageView</a>
encodeCostModel :: CostModel -> Encoding
getCostModelLanguage :: CostModel -> Language
getCostModelParams :: CostModel -> [Integer]
getCostModelEvaluationContext :: CostModel -> EvaluationContext
getEvaluationContext :: CostModel -> EvaluationContext
costModelParamNames :: Language -> [Text]
costModelToMap :: CostModel -> Map Text Integer
costModelFromMap :: MonadFail m => Language -> Map Text Integer -> m CostModel

-- | Number of parameters in a CostModel for a specific language
costModelParamsCount :: Language -> Int
decodeCostModelFailHard :: Language -> Decoder s CostModel

-- | For a known version of Plutus, attempting to construct a cost model
--   with too few parameters (depending on the version) will result in an
--   error. <tt>CostModelApplyError</tt> exists to collect these errors in
--   the <a>CostModels</a> type. The <a>CostModels</a> type itself needs to
--   be flexible enough to accept any map of <a>Word8</a> to '[Integer]',
--   so that cost models can be placed in the protocol parameters ahead of
--   changes to the Plutus evaluation context. In this way, serializing a
--   cost model, updating software, and deserializing can result in errors
--   going away.
--   
--   Additionally, <a>CostModels</a> needs to be able to store cost models
--   for future version of Plutus, which we cannot yet even validate. These
--   are stored in <a>costModelsUnknown</a>.
data CostModels

-- | Construct an all valid <a>CostModels</a>
mkCostModels :: Map Language CostModel -> CostModels
emptyCostModels :: CostModels

-- | Updates the first <tt><a>CostModels</a></tt> with the second one, so
--   that only the cost models that are present in the second one get
--   updated while all the others stay unchanged. Language specific errors
--   and unknown cost models are removed, whenever a valid <a>CostModel</a>
--   for the language is supplied in the update.
updateCostModels :: CostModels -> CostModels -> CostModels
decodeValidAndUnknownCostModels :: Decoder s CostModels
costModelsValid :: CostModels -> Map Language CostModel
costModelsErrors :: CostModels -> Map Language CostModelError
costModelsUnknown :: CostModels -> Map Word8 [Integer]

-- | Turn a <a>CostModels</a> into a mapping of potential language versions
--   and cost model values, with no distinction between valid and invalid
--   cost models. This is used for serialization, so that judgements about
--   validity can be made upon deserialization.
flattenCostModels :: CostModels -> Map Word8 [Integer]
instance GHC.Generics.Generic Cardano.Ledger.Plutus.CostModels.CostModel
instance GHC.Generics.Generic Cardano.Ledger.Plutus.CostModels.CostModelError
instance GHC.Show.Show Cardano.Ledger.Plutus.CostModels.CostModelError
instance GHC.Classes.Eq Cardano.Ledger.Plutus.CostModels.CostModelError
instance GHC.Generics.Generic Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Show.Show Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Classes.Ord Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Classes.Eq Cardano.Ledger.Plutus.CostModels.CostModels
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Base.Semigroup Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Base.Monoid Cardano.Ledger.Plutus.CostModels.CostModels
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.CostModels.CostModels
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.CostModels.CostModels
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.CostModels.CostModels
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.CostModels.CostModels
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.CostModels.CostModels
instance GHC.Classes.Ord Cardano.Ledger.Plutus.CostModels.CostModelError
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.CostModels.CostModelError
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.CostModels.CostModelError
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.CostModels.CostModelError
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.CostModels.CostModelError
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.CostModels.CostModelError
instance GHC.Classes.Eq Cardano.Ledger.Plutus.CostModels.CostModel
instance GHC.Show.Show Cardano.Ledger.Plutus.CostModels.CostModel
instance GHC.Classes.Ord Cardano.Ledger.Plutus.CostModels.CostModel
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.CostModels.CostModel
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.CostModels.CostModel
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.CostModels.CostModel


-- | <i>Deprecated: Use <a>Cardano.Ledger.Plutus.Language</a> instead</i>
module Cardano.Ledger.Language


-- | MemoBytes is an abstraction for a data type that encodes its own
--   serialization. The idea is to use a newtype around a MemoBytes applied
--   to a non-memoizing type. For example: newtype Foo = Foo
--   (<a>MemoBytes</a> NonMemoizingFoo) This way all the instances for
--   <tt>Foo (<a>Eq</a>, <a>Show</a>, <a>EncCBOR</a>, <a>DecCBOR</a>,
--   <a>NoThunks</a>, Generic`)</tt> can be derived for free. MemoBytes
--   plays an important role in the <a>SafeToHash</a> class introduced in
--   the module <a>SafeHash</a>
module Cardano.Ledger.MemoBytes

-- | Pair together a type <tt>t</tt> and its serialization. Used to encode
--   a type that is serialized over the network, and to remember the
--   original bytes that were used to transmit it. Important since hashes
--   are computed from the serialization of a type, and EncCBOR instances
--   do not have unique serializations.
data MemoBytes t era
pattern Memo :: Era era => t era -> ShortByteString -> MemoBytes t era
type family MemoHashIndex (t :: Type -> Type) :: Type

-- | Useful when deriving DecCBOR(Annotator T) deriving via (Mem T)
--   instance (Era era) =&gt; DecCBOR (Annotator T)
type Mem t era = Annotator (MemoBytes t era)

-- | Smart constructor
mkMemoBytes :: forall era t. Era era => t era -> ByteString -> MemoBytes t era

-- | Extract the inner type of the MemoBytes
getMemoBytesType :: MemoBytes t era -> t era

-- | Extract the hash value of the binary representation of the MemoBytes
getMemoBytesHash :: MemoBytes t era -> SafeHash (EraCrypto era) (MemoHashIndex t)

-- | Create MemoBytes from its CBOR encoding
memoBytes :: forall era w t. Era era => Encode w (t era) -> MemoBytes t era

-- | Turn a lazy bytestring into a short bytestring.
shorten :: ByteString -> ShortByteString

-- | Turn a MemoBytes into a string, Showing both its internal structure
--   and its original bytes. Useful since the Show instance of MemoBytes
--   does not display the original bytes.
showMemo :: Show (t era) => MemoBytes t era -> String
printMemo :: Show (t era) => MemoBytes t era -> IO ()

-- | Helper function. Converts a short bytestring to a lazy bytestring.
shortToLazy :: ShortByteString -> ByteString

-- | Returns true if the contents of the MemoBytes are equal
contentsEq :: Eq (t era) => MemoBytes t era -> MemoBytes t era -> Bool

-- | Class that relates the actual type with its raw and byte
--   representations
class Memoized t where {
    type RawType t = (r :: Type -> Type) | r -> t;
}

-- | Construct memoized type from the raw type using its EncCBOR instance
mkMemoized :: forall era t. (Era era, EncCBOR (RawType t era), Memoized t) => RawType t era -> t era

-- | Extract memoized SafeHash
getMemoSafeHash :: Memoized t => t era -> SafeHash (EraCrypto era) (MemoHashIndex (RawType t))

-- | Extract the raw type from the memoized version
getMemoRawType :: Memoized t => t era -> RawType t era

-- | This is a helper function that operates on raw types of two memoized
--   types.
zipMemoRawType :: (Memoized t1, Memoized t2) => (RawType t1 era -> RawType t2 era -> a) -> t1 era -> t2 era -> a
eqRawType :: forall t era. (Memoized t, Eq (RawType t era)) => t era -> t era -> Bool

-- | Extract the raw bytes from the memoized version
getMemoRawBytes :: Memoized t => t era -> ShortByteString

-- | This is a helper Lens creator for any Memoized type.
lensMemoRawType :: (Era era, EncCBOR (RawType t era), Memoized t) => (RawType t era -> a) -> (RawType t era -> b -> RawType t era) -> Lens (t era) (t era) a b

-- | This is a helper SimpleGetter creator for any Memoized type
getterMemoRawType :: Memoized t => (RawType t era -> a) -> SimpleGetter (t era) a

-- | Type class that implements equality on the Haskell type, ignoring any
--   of the potentially memoized binary representation of the type.
class EqRaw a
eqRaw :: EqRaw a => a -> a -> Bool
eqRaw :: (EqRaw a, a ~ t era, Memoized t, Eq (RawType t era)) => a -> a -> Bool
instance (Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (t era)) => NoThunks.Class.NoThunks (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance GHC.Generics.Generic (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance Control.DeepSeq.NFData (t era) => Control.DeepSeq.NFData (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance (Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance (Data.Typeable.Internal.Typeable t, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (t era)), Cardano.Ledger.Core.Era.Era era) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.MemoBytes.MemoBytes t era))
instance GHC.Classes.Eq (t era) => GHC.Classes.Eq (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance (GHC.Show.Show (t era), Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Core.Era.EraCrypto era))) => GHC.Show.Show (Cardano.Ledger.MemoBytes.MemoBytes t era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.MemoBytes.MemoBytes t era)


-- | Various identifiers in the ledger are hashes of particular structures.
--   While the structures may change from era to era, the hash will remain
--   the same, and we can refer to the hash of, say, a transaction, without
--   knowing the actual transaction type. As such, we define a number of
--   these hashes here.
module Cardano.Ledger.Hashes
data EraIndependentTxBody
data EraIndependentBlockHeader
data EraIndependentBlockBody
data EraIndependentMetadata
data EraIndependentScript
data EraIndependentData
data EraIndependentScriptData
data EraIndependentTxAuxData
data EraIndependentPParamView
data EraIndependentScriptIntegrity
newtype ScriptHash c
ScriptHash :: Hash (ADDRHASH c) EraIndependentScript -> ScriptHash c
type DataHash c = SafeHash c EraIndependentData
instance NoThunks.Class.NoThunks (Cardano.Ledger.Hashes.ScriptHash c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Hashes.ScriptHash c)
instance GHC.Generics.Generic (Cardano.Ledger.Hashes.ScriptHash c)
instance GHC.Classes.Ord (Cardano.Ledger.Hashes.ScriptHash c)
instance GHC.Classes.Eq (Cardano.Ledger.Hashes.ScriptHash c)
instance GHC.Show.Show (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Hashes.ScriptHash c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Hashes.ScriptHash c)

module Cardano.Ledger.Keys.WitVKey

-- | Proof/Witness that a transaction is authorized by the given key
--   holder.
data WitVKey kr c
pattern WitVKey :: (Typeable kr, Crypto c) => VKey kr c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> WitVKey kr c

-- | Access CBOR encoded representation of the witness. Evaluated lazily
witVKeyBytes :: WitVKey kr c -> ByteString

-- | Access computed hash. Evaluated lazily
witVKeyHash :: WitVKey kr c -> KeyHash 'Witness c
eqWitVKeyRaw :: (Crypto c, Typeable kr) => WitVKey kr c -> WitVKey kr c -> Bool
instance GHC.Generics.Generic (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance (Cardano.Ledger.Crypto.Crypto c, Data.Typeable.Internal.Typeable kr) => NoThunks.Class.NoThunks (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => GHC.Classes.Ord (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Keys.WitVKey.WitVKey kr c))
instance (Cardano.Ledger.Crypto.Crypto c, Data.Typeable.Internal.Typeable kr) => Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Keys.WitVKey.WitVKey kr c)

module Cardano.Ledger.Keys.Bootstrap
data BootstrapWitness c
pattern BootstrapWitness :: Crypto c => VKey 'Witness c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> ChainCode -> ByteString -> BootstrapWitness c
newtype ChainCode
ChainCode :: ByteString -> ChainCode
[unChainCode] :: ChainCode -> ByteString

-- | Rebuild the addrRoot of the corresponding address.
bootstrapWitKeyHash :: forall c. Crypto c => BootstrapWitness c -> KeyHash 'Witness c
unpackByronVKey :: forall c. DSIGN c ~ Ed25519DSIGN => VerificationKey -> (VKey 'Witness c, ChainCode)
makeBootstrapWitness :: forall c. (DSIGN c ~ Ed25519DSIGN, Crypto c) => Hash c EraIndependentTxBody -> SigningKey -> Attributes AddrAttributes -> BootstrapWitness c
verifyBootstrapWit :: forall c. (Crypto c, Signable (DSIGN c) (Hash c EraIndependentTxBody)) => Hash c EraIndependentTxBody -> BootstrapWitness c -> Bool
eqBootstrapWitnessRaw :: Crypto c => BootstrapWitness c -> BootstrapWitness c -> Bool
instance Control.DeepSeq.NFData Cardano.Ledger.Keys.Bootstrap.ChainCode
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Keys.Bootstrap.ChainCode
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Keys.Bootstrap.ChainCode
instance NoThunks.Class.NoThunks Cardano.Ledger.Keys.Bootstrap.ChainCode
instance GHC.Show.Show Cardano.Ledger.Keys.Bootstrap.ChainCode
instance GHC.Generics.Generic Cardano.Ledger.Keys.Bootstrap.ChainCode
instance GHC.Classes.Eq Cardano.Ledger.Keys.Bootstrap.ChainCode
instance GHC.Generics.Generic (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance (Cardano.Ledger.Crypto.Crypto era, Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN era)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN (Cardano.Ledger.Crypto.DSIGN era))) => Control.DeepSeq.NFData (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness era)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Ord (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness c)

module Cardano.Ledger.Keys

-- | The role of a key.
--   
--   Note that a role is not _fixed_, nor is it unique. In particular, keys
--   may variously be used as witnesses, and so in many case we will change
--   the role of a key to the <a>Witness</a> role.
--   
--   It is also perfectly allowable for a key to be used in many roles;
--   there is nothing prohibiting somebody using the same underlying key as
--   their payment and staking key, as well as the key for their stake
--   pool. So these roles are more intended for two purposes:
--   
--   <ul>
--   <li>To make explicit how we are using a key in the specifications</li>
--   <li>To provide a guide to downstream implementors, for whom the
--   profusion of keys may be confusing.</li>
--   </ul>
data KeyRole
Genesis :: KeyRole
GenesisDelegate :: KeyRole
Payment :: KeyRole
Staking :: KeyRole
StakePool :: KeyRole
BlockIssuer :: KeyRole
Witness :: KeyRole
DRepRole :: KeyRole
HotCommitteeRole :: KeyRole
ColdCommitteeRole :: KeyRole
class HasKeyRole (a :: KeyRole -> Type -> Type)

-- | General coercion of key roles.
--   
--   The presence of this function is mostly to help the user realise where
--   they are converting key roles.
coerceKeyRole :: HasKeyRole a => a r c -> a r' c

-- | General coercion of key roles.
--   
--   The presence of this function is mostly to help the user realise where
--   they are converting key roles.
coerceKeyRole :: (HasKeyRole a, Coercible (a r c) (a r' c)) => a r c -> a r' c

-- | Use a key as a witness.
--   
--   This is the most common coercion between key roles, because most keys
--   can be used as witnesses to some types of transaction. As such, we
--   provide an explicit coercion for it.
asWitness :: HasKeyRole a => a r c -> a 'Witness c
type DSignable c = Signable (DSIGN c)

-- | Discriminated verification key
--   
--   We wrap the basic <tt>VerKeyDSIGN</tt> in order to add the key role.
newtype VKey (kd :: KeyRole) c
VKey :: VerKeyDSIGN (DSIGN c) -> VKey (kd :: KeyRole) c
[unVKey] :: VKey (kd :: KeyRole) c -> VerKeyDSIGN (DSIGN c)

-- | <i>Deprecated: Use `Test.Cardano.Ledger.Core.KeyPair (KeyPair)`
--   instead</i>
data KeyPair (kd :: KeyRole) c

-- | <i>Deprecated: Use `Test.Cardano.Ledger.Core.KeyPair (KeyPair)`
--   instead</i>
KeyPair :: !VKey kd c -> !SignKeyDSIGN (DSIGN c) -> KeyPair (kd :: KeyRole) c
[vKey] :: KeyPair (kd :: KeyRole) c -> !VKey kd c
[sKey] :: KeyPair (kd :: KeyRole) c -> !SignKeyDSIGN (DSIGN c)

-- | Produce a digital signature
signedDSIGN :: (Crypto c, Signable (DSIGN c) a) => SignKeyDSIGN (DSIGN c) -> a -> SignedDSIGN c a

-- | Verify a digital signature
verifySignedDSIGN :: (Crypto c, Signable (DSIGN c) a) => VKey kd c -> a -> SignedDSIGN c a -> Bool

-- | Hash a given signature
hashSignature :: Crypto c => SignedDSIGN c (Hash c h) -> Hash c (SignedDSIGN c (Hash c h))

-- | Discriminated hash of public Key
newtype KeyHash (discriminator :: KeyRole) c
KeyHash :: Hash (ADDRHASH c) (VerKeyDSIGN (DSIGN c)) -> KeyHash (discriminator :: KeyRole) c

-- | Hash a given public key
hashKey :: Crypto c => VKey kd c -> KeyHash kd c
data GenDelegPair c
GenDelegPair :: !KeyHash 'GenesisDelegate c -> !Hash c (VerKeyVRF c) -> GenDelegPair c
[genDelegKeyHash] :: GenDelegPair c -> !KeyHash 'GenesisDelegate c
[genDelegVrfHash] :: GenDelegPair c -> !Hash c (VerKeyVRF c)
newtype GenDelegs c
GenDelegs :: Map (KeyHash 'Genesis c) (GenDelegPair c) -> GenDelegs c
[unGenDelegs] :: GenDelegs c -> Map (KeyHash 'Genesis c) (GenDelegPair c)
newtype GKeys c
GKeys :: Set (VKey 'Genesis c) -> GKeys c
[unGKeys] :: GKeys c -> Set (VKey 'Genesis c)
type KESignable c = Signable (KES c)
type VRFSignable c = Signable (VRF c)
decodeSignedDSIGN :: DSIGNAlgorithm v => Decoder s (SignedDSIGN v a)
encodeSignedDSIGN :: DSIGNAlgorithm v => SignedDSIGN v a -> Encoding
hashWithSerialiser :: HashAlgorithm h => (a -> Encoding) -> a -> Hash h a
decodeSignedKES :: KESAlgorithm v => Decoder s (SignedKES v a)
decodeVerKeyKES :: KESAlgorithm v => Decoder s (VerKeyKES v)
encodeSignedKES :: KESAlgorithm v => SignedKES v a -> Encoding
encodeVerKeyKES :: KESAlgorithm v => VerKeyKES v -> Encoding
signedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> Period -> a -> SignKeyKES v -> SignedKES v a
updateKES :: KESAlgorithm v => ContextKES v -> SignKeyKES v -> Period -> Maybe (SignKeyKES v)
verifyKES :: (KESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> VerKeyKES v -> Period -> a -> SigKES v -> Either String ()
verifySignedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> VerKeyKES v -> Period -> a -> SignedKES v a -> Either String ()
decodeVerKeyVRF :: VRFAlgorithm v => Decoder s (VerKeyVRF v)
encodeVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> Encoding
hashVerKeyVRF :: (VRFAlgorithm v, HashAlgorithm h) => VerKeyVRF v -> Hash h (VerKeyVRF v)
verifyVRF :: (VRFAlgorithm v, HasCallStack, Signable v a) => ContextVRF v -> VerKeyVRF v -> a -> CertVRF v -> Maybe (OutputVRF v)
type CertifiedVRF c = CertifiedVRF (VRF c)
type Hash c = Hash (HASH c)
type SignedDSIGN c = SignedDSIGN (DSIGN c)
type SignKeyDSIGN c = SignKeyDSIGN (DSIGN c)
type SignedKES c = SignedKES (KES c)
type SignKeyKES c = SignKeyKES (KES c)
type SignKeyVRF c = SignKeyVRF (VRF c)
type VerKeyKES c = VerKeyKES (KES c)
type VerKeyVRF c = VerKeyVRF (VRF c)


-- | The stake distribution, aggregated by stake pool (as opposed to stake
--   credential), plays a primary role in Cardano's proof of stake network.
--   Together with the VRF checks, the stake distribution determines leader
--   election. The leader election is the precisely the part of the ledger
--   that is determined by Ouroboros (Praos and Genesis), our consensus
--   mechanism. See Section 16, "Leader Value Calculation", of the
--   <a>formal specification</a>.
module Cardano.Ledger.PoolDistr

-- | The <a>IndividualPoolStake</a> contains all the stake controlled by a
--   single stake pool (the combination of owners and delegates) for a
--   given epoch, and also the hash of the stake pool's registered VRF key.
--   
--   When a stake pool produces a block, the header contains the full VRF
--   verification key and VRF value for leader election. We check the VRF
--   key against the value in <a>IndividualPoolStake</a> and we check the
--   VRF value using the epoch nonce and the relative stake of the pool as
--   given in <a>IndividualPoolStake</a>. The stake is relative to the
--   total amount of active stake in the network. Stake is active if it is
--   both registered and delegated to a registered stake pool.
data IndividualPoolStake c
IndividualPoolStake :: !Rational -> !Hash c (VerKeyVRF c) -> IndividualPoolStake c
[individualPoolStake] :: IndividualPoolStake c -> !Rational
[individualPoolStakeVrf] :: IndividualPoolStake c -> !Hash c (VerKeyVRF c)

-- | A map of stake pool IDs (the hash of the stake pool operator's
--   verification key) to <a>IndividualPoolStake</a>.
newtype PoolDistr c
PoolDistr :: Map (KeyHash 'StakePool c) (IndividualPoolStake c) -> PoolDistr c
[unPoolDistr] :: PoolDistr c -> Map (KeyHash 'StakePool c) (IndividualPoolStake c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance Control.DeepSeq.NFData (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance GHC.Generics.Generic (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance GHC.Classes.Eq (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance GHC.Show.Show (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.PoolDistr.PoolDistr c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.PoolDistr.PoolDistr c)
instance Control.DeepSeq.NFData (Cardano.Ledger.PoolDistr.PoolDistr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.PoolDistr.PoolDistr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.PoolDistr.PoolDistr c)
instance GHC.Generics.Generic (Cardano.Ledger.PoolDistr.PoolDistr c)
instance GHC.Classes.Eq (Cardano.Ledger.PoolDistr.PoolDistr c)
instance GHC.Show.Show (Cardano.Ledger.PoolDistr.PoolDistr c)
instance Control.Iterate.Exp.HasExp (Cardano.Ledger.PoolDistr.PoolDistr c) (Data.Map.Internal.Map (Cardano.Ledger.Keys.Internal.KeyHash 'Cardano.Ledger.Keys.Internal.StakePool c) (Cardano.Ledger.PoolDistr.IndividualPoolStake c))
instance Control.Iterate.BaseTypes.Embed (Cardano.Ledger.PoolDistr.PoolDistr c) (Data.Map.Internal.Map (Cardano.Ledger.Keys.Internal.KeyHash 'Cardano.Ledger.Keys.Internal.StakePool c) (Cardano.Ledger.PoolDistr.IndividualPoolStake c))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.PoolDistr.IndividualPoolStake c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.PoolDistr.IndividualPoolStake c)

module Cardano.Ledger.BaseTypes
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64
data () => WithOrigin t
Origin :: WithOrigin t
At :: !t -> WithOrigin t
data ProtVer
ProtVer :: !Version -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Version
[pvMinor] :: ProtVer -> !Natural
type FixedPoint = Digits34
(==>) :: Bool -> Bool -> Bool
infix 1 ==>

-- | Evolve the nonce
(⭒) :: Nonce -> Nonce -> Nonce
data Network
Testnet :: Network
Mainnet :: Network
networkToWord8 :: Network -> Word8
word8ToNetwork :: Word8 -> Maybe Network

-- | Evolving nonce type.
data Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce

-- | Identity element
NeutralNonce :: Nonce

-- | Seed to the verifiable random function.
newtype Seed
Seed :: Hash Blake2b_256 Seed -> Seed

-- | Type to represent a value in the unit interval [0; 1]
data UnitInterval

-- | Type to represent a value in the unit interval (0; 1]
data PositiveUnitInterval

-- | Type to represent a value in the interval (0; +∞)
data PositiveInterval

-- | Type to represent a value in the interval [0; +∞)
data NonNegativeInterval

-- | Type clases that allows conversion between <a>Rational</a> and some
--   form of bounded rational type. Bounds can be restricted by both the
--   <a>Bounded</a> type class and underlyng representation.
--   
--   <pre>
--   maybe True (\br -&gt; minBound &lt;= br &amp;&amp; br &lt;= maxBound) . boundRational
--   </pre>
--   
--   Roundtrip properties must hold:
--   
--   <pre>
--   \r -&gt; maybe True ((r ==) . unboundRational) (boundRational r)
--   \br -&gt; Just br == boundRational (unboundRational br)
--   </pre>
class Bounded r => BoundedRational r

-- | Returns <a>Nothing</a> when supplied value is not within bounds or
--   when precision is too high to be represented by the underlying type
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Ratio
--   
--   &gt;&gt;&gt; boundRational @UnitInterval $ 2 % 3
--   Just (2 % 3)
--   
--   &gt;&gt;&gt; boundRational @UnitInterval (-0.5)
--   Nothing
--   
--   &gt;&gt;&gt; boundRational @UnitInterval (1.5)
--   Nothing
--   
--   &gt;&gt;&gt; boundRational @UnitInterval 0
--   Just (0 % 1)
--   
--   &gt;&gt;&gt; boundRational @PositiveUnitInterval 0
--   Nothing
--   </pre>
boundRational :: BoundedRational r => Rational -> Maybe r

-- | Promote bounded rational type into the unbounded <a>Rational</a>.
unboundRational :: BoundedRational r => r -> Rational
fpPrecision :: FixedPoint
promoteRatio :: Integral a => Ratio a -> Rational
invalidKey :: MonadFail m => Word -> m a

-- | Make a nonce from the VRF output bytes
mkNonceFromOutputVRF :: OutputVRF v -> Nonce

-- | Make a nonce from a number.
mkNonceFromNumber :: Word64 -> Nonce
data Url
urlToText :: Url -> Text

-- | Turn a Text into a Url, fail if the Text has more than <tt>n</tt>
--   Bytes
textToUrl :: MonadFail m => Int -> Text -> m Url
data DnsName
dnsToText :: DnsName -> Text

-- | Turn a Text into a DnsName, fail if the Text has more than <tt>n</tt>
--   Bytes
textToDns :: MonadFail m => Int -> Text -> m DnsName
newtype Port
Port :: Word16 -> Port
[portToWord16] :: Port -> Word16
data ActiveSlotCoeff
mkActiveSlotCoeff :: PositiveUnitInterval -> ActiveSlotCoeff
activeSlotVal :: ActiveSlotCoeff -> PositiveUnitInterval
activeSlotLog :: ActiveSlotCoeff -> FixedPoint

-- | Blocks made
newtype BlocksMade c
BlocksMade :: Map (KeyHash 'StakePool c) Natural -> BlocksMade c
[unBlocksMade] :: BlocksMade c -> Map (KeyHash 'StakePool c) Natural

-- | Denotes a positive change in the EpochNo
newtype EpochInterval
EpochInterval :: Word32 -> EpochInterval
[unEpochInterval] :: EpochInterval -> Word32

-- | Add a EpochInterval (a positive change) to an EpochNo to get a new
--   EpochNo
addEpochInterval :: EpochNo -> EpochInterval -> EpochNo

-- | Helper function for a common pattern of creating objects
kindObject :: Text -> [Pair] -> Value

-- | Transaction index.
newtype TxIx
TxIx :: Word64 -> TxIx
txIxToInt :: TxIx -> Int
txIxFromIntegral :: Integral a => a -> Maybe TxIx

-- | Construct a <a>TxIx</a> from a 16 bit unsigned integer
mkTxIx :: Word16 -> TxIx

-- | Construct a <a>TxIx</a> from an arbitrary precision <a>Integer</a>.
--   Throws an error for values out of range. Make sure to use it only for
--   testing.
mkTxIxPartial :: HasCallStack => Integer -> TxIx

-- | Certificate index. Use <a>certIxFromIntegral</a> in order to construct
--   this index safely from anything other than <a>Word16</a>. There is
--   also <a>mkCertIxPartial</a> that can be used for testing.
newtype CertIx
CertIx :: Word64 -> CertIx
certIxToInt :: CertIx -> Int
certIxFromIntegral :: Integral a => a -> Maybe CertIx

-- | Construct a <a>CertIx</a> from a 16 bit unsigned integer
mkCertIx :: Word16 -> CertIx

-- | Construct a <a>CertIx</a> from an arbitrary precision <a>Integer</a>.
--   Throws an error for values out of range. Make sure to use it only for
--   testing.
mkCertIxPartial :: HasCallStack => Integer -> CertIx
data Anchor c
Anchor :: !Url -> !SafeHash c AnchorData -> Anchor c
[anchorUrl] :: Anchor c -> !Url
[anchorDataHash] :: Anchor c -> !SafeHash c AnchorData
newtype AnchorData
AnchorData :: ByteString -> AnchorData

-- | Hash <a>AnchorData</a>
hashAnchorData :: forall c. Crypto c => AnchorData -> SafeHash c AnchorData
data Globals
Globals :: !EpochInfo (Either Text) -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Version -> !Word64 -> !ActiveSlotCoeff -> !Network -> !SystemStart -> Globals
[epochInfo] :: Globals -> !EpochInfo (Either Text)
[slotsPerKESPeriod] :: Globals -> !Word64

-- | The window size in which our chosen chain growth property guarantees
--   at least k blocks. From the paper "Ouroboros praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol". The
--   <a>stabilityWindow</a> constant is used in a number of places; for
--   example, protocol updates must be submitted at least twice this many
--   slots before an epoch boundary.
[stabilityWindow] :: Globals -> !Word64

-- | Number of slots before the end of the epoch at which we stop updating
--   the candidate nonce for the next epoch.
[randomnessStabilisationWindow] :: Globals -> !Word64

-- | Maximum number of blocks we are allowed to roll back
[securityParameter] :: Globals -> !Word64

-- | Maximum number of KES iterations
[maxKESEvo] :: Globals -> !Word64

-- | Quorum for update system votes and MIR certificates
[quorum] :: Globals -> !Word64

-- | All blocks invalid after this protocol version
[maxMajorPV] :: Globals -> !Version

-- | Maximum number of lovelace in the system
[maxLovelaceSupply] :: Globals -> !Word64

-- | Active Slot Coefficient, named f in "Ouroboros Praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol"
[activeSlotCoeff] :: Globals -> !ActiveSlotCoeff

-- | The network ID
[networkId] :: Globals -> !Network

-- | System start time
[systemStart] :: Globals -> !SystemStart

-- | Pure epoch info via throw. Note that this should only be used when we
--   can guarantee the validity of the translation; in particular, the
--   <a>EpochInfo</a> used here should never be applied to user-supplied
--   input.
epochInfoPure :: Globals -> EpochInfo Identity
type ShelleyBase = ReaderT Globals Identity
class Inject t s
inject :: Inject t s => t -> s
inject :: (Inject t s, t ~ s) => t -> s
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.ProtVer
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Show.Show Cardano.Ledger.BaseTypes.ProtVer
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Generics.Generic (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.NonNegativeInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.PositiveInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.PositiveInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.PositiveInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.PositiveInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.UnitInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.UnitInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.UnitInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.UnitInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Nonce
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Nonce
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Nonce
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Nonce
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.Seed
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Seed
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Seed
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Seed
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Seed
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Seed
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Url
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Url
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Url
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Url
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.Url
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Url
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Url
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Url
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Url
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.DnsName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.DnsName
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.DnsName
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.DnsName
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.DnsName
instance GHC.Show.Show Cardano.Ledger.BaseTypes.DnsName
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.DnsName
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.DnsName
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.DnsName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Port
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Port
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Port
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Port
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.Port
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.Port
instance GHC.Num.Num Cardano.Ledger.BaseTypes.Port
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Port
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Port
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Port
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Port
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Show.Show Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Network
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Network
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Network
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Network
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Network
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Network
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.Network
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.Network
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Network
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Network
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Globals
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Globals
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.BaseTypes.BlocksMade c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.BaseTypes.BlocksMade c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.BaseTypes.BlocksMade c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.BaseTypes.BlocksMade c)
instance Control.DeepSeq.NFData (Cardano.Ledger.BaseTypes.BlocksMade c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.BaseTypes.BlocksMade c)
instance GHC.Show.Show (Cardano.Ledger.BaseTypes.BlocksMade c)
instance GHC.Generics.Generic (Cardano.Ledger.BaseTypes.BlocksMade c)
instance GHC.Classes.Eq (Cardano.Ledger.BaseTypes.BlocksMade c)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.TxIx
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.TxIx
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.TxIx
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.TxIx
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.TxIx
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.TxIx
instance GHC.Show.Show Cardano.Ledger.BaseTypes.TxIx
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.TxIx
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.TxIx
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.CertIx
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.CertIx
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.CertIx
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.CertIx
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.CertIx
instance GHC.Show.Show Cardano.Ledger.BaseTypes.CertIx
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.CertIx
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Ledger.SafeHash.SafeToHash Cardano.Ledger.BaseTypes.AnchorData
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.AnchorData
instance GHC.Generics.Generic (Cardano.Ledger.BaseTypes.Anchor c)
instance GHC.Show.Show (Cardano.Ledger.BaseTypes.Anchor c)
instance GHC.Classes.Ord (Cardano.Ledger.BaseTypes.Anchor c)
instance GHC.Classes.Eq (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.EpochInterval
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.EpochInterval
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.EpochInterval
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.EpochInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.EpochInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.EpochInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.EpochInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.EpochInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.EpochInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.EpochInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.EpochInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.EpochInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Nonce
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Nonce
instance GHC.Show.Show Cardano.Ledger.BaseTypes.EpochErr
instance NoThunks.Class.NoThunks (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Control.DeepSeq.NFData (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.BaseTypes.Anchor c)
instance Cardano.Ledger.SafeHash.HashWithCrypto Cardano.Ledger.BaseTypes.AnchorData Cardano.Ledger.BaseTypes.AnchorData
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Globals
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Globals
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.Network
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.Network
instance Data.Default.Class.Default Cardano.Ledger.BaseTypes.Network
instance GHC.Exception.Type.Exception Cardano.Ledger.BaseTypes.EpochErr
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.DnsName
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.Url
instance Cardano.Crypto.Util.SignableRepresentation Cardano.Ledger.BaseTypes.Seed
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.Nonce
instance GHC.Real.Integral a => GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.UnitInterval a)
instance Data.Default.Class.Default Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.PositiveUnitInterval GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.PositiveInterval GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.NonNegativeInterval GHC.Word.Word64)
instance (GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b a), GHC.Enum.Bounded a, GHC.Real.Integral a) => Cardano.Ledger.BaseTypes.BoundedRational (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Real.Integral a => GHC.Classes.Ord (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance (Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR a, GHC.Real.Integral a, GHC.Enum.Bounded a, Data.Typeable.Internal.Typeable b) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance (Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR a, GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b a), GHC.Enum.Bounded a, GHC.Real.Integral a, Data.Typeable.Internal.Typeable b, GHC.Show.Show a) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64)
instance Data.Fixed.HasResolution Cardano.Ledger.BaseTypes.E34
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.ProtVer
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.ProtVer
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.ProtVer
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Binary.Group.EncCBORGroup Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Binary.Group.DecCBORGroup Cardano.Ledger.BaseTypes.ProtVer


-- | Describes modes under which we might validate certain rules in the
--   ledger.
--   
--   What does this mean? Sometimes, we will want to check only certain
--   conditions specified in the rules. For example, when replaying a
--   previously validated chain, we do not care about rerunning _any_
--   checks, only making the relevant changes to the ledger state.
module Cardano.Ledger.Rules.ValidationMode

-- | Indicates that this check depends only upon the signal to the
--   transition, not the state or environment.
lblStatic :: Label

-- | Construct a static predicate check.
--   
--   The choice of <tt>#</tt> as a postfix here is made because often these
--   are crypto checks.
(?!#) :: Bool -> PredicateFailure sts -> Rule sts ctx ()
infix 1 ?!#

-- | Construct a static predicate check with an explanation.
--   
--   The choice of <tt>#</tt> as a postfix here is made because often these
--   are crypto checks.
(?!#:) :: Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()
infix 1 ?!#:

-- | Fail, if static checks are enabled.
failBecauseS :: PredicateFailure sts -> Rule sts ctx ()

-- | Apply an STS system and do not validate any static checks.
applySTSNonStatic :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (Either [PredicateFailure s] (State s))
applySTSValidateSuchThat :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ([Label] -> Bool) -> RuleContext rtype s -> m (Either [PredicateFailure s] (State s))
class Inject t s
inject :: Inject t s => t -> s
inject :: (Inject t s, t ~ s) => t -> s
type Test failure = Validation (NonEmpty failure) ()
runTest :: Inject t (PredicateFailure sts) => Test t -> Rule sts ctx ()
runTestOnSignal :: Inject t (PredicateFailure sts) => Test t -> Rule sts ctx ()

module Cardano.Ledger.Credential

-- | Script hash or key hash for a payment or a staking object.
--   
--   Note that credentials (unlike raw key hashes) do appear to vary from
--   era to era, since they reference the hash of a script, which can
--   change. This parameter is a phantom, however, so in actuality the
--   instances will remain the same.
data Credential (kr :: KeyRole) c
ScriptHashObj :: !ScriptHash c -> Credential (kr :: KeyRole) c
KeyHashObj :: !KeyHash kr c -> Credential (kr :: KeyRole) c
newtype GenesisCredential c
GenesisCredential :: KeyHash 'Genesis c -> GenesisCredential c
[unGenesisCredential] :: GenesisCredential c -> KeyHash 'Genesis c
type PaymentCredential c = Credential 'Payment c

-- | Convert a KeyHash into a Witness KeyHash. Does nothing for Script
--   credentials.
credKeyHashWitness :: Credential r c -> Maybe (KeyHash 'Witness c)

-- | Extract ScriptHash from a Credential. Returns Nothing for KeyHashes
credScriptHash :: Credential kr c -> Maybe (ScriptHash c)
credToText :: Credential kr c -> Text
parseCredential :: (MonadFail m, Crypto c) => Text -> m (Credential kr c)

-- | Pointer to a slot number, transaction index and an index in
--   certificate list.
data Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr
ptrSlotNo :: Ptr -> SlotNo
ptrTxIx :: Ptr -> TxIx
ptrCertIx :: Ptr -> CertIx
type StakeCredential c = Credential 'Staking c
data StakeReference c
StakeRefBase :: !StakeCredential c -> StakeReference c
StakeRefPtr :: !Ptr -> StakeReference c
StakeRefNull :: StakeReference c

-- | Convert any invalid <a>Ptr</a> to a <a>Ptr</a> that contains all zeros
--   for its fields. Any pointer that contains a <a>SlotNo</a>, <a>TxIx</a>
--   or <a>CertIx</a> that is too large to fit into <a>Word32</a>,
--   <a>Word16</a> and <a>Word16</a> respectively is considered to be an
--   invalid <a>Ptr</a>. Valid <a>Ptr</a>s will be returned unmodified.
--   
--   <i>Note</i> - This is in no way related to dangling pointers, with an
--   exception that any invalid <a>Ptr</a> is guarateed to be a dangling
--   <a>Ptr</a>.
normalizePtr :: Ptr -> Ptr
instance GHC.Classes.Ord (Cardano.Ledger.Credential.Credential kr c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Credential.Credential kr c)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.Credential kr c)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.Credential kr c)
instance GHC.Show.Show (Cardano.Ledger.Credential.Credential kr c)
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Credential.Ptr
instance NoThunks.Class.NoThunks Cardano.Ledger.Credential.Ptr
instance Control.DeepSeq.NFData Cardano.Ledger.Credential.Ptr
instance GHC.Generics.Generic Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Ord Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Eq Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Ord (Cardano.Ledger.Credential.StakeReference c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Credential.StakeReference c)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.StakeReference c)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.StakeReference c)
instance GHC.Show.Show (Cardano.Ledger.Credential.StakeReference c)
instance GHC.Show.Show (Cardano.Ledger.Credential.GenesisCredential c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Credential.GenesisCredential c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Credential.GenesisCredential c)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.GenesisCredential c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Credential.StakeReference c)
instance GHC.Classes.Ord (Cardano.Ledger.Credential.GenesisCredential c)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.GenesisCredential c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Credential.StakeReference c)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Credential.Ptr
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Credential.Ptr
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Credential.Ptr
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Ledger.Credential.Ptr
instance GHC.Show.Show Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Binary.Group.EncCBORGroup Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Binary.Group.DecCBORGroup Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Crypto.Crypto e => Data.Default.Class.Default (Cardano.Ledger.Credential.Credential r e)
instance Cardano.Ledger.Keys.Internal.HasKeyRole Cardano.Ledger.Credential.Credential
instance NoThunks.Class.NoThunks (Cardano.Ledger.Credential.Credential kr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Credential.Credential kr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Credential.Credential kr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Credential.Credential kr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Credential.Credential kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Credential.Credential kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Credential.Credential kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Credential.Credential kr c)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Credential.Credential kr c)

module Cardano.Ledger.Coin

-- | The amount of value held by a transaction output.
newtype Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data CompactForm a :: Type
newtype DeltaCoin
DeltaCoin :: Integer -> DeltaCoin
word64ToCoin :: Word64 -> Coin
coinToRational :: Coin -> Rational
rationalToCoinViaFloor :: Rational -> Coin
rationalToCoinViaCeiling :: Rational -> Coin
addDeltaCoin :: Coin -> DeltaCoin -> Coin
toDeltaCoin :: Coin -> DeltaCoin
integerToWord64 :: Integer -> Maybe Word64
decodePositiveCoin :: String -> Decoder s Coin
compactCoinOrError :: HasCallStack => Coin -> CompactForm Coin
instance Cardano.HeapWords.HeapWords Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Coin.Coin
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Coin.Coin
instance Data.PartialOrd.PartialOrd Cardano.Ledger.Coin.Coin
instance Data.Group.Abelian Cardano.Ledger.Coin.Coin
instance Data.Group.Group Cardano.Ledger.Coin.Coin
instance GHC.Base.Monoid Cardano.Ledger.Coin.Coin
instance GHC.Base.Semigroup Cardano.Ledger.Coin.Coin
instance GHC.Show.Show Cardano.Ledger.Coin.Coin
instance Control.DeepSeq.NFData Cardano.Ledger.Coin.Coin
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Coin.Coin
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Coin.Coin
instance GHC.Generics.Generic Cardano.Ledger.Coin.Coin
instance NoThunks.Class.NoThunks Cardano.Ledger.Coin.Coin
instance GHC.Enum.Enum Cardano.Ledger.Coin.Coin
instance GHC.Classes.Ord Cardano.Ledger.Coin.Coin
instance GHC.Classes.Eq Cardano.Ledger.Coin.Coin
instance Data.Group.Abelian (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.Group.Group (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Base.Monoid (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Base.Semigroup (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Classes.Ord (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.Primitive.Types.Prim (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Control.DeepSeq.NFData (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Coin.DeltaCoin
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Coin.DeltaCoin
instance Control.DeepSeq.NFData Cardano.Ledger.Coin.DeltaCoin
instance Data.PartialOrd.PartialOrd Cardano.Ledger.Coin.DeltaCoin
instance Data.Group.Abelian Cardano.Ledger.Coin.DeltaCoin
instance Data.Group.Group Cardano.Ledger.Coin.DeltaCoin
instance GHC.Base.Monoid Cardano.Ledger.Coin.DeltaCoin
instance GHC.Base.Semigroup Cardano.Ledger.Coin.DeltaCoin
instance GHC.Show.Show Cardano.Ledger.Coin.DeltaCoin
instance Cardano.HeapWords.HeapWords Cardano.Ledger.Coin.DeltaCoin
instance NoThunks.Class.NoThunks Cardano.Ledger.Coin.DeltaCoin
instance GHC.Enum.Enum Cardano.Ledger.Coin.DeltaCoin
instance GHC.Generics.Generic Cardano.Ledger.Coin.DeltaCoin
instance GHC.Classes.Ord Cardano.Ledger.Coin.DeltaCoin
instance GHC.Classes.Eq Cardano.Ledger.Coin.DeltaCoin
instance Data.Primitive.Types.Prim (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Control.DeepSeq.NFData (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Ledger.BaseTypes.Inject Cardano.Ledger.Coin.Coin Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Ledger.Compactible.Compactible Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Ledger.BaseTypes.Inject Cardano.Ledger.Coin.Coin Cardano.Ledger.Coin.Coin
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Compactible.Compactible Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)

module Cardano.Ledger.Rewards

-- | The staking rewards in Cardano are all either:
--   
--   <ul>
--   <li>member rewards - rewards given to a registered stake credential
--   which has delegated to a stake pool, or</li>
--   <li>leader rewards - rewards given to a registered stake pool (in
--   particular, given to the stake credential in the stake pool
--   registration certificate).</li>
--   </ul>
--   
--   See Figure 47, "Functions used in the Reward Splitting", of the
--   <a>formal specification</a> for more details.
data RewardType
MemberReward :: RewardType
LeaderReward :: RewardType

-- | The <a>Reward</a> type captures:
--   
--   <ul>
--   <li>if the reward is a member or leader reward</li>
--   <li>the stake pool ID associated with the reward</li>
--   <li>the number of Lovelace in the reward</li>
--   </ul>
data Reward c
Reward :: !RewardType -> !KeyHash 'StakePool c -> !Coin -> Reward c
[rewardType] :: Reward c -> !RewardType
[rewardPool] :: Reward c -> !KeyHash 'StakePool c
[rewardAmount] :: Reward c -> !Coin
instance GHC.Generics.Generic Cardano.Ledger.Rewards.RewardType
instance GHC.Enum.Enum Cardano.Ledger.Rewards.RewardType
instance GHC.Enum.Bounded Cardano.Ledger.Rewards.RewardType
instance GHC.Classes.Ord Cardano.Ledger.Rewards.RewardType
instance GHC.Show.Show Cardano.Ledger.Rewards.RewardType
instance GHC.Classes.Eq Cardano.Ledger.Rewards.RewardType
instance GHC.Generics.Generic (Cardano.Ledger.Rewards.Reward c)
instance GHC.Show.Show (Cardano.Ledger.Rewards.Reward c)
instance GHC.Classes.Eq (Cardano.Ledger.Rewards.Reward c)
instance GHC.Classes.Ord (Cardano.Ledger.Rewards.Reward c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Rewards.Reward c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Rewards.Reward c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Rewards.Reward c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Rewards.Reward c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Rewards.Reward c)
instance NoThunks.Class.NoThunks Cardano.Ledger.Rewards.RewardType
instance Control.DeepSeq.NFData Cardano.Ledger.Rewards.RewardType
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Rewards.RewardType
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Rewards.RewardType
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Rewards.RewardType

module Cardano.Ledger.Plutus.ExUnits

-- | Compute the cost of a script based upon prices and the number of
--   execution units.
txscriptfee :: Prices -> ExUnits -> Coin

-- | It is deliberate that there is no <a>Ord</a> instance for
--   <a>ExUnits</a>. Use this function to compare if one <tt>ExUnit</tt> is
--   pointwise compareable to another. In case when <a>Ord</a> instance
--   like comparison is necessary you can use <tt><a>zipSemiExUnits</a>
--   <a>compare</a></tt>
pointWiseExUnits :: (Natural -> Natural -> Bool) -> ExUnits -> ExUnits -> Bool

-- | Pointwise combine units into a semigroup and mappened the results.
zipSemiExUnits :: Semigroup a => (Natural -> Natural -> a) -> ExUnits -> ExUnits -> a

-- | This newtype wrapper of ExUnits' is used to hide an implementation
--   detail inside the ExUnits pattern.
newtype ExUnits
WrapExUnits :: ExUnits' Natural -> ExUnits
[unWrapExUnits] :: ExUnits -> ExUnits' Natural

-- | Arbitrary execution unit in which we measure the cost of scripts in
--   terms of space in memory and execution time.
--   
--   This pattern hides the fact that ExUnits' is parametric in the
--   underlying type. The ledger itself uses <a>ExUnits</a> Natural'
--   exclusively.
--   
--   We would have preferred to use a type alias for <a>ExUnits</a>
--   Natural', but this is not possible:
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/19507</a>.
pattern ExUnits :: Natural -> Natural -> ExUnits

-- | Arbitrary execution unit in which we measure the cost of scripts in
--   terms of space in memory and execution time.
--   
--   The ledger itself uses <a>ExUnits</a> Natural' exclusively, but the
--   flexibility here allows the consensus layer to translate the execution
--   units into something equivalent to 'ExUnits (Inf Natural)'. This is
--   needed in order to provide a <a>BoundedMeasure</a> instance, which
--   itself is needed for the alonzo instance of <tt>TxLimits</tt> (in
--   consensus).
data ExUnits' a
ExUnits' :: !a -> !a -> ExUnits' a
[exUnitsMem'] :: ExUnits' a -> !a
[exUnitsSteps'] :: ExUnits' a -> !a

-- | Prices per execution unit
data Prices
Prices :: !NonNegativeInterval -> !NonNegativeInterval -> Prices
[prMem] :: Prices -> !NonNegativeInterval
[prSteps] :: Prices -> !NonNegativeInterval
instance Data.Measure.Class.Measure a => GHC.Base.Semigroup (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance Data.Measure.Class.Measure a => GHC.Base.Monoid (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance Data.Measure.Class.BoundedMeasure a => Data.Measure.Class.BoundedMeasure (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.Measure (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance GHC.Base.Functor Cardano.Ledger.Plutus.ExUnits.ExUnits'
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance GHC.Base.Semigroup Cardano.Ledger.Plutus.ExUnits.ExUnits
instance GHC.Base.Monoid Cardano.Ledger.Plutus.ExUnits.ExUnits
instance GHC.Show.Show Cardano.Ledger.Plutus.ExUnits.ExUnits
instance GHC.Generics.Generic Cardano.Ledger.Plutus.ExUnits.ExUnits
instance GHC.Classes.Eq Cardano.Ledger.Plutus.ExUnits.ExUnits
instance GHC.Classes.Ord Cardano.Ledger.Plutus.ExUnits.Prices
instance GHC.Show.Show Cardano.Ledger.Plutus.ExUnits.Prices
instance GHC.Generics.Generic Cardano.Ledger.Plutus.ExUnits.Prices
instance GHC.Classes.Eq Cardano.Ledger.Plutus.ExUnits.Prices
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.ExUnits.Prices
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.ExUnits.Prices
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.ExUnits.Prices
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Plutus.ExUnits.Prices
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.ExUnits.Prices
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.ExUnits.Prices
instance NoThunks.Class.NoThunks Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Control.DeepSeq.NFData Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.ExUnits.ExUnits
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Ledger.Plutus.ExUnits.ExUnits' a)

module Cardano.Ledger.Plutus.ToPlutusData
class ToPlutusData x
toPlutusData :: ToPlutusData x => x -> Data
fromPlutusData :: ToPlutusData x => Data -> Maybe x
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.BaseTypes.EpochInterval
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData a => Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData [a]
instance (GHC.Classes.Ord a, Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData a, Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData b) => Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData (Data.Map.Internal.Map a b)
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.Binary.Version.Version
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.Plutus.CostModels.CostModels
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.Plutus.ExUnits.ExUnits
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData Cardano.Ledger.Plutus.ExUnits.Prices
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Word.Word32
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Word.Word16
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Word.Word8
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Num.Natural.Natural
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Num.Integer.Integer
instance Cardano.Ledger.Plutus.ToPlutusData.ToPlutusData GHC.Types.Word

module Cardano.Ledger.DRep
data DRep c
DRepAlwaysAbstain :: DRep c
DRepAlwaysNoConfidence :: DRep c
pattern DRepCredential :: Credential 'DRepRole c -> DRep c
data DRepState c
DRepState :: !EpochNo -> !StrictMaybe (Anchor c) -> !Coin -> DRepState c
[drepExpiry] :: DRepState c -> !EpochNo
[drepAnchor] :: DRepState c -> !StrictMaybe (Anchor c)
[drepDeposit] :: DRepState c -> !Coin
drepExpiryL :: Lens' (DRepState c) EpochNo
drepAnchorL :: Lens' (DRepState c) (StrictMaybe (Anchor c))
drepDepositL :: Lens' (DRepState c) Coin
instance Control.DeepSeq.NFData (Cardano.Ledger.DRep.DRep c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.DRep.DRep c)
instance GHC.Generics.Generic (Cardano.Ledger.DRep.DRep c)
instance GHC.Classes.Ord (Cardano.Ledger.DRep.DRep c)
instance GHC.Classes.Eq (Cardano.Ledger.DRep.DRep c)
instance GHC.Show.Show (Cardano.Ledger.DRep.DRep c)
instance GHC.Generics.Generic (Cardano.Ledger.DRep.DRepState c)
instance GHC.Classes.Ord (Cardano.Ledger.DRep.DRepState c)
instance GHC.Classes.Eq (Cardano.Ledger.DRep.DRepState c)
instance GHC.Show.Show (Cardano.Ledger.DRep.DRepState c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.DRep.DRepState era)
instance Cardano.Ledger.Crypto.Crypto c => Control.DeepSeq.NFData (Cardano.Ledger.DRep.DRepState c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.DRep.DRepState c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.DRep.DRepState c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.DRep.DRepState c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.DRep.DRepState c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.DRep.DRep c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.DRep.DRep c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.DRep.DRep c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.DRep.DRep c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.DRep.DRep c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.DRep.DRep c)

module Cardano.Ledger.Address

-- | <i>Deprecated: In favor of <a>RewardAcnt</a></i>
mkRwdAcnt :: Network -> Credential 'Staking c -> RewardAcnt c

-- | Serialise an address to the external format.
serialiseAddr :: Addr c -> ByteString

-- | Deserialise an address from the external format. This will fail if the
--   input data is not in the right format (or if there is trailing data).

-- | <i>Deprecated: In favor of <a>decodeAddr</a> or
--   <a>decodeAddrLenient</a>. Please choose the appropriate variant
--   carefully depending on your use case</i>
deserialiseAddr :: Crypto c => ByteString -> Maybe (Addr c)

-- | An address for UTxO.
--   
--   Contents of Addr data type are intentionally left as lazy, otherwise
--   operating on compact form of an address will result in redundant work.
data Addr c
Addr :: Network -> PaymentCredential c -> StakeReference c -> Addr c
AddrBootstrap :: BootstrapAddress c -> Addr c

-- | This function is implemented solely for the purpose of translating
--   garbage pointers into knowingly invalid ones. Any pointer that
--   contains a SlotNo, TxIx or CertIx that is too large to fit into
--   Word32, Word16 and Word16 respectively, will have all of its values
--   set to 0 using <a>normalizePtr</a>.
--   
--   There are two reasons why we can safely do that at the Babbage/Conway
--   era boundary:
--   
--   <ul>
--   <li>Invalid pointers are no longer allowed in transactions starting
--   with Babbage era</li>
--   <li>There are only a handful of <a>Ptr</a>s on mainnet that are
--   invalid.</li>
--   </ul>
--   
--   Once the transition is complete and we are officially in Conway era,
--   this translation logic can be removed in favor of a fixed deserializer
--   that does the same thing for all eras prior to Babbage.
addrPtrNormalize :: Addr c -> Addr c
newtype BootstrapAddress c
BootstrapAddress :: Address -> BootstrapAddress c
[unBootstrapAddress] :: BootstrapAddress c -> Address

-- | The size of the extra attributes in a bootstrp (ie Byron) address.
--   Used to help enforce that people do not post huge ones on the chain.
bootstrapAddressAttrsSize :: BootstrapAddress c -> Int

-- | Return True if a given address is a redeemer address from the Byron
--   Era
isBootstrapRedeemer :: BootstrapAddress c -> Bool

-- | Lookup a Network Id for an Address
getNetwork :: Addr c -> Network

-- | An account based address for rewards
data RewardAcnt c
RewardAcnt :: !Network -> !Credential 'Staking c -> RewardAcnt c
[getRwdNetwork] :: RewardAcnt c -> !Network
[getRwdCred] :: RewardAcnt c -> !Credential 'Staking c

-- | Serialise a reward account to the external format.
serialiseRewardAcnt :: RewardAcnt c -> ByteString

-- | Deserialise a reward account from the external format. This will fail
--   if the input data is not in the right format (or if there is trailing
--   data).
deserialiseRewardAcnt :: Crypto c => ByteString -> Maybe (RewardAcnt c)
bootstrapKeyHash :: forall c. Crypto c => BootstrapAddress c -> KeyHash 'Payment c
putAddr :: Addr c -> Put
putCredential :: Credential kr c -> Put
putPtr :: Ptr -> Put
putRewardAcnt :: RewardAcnt c -> Put
putVariableLengthWord64 :: Word64 -> Put
newtype Word7
Word7 :: Word8 -> Word7
toWord7 :: Word8 -> Word7

-- | Convert Byron's comapct address into <a>CompactAddr</a>. This is just
--   an efficient type cast.
fromBoostrapCompactAddress :: CompactAddress -> CompactAddr c
compactAddr :: Addr c -> CompactAddr c
decompactAddr :: forall c. (HasCallStack, Crypto c) => CompactAddr c -> Addr c
data CompactAddr c

-- | Unwrap the compact address and get to the address' binary
--   representation.
unCompactAddr :: CompactAddr c -> ShortByteString

-- | Efficiently check whether compacted adddress is an address with a
--   credential that is a payment script.
isPayCredScriptCompactAddr :: CompactAddr c -> Bool

-- | Efficiently check whether compated adddress is a Byron address.
isBootstrapCompactAddr :: CompactAddr c -> Bool

-- | Strict decoder for an address from a <a>ByteString</a>. This will not
--   let you decode some of the buggy addresses that have been placed on
--   chain. This decoder is intended for addresses that are to be placed on
--   chian today.
decodeAddr :: forall c m. (Crypto c, MonadFail m) => ByteString -> m (Addr c)

-- | Same as <a>decodeAddr</a>, but produces an <a>Either</a> result
decodeAddrEither :: forall c. Crypto c => ByteString -> Either String (Addr c)

-- | Just like <a>decodeAddrStateLenientT</a>, but enforces the address to
--   be well-formed.
decodeAddrStateT :: (Crypto c, MonadFail m, AddressBuffer b) => b -> StateT Int m (Addr c)

-- | This is the most general decoder for a Cardano address. This function
--   is not meant to be used directly, but it is exported for convenice.
--   <a>decodeAddr</a> and other should be used instead.
--   
--   While decoding an Addr the header (the first byte in the buffer) is
--   expected to be in a certain format. Here are the meaning of all the
--   bits:
--   
--   @@@
--   
--   ┏━━━━━━━━━━━━━━━━┳━┯━┯━┯━┯━┯━┯━┯━┓ ┃ Byron Address ┃1┊0┊0┊0┊0┊0┊1┊0┃
--   ┣━━━━━━━━━━━━━━━━╋━┿━┿━┿━┿━┿━┿━┿━┫ ┃Shelley Address ┃0┊x┊x┊x┊0┊0┊0┊x┃
--   ┗━━━━━━━━━━━━━━━━╋━┿━┿━┿━┿━┿━┿━┿━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
--   ┃0┊0┊0┊0┊0┊0┊0┊0┃ Testnet PaymentKey StakingKey ┃ ┃0┊0┊0┊0┊0┊0┊0┊1┃
--   Mainnet PaymentKey StakingKey ┃ ┃0┊0┊0┊1┊0┊0┊0┊0┃ Testnet
--   PaymentScript StakingKey ┃ ┃0┊0┊0┊1┊0┊0┊0┊1┃ Mainnet PaymentScript
--   StakingKey ┃ ┃0┊0┊1┊0┊0┊0┊0┊0┃ Testnet PaymentKey StakingScript ┃
--   ┃0┊0┊1┊0┊0┊0┊0┊1┃ Mainnet PaymentKey StakingScript ┃ ┃0┊0┊1┊1┊0┊0┊0┊0┃
--   Testnet PaymentScript StakingScript ┃ ┃0┊0┊1┊1┊0┊0┊0┊1┃ Mainnet
--   PaymentScript StakingScript ┃ ┃0┊1┊0┊0┊0┊0┊0┊0┃ Testnet PaymentKey
--   StakingPtr ┃ ┃0┊1┊0┊0┊0┊0┊0┊1┃ Mainnet PaymentKey StakingPtr ┃
--   ┃0┊1┊0┊1┊0┊0┊0┊0┃ Testnet PaymentScript StakingPtr ┃ ┃0┊1┊0┊1┊0┊0┊0┊1┃
--   Mainnet PaymentScript StakingPtr ┃ ┃0┊1┊1┊0┊0┊0┊0┊0┃ Testnet
--   PaymentKey StakingNull ┃ ┃0┊1┊1┊0┊0┊0┊0┊1┃ Mainnet PaymentKey
--   StakingNull ┃ ┃0┊1┊1┊1┊0┊0┊0┊0┃ Testnet PaymentScript StakingNull ┃
--   ┃0┊1┊1┊1┊0┊0┊0┊1┃ Mainnet PaymentScript StakingNull ┃
--   ┗━┷━┷━┷━┷━┷━┷━┷━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛ `Is Mainnet
--   Address `Payment Credential is a Script `Staking Credential is a
--   Script / No Staking Credential `Not a Base Address @@@
decodeAddrStateLenientT :: (Crypto c, MonadFail m, AddressBuffer b) => Bool -> Bool -> b -> StateT Int m (Addr c)

-- | Decoder for an <a>Addr</a>. Works in all eras
fromCborAddr :: forall c s. Crypto c => Decoder s (Addr c)

-- | This is the decoder for an address that returns both the actual
--   <a>Addr</a> and the bytes, that it was encoded as.
fromCborBothAddr :: forall c s. Crypto c => Decoder s (Addr c, CompactAddr c)

-- | Returns the actual bytes that represent an addres, while ensuring that
--   they can be decoded in any era as an <a>Addr</a> when need be.
fromCborCompactAddr :: forall c s. Crypto c => Decoder s (CompactAddr c)

-- | Prior to Babbage era we did not check if a binary blob representing an
--   address was fully consumed, so unfortunately we must preserve this
--   behavior. However, we do not need to preserve the unconsumed bytes in
--   memory, therefore we can to drop the garbage after we successfully
--   decoded the malformed address. We also need to allow bogus pointer
--   address to be deserializeable prior to Babbage era.
fromCborBackwardsBothAddr :: forall c s. Crypto c => Decoder s (Addr c, CompactAddr c)
decodeRewardAcnt :: forall c b m. (Crypto c, AddressBuffer b, MonadFail m) => b -> m (RewardAcnt c)
fromCborRewardAcnt :: forall c s. Crypto c => Decoder s (RewardAcnt c)

-- | This is called <tt>wdrl</tt> in the spec.
newtype Withdrawals c
Withdrawals :: Map (RewardAcnt c) Coin -> Withdrawals c
[unWithdrawals] :: Withdrawals c -> Map (RewardAcnt c) Coin
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Address.RewardAcnt c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Address.RewardAcnt c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.RewardAcnt c)
instance GHC.Classes.Ord (Cardano.Ledger.Address.RewardAcnt c)
instance GHC.Generics.Generic (Cardano.Ledger.Address.RewardAcnt c)
instance GHC.Classes.Eq (Cardano.Ledger.Address.RewardAcnt c)
instance GHC.Show.Show (Cardano.Ledger.Address.RewardAcnt c)
instance GHC.Show.Show Cardano.Ledger.Address.Word7
instance GHC.Classes.Eq Cardano.Ledger.Address.Word7
instance GHC.Show.Show (Cardano.Ledger.Address.BootstrapAddress c)
instance GHC.Classes.Ord (Cardano.Ledger.Address.BootstrapAddress c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.BootstrapAddress c)
instance GHC.Generics.Generic (Cardano.Ledger.Address.BootstrapAddress c)
instance GHC.Classes.Eq (Cardano.Ledger.Address.BootstrapAddress c)
instance GHC.Classes.Ord (Cardano.Ledger.Address.Addr c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.Addr c)
instance GHC.Generics.Generic (Cardano.Ledger.Address.Addr c)
instance GHC.Classes.Eq (Cardano.Ledger.Address.Addr c)
instance GHC.Show.Show (Cardano.Ledger.Address.Addr c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.CompactAddr c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.CompactAddr c)
instance GHC.Classes.Ord (Cardano.Ledger.Address.CompactAddr c)
instance GHC.Generics.Generic (Cardano.Ledger.Address.CompactAddr c)
instance GHC.Classes.Eq (Cardano.Ledger.Address.CompactAddr c)
instance GHC.Num.Num Cardano.Ledger.Address.Header
instance GHC.Bits.Bits Cardano.Ledger.Address.Header
instance GHC.Classes.Ord Cardano.Ledger.Address.Header
instance GHC.Classes.Eq Cardano.Ledger.Address.Header
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Address.Withdrawals c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Address.Withdrawals c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.Withdrawals c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.Withdrawals c)
instance GHC.Generics.Generic (Cardano.Ledger.Address.Withdrawals c)
instance GHC.Classes.Eq (Cardano.Ledger.Address.Withdrawals c)
instance GHC.Show.Show (Cardano.Ledger.Address.Withdrawals c)
instance GHC.Show.Show Cardano.Ledger.Address.Header
instance Cardano.Ledger.Address.AddressBuffer Data.ByteString.Short.Internal.ShortByteString
instance Cardano.Ledger.Address.AddressBuffer Data.ByteString.Internal.Type.ByteString
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.Address.CompactAddr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Address.CompactAddr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Address.CompactAddr c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.Addr c)
instance Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Address.Addr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Address.Addr c)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Address.Addr c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Address.Addr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Address.Addr c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Address.Addr c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.BootstrapAddress c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.Address.RewardAcnt c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Address.RewardAcnt c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Address.RewardAcnt c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.RewardAcnt c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Address.RewardAcnt c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Address.RewardAcnt c)

module Cardano.Ledger.PoolParams

-- | A stake pool.
data PoolParams c
PoolParams :: !KeyHash 'StakePool c -> !Hash c (VerKeyVRF c) -> !Coin -> !Coin -> !UnitInterval -> !RewardAcnt c -> !Set (KeyHash 'Staking c) -> !StrictSeq StakePoolRelay -> !StrictMaybe PoolMetadata -> PoolParams c
[ppId] :: PoolParams c -> !KeyHash 'StakePool c
[ppVrf] :: PoolParams c -> !Hash c (VerKeyVRF c)
[ppPledge] :: PoolParams c -> !Coin
[ppCost] :: PoolParams c -> !Coin
[ppMargin] :: PoolParams c -> !UnitInterval
[ppRewardAcnt] :: PoolParams c -> !RewardAcnt c
[ppOwners] :: PoolParams c -> !Set (KeyHash 'Staking c)
[ppRelays] :: PoolParams c -> !StrictSeq StakePoolRelay
[ppMetadata] :: PoolParams c -> !StrictMaybe PoolMetadata
data PoolMetadata
PoolMetadata :: !Url -> !ByteString -> PoolMetadata
[pmUrl] :: PoolMetadata -> !Url
[pmHash] :: PoolMetadata -> !ByteString
data StakePoolRelay

-- | One or both of IPv4 &amp; IPv6
SingleHostAddr :: !StrictMaybe Port -> !StrictMaybe IPv4 -> !StrictMaybe IPv6 -> StakePoolRelay

-- | An <tt>A</tt> or <tt>AAAA</tt> DNS record
SingleHostName :: !StrictMaybe Port -> !DnsName -> StakePoolRelay

-- | A <tt>SRV</tt> DNS record
MultiHostName :: !DnsName -> StakePoolRelay

-- | The size of the <a>ppRelays</a> <a>Set</a>. Only used to compute size
--   of encoded <a>PoolParams</a>.
data SizeOfPoolRelays
SizeOfPoolRelays :: SizeOfPoolRelays

-- | The size of the <a>ppOwners</a> <a>Set</a>. Only used to compute size
--   of encoded <a>PoolParams</a>.
data SizeOfPoolOwners
SizeOfPoolOwners :: SizeOfPoolOwners
instance GHC.Show.Show Cardano.Ledger.PoolParams.PoolMetadata
instance GHC.Generics.Generic Cardano.Ledger.PoolParams.PoolMetadata
instance GHC.Classes.Ord Cardano.Ledger.PoolParams.PoolMetadata
instance GHC.Classes.Eq Cardano.Ledger.PoolParams.PoolMetadata
instance GHC.Show.Show Cardano.Ledger.PoolParams.StakePoolRelay
instance GHC.Generics.Generic Cardano.Ledger.PoolParams.StakePoolRelay
instance GHC.Classes.Ord Cardano.Ledger.PoolParams.StakePoolRelay
instance GHC.Classes.Eq Cardano.Ledger.PoolParams.StakePoolRelay
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.PoolParams.PoolParams c)
instance GHC.Classes.Ord (Cardano.Ledger.PoolParams.PoolParams c)
instance GHC.Classes.Eq (Cardano.Ledger.PoolParams.PoolParams c)
instance GHC.Generics.Generic (Cardano.Ledger.PoolParams.PoolParams c)
instance GHC.Show.Show (Cardano.Ledger.PoolParams.PoolParams c)
instance Control.DeepSeq.NFData Cardano.Ledger.PoolParams.PoolMetadata
instance Control.DeepSeq.NFData (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.PoolParams.SizeOfPoolRelays
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Group.EncCBORGroup (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.PoolParams.SizeOfPoolOwners
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.PoolParams.PoolParams c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.PoolParams.PoolParams c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Group.DecCBORGroup (Cardano.Ledger.PoolParams.PoolParams c)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.PoolParams.StakePoolRelay
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.PoolParams.StakePoolRelay
instance NoThunks.Class.NoThunks Cardano.Ledger.PoolParams.StakePoolRelay
instance Control.DeepSeq.NFData Cardano.Ledger.PoolParams.StakePoolRelay
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.PoolParams.StakePoolRelay
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.PoolParams.StakePoolRelay
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.PoolParams.PoolMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.PoolParams.PoolMetadata
instance NoThunks.Class.NoThunks Cardano.Ledger.PoolParams.PoolMetadata
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.PoolParams.PoolMetadata
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.PoolParams.PoolMetadata

module Cardano.Ledger.AuxiliaryData
newtype AuxiliaryDataHash c
AuxiliaryDataHash :: SafeHash c EraIndependentTxAuxData -> AuxiliaryDataHash c
[unsafeAuxiliaryDataHash] :: AuxiliaryDataHash c -> SafeHash c EraIndependentTxAuxData

-- | <i>Deprecated: Use <a>EraTxAuxData</a> instead</i>
type ValidateAuxiliaryData era c = ()
instance Control.DeepSeq.NFData (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance GHC.Generics.Generic (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance GHC.Classes.Ord (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance GHC.Classes.Eq (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance GHC.Show.Show (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c)


-- | <i>Deprecated: Use <a>Binary</a> from 'cardano-ledger-binary' package
--   instead</i>
module Cardano.Ledger.Serialization
class Typeable a => EncCBORGroup a
encCBORGroup :: EncCBORGroup a => a -> Encoding
encodedGroupSizeExpr :: EncCBORGroup a => (forall x. EncCBOR x => Proxy x -> Size) -> Proxy a -> Size
listLen :: EncCBORGroup a => a -> Word
listLenBound :: EncCBORGroup a => Proxy a -> Word
class Typeable a => DecCBORGroup a
decCBORGroup :: DecCBORGroup a => Decoder s a
newtype () => CBORGroup a
CBORGroup :: a -> CBORGroup a
[unCBORGroup] :: CBORGroup a -> a
decodeList :: Decoder s a -> Decoder s [a]
decodeSeq :: Decoder s a -> Decoder s (Seq a)
decodeStrictSeq :: Decoder s a -> Decoder s (StrictSeq a)
decodeSet :: Ord a => Decoder s a -> Decoder s (Set a)
decodeMap :: Ord k => Decoder s k -> Decoder s v -> Decoder s (Map k v)
decodeMapContents :: Decoder s a -> Decoder s [a]
decodeMapTraverse :: (Ord a, Applicative t) => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t (Map a b))
decodeMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: Text -> (Word -> Decoder s (Int, a)) -> Decoder s a
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)
encodeFoldable :: (EncCBOR a, Foldable f) => f a -> Encoding
encodeFoldableEncoder :: Foldable f => (a -> Encoding) -> f a -> Encoding
encodeFoldableMapEncoder :: Foldable f => (Word -> a -> Maybe Encoding) -> f a -> Encoding
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeMap :: (k -> Encoding) -> (v -> Encoding) -> Map k v -> Encoding
groupRecord :: (EncCBORGroup a, DecCBORGroup a) => Decoder s a
ratioEncCBOR :: EncCBOR a => Ratio a -> Encoding
ratioDecCBOR :: (Integral a, DecCBOR a) => Decoder s (Ratio a)
mapEncCBOR :: (EncCBOR a, EncCBOR b) => Map a b -> Encoding
mapDecCBOR :: (Ord a, DecCBOR a, DecCBOR b) => Decoder s (Map a b)
translateViaCBORAnnotator :: (ToCBOR a, DecCBOR (Annotator b)) => Version -> Text -> a -> Except DecoderError b
ipv4ToBytes :: IPv4 -> ByteString
ipv4FromBytes :: ByteString -> Either String IPv4
ipv4EncCBOR :: IPv4 -> Encoding
ipv4DecCBOR :: Decoder s IPv4
ipv6ToBytes :: IPv6 -> ByteString
ipv6FromBytes :: ByteString -> Either String IPv6
ipv6EncCBOR :: IPv6 -> Encoding
ipv6DecCBOR :: Decoder s IPv6
listLenInt :: EncCBORGroup a => a -> Int
runByteBuilder :: Int -> Builder -> ByteString
utcTimeEncCBOR :: UTCTime -> Encoding
utcTimeDecCBOR :: Decoder s UTCTime
data () => Sized a
Sized :: !a -> Int64 -> Sized a
[sizedValue] :: Sized a -> !a
[sizedSize] :: Sized a -> Int64
mkSized :: EncCBOR a => Version -> a -> Sized a
sizedDecoder :: Decoder s a -> Decoder s (Sized a)
toSizedL :: EncCBOR s => Version -> Lens' s a -> Lens' (Sized s) a

module Cardano.Ledger.Slot
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype Duration
Duration :: Word64 -> Duration
[unDuration] :: Duration -> Word64
(-*) :: SlotNo -> SlotNo -> Duration
(+*) :: SlotNo -> Duration -> SlotNo

-- | Subtract a duration from a slot
(*-) :: SlotNo -> Duration -> SlotNo
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64
data () => EpochInfo (m :: Type -> Type)
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
epochInfoEpoch :: HasCallStack => EpochInfo Identity -> SlotNo -> ShelleyBase EpochNo
epochInfoFirst :: HasCallStack => EpochInfo Identity -> EpochNo -> ShelleyBase SlotNo
epochInfoSize :: HasCallStack => EpochInfo Identity -> EpochNo -> ShelleyBase EpochSize
instance GHC.Show.Show Cardano.Ledger.Slot.Duration
instance GHC.Enum.Enum Cardano.Ledger.Slot.Duration
instance GHC.Real.Real Cardano.Ledger.Slot.Duration
instance GHC.Real.Integral Cardano.Ledger.Slot.Duration
instance GHC.Num.Num Cardano.Ledger.Slot.Duration
instance NoThunks.Class.NoThunks Cardano.Ledger.Slot.Duration
instance GHC.Classes.Ord Cardano.Ledger.Slot.Duration
instance GHC.Generics.Generic Cardano.Ledger.Slot.Duration
instance GHC.Classes.Eq Cardano.Ledger.Slot.Duration
instance GHC.Base.Semigroup Cardano.Ledger.Slot.Duration
instance GHC.Base.Monoid Cardano.Ledger.Slot.Duration

module Cardano.Ledger.BHeaderView

-- | <a>BHeaderView</a> provides an interface between block headers from
--   different Cardano protocols and packages that should be agnostic of
--   Cardano protocol specific details, such as those in TPraos, Praos,
--   Genesis, etc.
--   
--   In particular, the <tt>BBODY</tt> rule comprises most of the ledger
--   logic and should work independently of the protocol. The values in
--   <a>BHeaderView</a> provide <tt>BBODY</tt> all the data that it needs
--   from the block headers.
data BHeaderView c
BHeaderView :: KeyHash 'BlockIssuer c -> Word32 -> Int -> Hash c EraIndependentBlockBody -> SlotNo -> BHeaderView c

-- | The block issuer. In the TPraos protocol, this can be a Genesis
--   delegate, everywhere else it is the stake pool ID.
[bhviewID] :: BHeaderView c -> KeyHash 'BlockIssuer c

-- | The purported size (in bytes) of the block body.
[bhviewBSize] :: BHeaderView c -> Word32

-- | The purported size (in bytes) of the block header.
[bhviewHSize] :: BHeaderView c -> Int

-- | The purported hash of the block body.
[bhviewBHash] :: BHeaderView c -> Hash c EraIndependentBlockBody

-- | The slot for which this block was submitted to the chain.
[bhviewSlot] :: BHeaderView c -> SlotNo

-- | Determine if the given slot is reserved for the overlay schedule.
isOverlaySlot :: SlotNo -> UnitInterval -> SlotNo -> Bool

module Cardano.Ledger.TxIn

-- | A unique ID of a transaction, which is computable from the
--   transaction.
newtype TxId c
TxId :: SafeHash c EraIndependentTxBody -> TxId c
[unTxId] :: TxId c -> SafeHash c EraIndependentTxBody

-- | <i>Deprecated: In favor of <a>unTxId</a></i>
_unTxId :: TxId c -> SafeHash c EraIndependentTxBody

-- | The input of a UTxO.
data TxIn c
TxIn :: !TxId c -> {-# UNPACK #-} !TxIx -> TxIn c

-- | Construct <a>TxIn</a> while throwing an error for an out of range
--   <a>TxIx</a>. Make sure to use it only for testing.
mkTxInPartial :: HasCallStack => TxId c -> Integer -> TxIn c
txInToText :: TxIn c -> Text

-- | Transaction index.
data TxIx
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.TxIn.TxId c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.TxIn.TxId c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.TxIn.TxId c)
instance GHC.Generics.Generic (Cardano.Ledger.TxIn.TxId c)
instance GHC.Classes.Ord (Cardano.Ledger.TxIn.TxId c)
instance GHC.Classes.Eq (Cardano.Ledger.TxIn.TxId c)
instance GHC.Show.Show (Cardano.Ledger.TxIn.TxId c)
instance GHC.Generics.Generic (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.HeapWords.HeapWords (Cardano.Ledger.TxIn.TxId c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.TxIn.TxId c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.TxIn.TxId c)
instance Cardano.Ledger.Crypto.Crypto c => Control.DeepSeq.NFData (Cardano.Ledger.TxIn.TxId c)
instance GHC.Classes.Eq (Cardano.Ledger.TxIn.TxIn c)
instance GHC.Classes.Ord (Cardano.Ledger.TxIn.TxIn c)
instance GHC.Show.Show (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Control.DeepSeq.NFData (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.HeapWords.HeapWords (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.TxIn.TxIn c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.TxIn.TxIn c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.TxIn.TxIn c)


-- | A <a>UMap</a> (for Unified map) represents
--   
--   <ol>
--   <li>4 Maps with the same domain in one direction, as a single
--   <a>Map</a> and</li>
--   <li>1 other <a>Map</a> which is an inverse of one of the other 4
--   Maps.</li>
--   </ol>
--   
--   The advantage of using <a>UMap</a> is that it stores all the
--   information compactly, by exploiting the large amount of sharing in
--   Map #1.
--   
--   As for the other Map #2, we don't expect it to have much volume.
module Cardano.Ledger.UMap

-- | A Reward-Deposit Pair Used to represent the reward and the deposit for
--   a given (Credential 'Staking c)
data RDPair
RDPair :: {-# UNPACK #-} !CompactForm Coin -> {-# UNPACK #-} !CompactForm Coin -> RDPair
[rdReward] :: RDPair -> {-# UNPACK #-} !CompactForm Coin
[rdDeposit] :: RDPair -> {-# UNPACK #-} !CompactForm Coin

-- | A <a>UMElem</a> compactly represents the range of 4 <a>Map</a>s with
--   the same domain as a single n-tuple.
--   
--   This space-compacting datatype, and the pattern <a>UMElem</a> are
--   equivalent to: <tt> data Elem c = Elem { rdPairT :: !(StrictMaybe
--   RDPair), ptrT :: !(Set Ptr), sPoolT :: !(StrictMaybe (KeyHash
--   'StakePool c)), -- the stake pool identity dRepT :: !(StrictMaybe
--   (DRep c)), } deriving (Show, Eq, Generic, NoThunks, NFData) </tt>
--   
--   To name the constructors of <a>UMElem</a> we use the notation
--   <tt>Txxx</tt> where each <tt>x</tt> is either <tt>F</tt> for full,
--   i.e. the component is present, or <tt>E</tt> for empty, i.e. the
--   component is not present.
--   
--   There are four components: 1) the reward-deposit pair as an
--   <a>RDPair</a> (CompactForm Coin) (CompactForm Coin) as a pair of
--   Word64s, the first <tt>x</tt>, 2) the set of pointers, the second
--   <tt>x</tt>, 3) the stake pool id (KeyHash 'StakePool c), the third
--   <tt>x</tt>, and 4) the voting delegatee id (DRep c), the fourth
--   <tt>x</tt>.
--   
--   So, TEEEE means none of the components are present, TFEEE means only
--   the reward-deposit pair is present, TEFEE means only the set of
--   pointers is present, TEEFE means only the stake pool id is present.
--   etc. TEEEF means only the voting delegatee id is present, and
--   
--   The pattern <a>UMElem</a> will correctly use the optimal constructor.
data UMElem c

-- | A <a>UMElem</a> can be extracted and injected into the <a>TEEEE</a>
--   ... <a>TFFFF</a> constructors.
pattern UMElem :: StrictMaybe RDPair -> Set Ptr -> StrictMaybe (KeyHash 'StakePool c) -> StrictMaybe (DRep c) -> UMElem c

-- | Extract the reward-deposit pair if it is present. We can tell that the
--   reward is present when Txxxx has an F in the first position
--   
--   This is equivalent to the pattern (ElemP (SJust r) _ _ _) -&gt; Just r
umElemRDPair :: UMElem c -> Maybe RDPair

-- | Extract a delegated reward-deposit pair if it is present. We can tell
--   that the pair is present and active when Txxxx has an F in the 1st
--   position (present) and 3rd position (delegated).
--   
--   This is equivalent to the pattern (ElemP (SJust r) _ (SJust _) _)
--   -&gt; Just r
umElemRDActive :: UMElem c -> Maybe RDPair

-- | Extract the set of pointers if it is non-empty. We can tell that the
--   reward is present when Txxxx has an F in the second position
--   
--   This is equivalent to the pattern (ElemP _ ptrs _ _) | not (Set.null
--   ptrs) -&gt; Just ptrs
umElemPtrs :: UMElem c -> Maybe (Set Ptr)

-- | Extract the stake delegatee pool id, if present. We can tell that the
--   pool id is present when Txxxx has an F in the third position
--   
--   This is equivalent to the pattern (ElemP _ _ (SJust s) _) -&gt; Just s
umElemSPool :: UMElem c -> Maybe (KeyHash 'StakePool c)

-- | Extract the voting delegatee id, if present. We can tell that the
--   delegatee is present when Txxxx has an F in the fourth position
--   
--   This is equivalent to the pattern (ElemP _ _ _ (SJust v)) -&gt; Just v
umElemDRep :: UMElem c -> Maybe (DRep c)

-- | A n-Tuple view of the <a>UMElem</a>. We can view all of the
--   constructors as an <a>UMElem</a>.
umElemAsTuple :: UMElem c -> (StrictMaybe RDPair, Set Ptr, StrictMaybe (KeyHash 'StakePool c), StrictMaybe (DRep c))

-- | <a>null</a> for an <a>UMElem</a>
nullUMElem :: UMElem c -> Bool

-- | <a>null</a> <a>Maybe</a> for an <a>UMElem</a>
nullUMElemMaybe :: UMElem c -> Maybe (UMElem c)

-- | A unified map represents 4 Maps with domain <tt>(Credential 'Staking
--   c)</tt>
--   
--   1) Map (Credential 'Staking c) RDPair -- (RDPair rewardCoin
--   depositCoin) 2) Map (Credential 'Staking c) (Set Ptr) 3) Map
--   (Credential 'Staking c) (StrictMaybe (KeyHash 'StakePool c)) 4) Map
--   (Credential 'Staking c) (StrictMaybe (DRep c)) and one more map in the
--   inverse direction with <tt>Ptr</tt> for keys and <tt>(Credential
--   'Staking c)</tt> for values.
data UMap c
UMap :: !Map (Credential 'Staking c) (UMElem c) -> !Map Ptr (Credential 'Staking c) -> UMap c
[umElems] :: UMap c -> !Map (Credential 'Staking c) (UMElem c)
[umPtrs] :: UMap c -> !Map Ptr (Credential 'Staking c)
umElemsL :: Lens' (UMap c) (Map (Credential 'Staking c) (UMElem c))

-- | Construct an empty <a>UMap</a>
empty :: UMap c

-- | It is worthwhile stating the invariant that holds on a Unified Map.
--   The <a>umPtrs</a> and the <tt>ptrT</tt> field of the <a>umElems</a>
--   are inverses.
umInvariant :: Credential 'Staking c -> Ptr -> UMap c -> Bool

-- | All maps unrolled. It is important to note that all fields are lazy,
--   because conversion from UMap can be expensive, thus only fields that
--   are forced will incur that conversion overhead.
data StakeCredentials c
StakeCredentials :: Map (Credential 'Staking c) Coin -> Map (Credential 'Staking c) Coin -> Map (Credential 'Staking c) (KeyHash 'StakePool c) -> Map (Credential 'Staking c) (DRep c) -> Map Ptr (Credential 'Staking c) -> Map (Credential 'Staking c) (Set Ptr) -> StakeCredentials c
[scRewards] :: StakeCredentials c -> Map (Credential 'Staking c) Coin
[scDeposits] :: StakeCredentials c -> Map (Credential 'Staking c) Coin
[scSPools] :: StakeCredentials c -> Map (Credential 'Staking c) (KeyHash 'StakePool c)
[scDReps] :: StakeCredentials c -> Map (Credential 'Staking c) (DRep c)
[scPtrs] :: StakeCredentials c -> Map Ptr (Credential 'Staking c)

-- | There will be no empty sets in the range
[scPtrsInverse] :: StakeCredentials c -> Map (Credential 'Staking c) (Set Ptr)
toStakeCredentials :: UMap c -> StakeCredentials c
domRestrictedStakeCredentials :: Set (Credential 'Staking c) -> UMap c -> StakeCredentials c

-- | A <a>UView</a> lets one view a <a>UMap</a> in <tt>n</tt> different
--   ways, one for each of the elements in a Unified Element <a>UMElem</a>
--   <tt>(4)</tt> A <tt>(UView c key value)</tt> can be used like a
--   <tt>(Map key value)</tt>. It acts like a map, supporting efficient
--   insert, delete, and lookup operations.
data UView c k v
[RewDepUView] :: !UMap c -> UView c (Credential 'Staking c) RDPair
[PtrUView] :: !UMap c -> UView c Ptr (Credential 'Staking c)
[SPoolUView] :: !UMap c -> UView c (Credential 'Staking c) (KeyHash 'StakePool c)
[DRepUView] :: !UMap c -> UView c (Credential 'Staking c) (DRep c)

-- | Construct a <a>RewDepUView</a> from the two maps that make up a
--   <a>UMap</a>
rewDepUView :: Map (Credential 'Staking c) (UMElem c) -> Map Ptr (Credential 'Staking c) -> UView c (Credential 'Staking c) RDPair

-- | Construct a <a>PtrUView</a> from the two maps that make up a
--   <a>UMap</a>
ptrUView :: Map (Credential 'Staking c) (UMElem c) -> Map Ptr (Credential 'Staking c) -> UView c Ptr (Credential 'Staking c)

-- | Construct a <a>SPoolUView</a> from the two maps that make up a
--   <a>UMap</a>
sPoolUView :: Map (Credential 'Staking c) (UMElem c) -> Map Ptr (Credential 'Staking c) -> UView c (Credential 'Staking c) (KeyHash 'StakePool c)

-- | Construct a <a>DRepUView</a> from the two maps that make up a
--   <a>UMap</a>
dRepUView :: Map (Credential 'Staking c) (UMElem c) -> Map Ptr (Credential 'Staking c) -> UView c (Credential 'Staking c) (DRep c)

-- | Extract the underlying <a>UMap</a> from a <a>UView</a>
unUView :: UView c k v -> UMap c

-- | Materialize a real <tt>VMap</tt> (Vector Map) from a <a>UView</a> This
--   is expensive, use it wisely (like maybe once per epoch boundary to
--   make a <tt>SnapShot</tt>)
unUnifyToVMap :: UView c k v -> VMap VB VB k v

-- | Extract a reward-deposit pairs <a>Map</a> from a <a>UMap</a>
rdPairMap :: UMap c -> Map (Credential 'Staking c) RDPair

-- | Extract a rewards <a>Map</a> from a <a>UMap</a>
rewardMap :: UMap c -> Map (Credential 'Staking c) Coin

-- | Extract a compact rewards <a>Map</a> from a <a>UMap</a>
compactRewardMap :: UMap c -> Map (Credential 'Staking c) (CompactForm Coin)

-- | Extract a deposits <a>Map</a> from a <a>UMap</a>
depositMap :: UMap c -> Map (Credential 'Staking c) Coin

-- | Extract a pointers <a>Map</a> from a <a>UMap</a>
ptrMap :: UMap c -> Map Ptr (Credential 'Staking c)

-- | Extract a pointers <a>Map</a> from a <a>UMap</a>
invPtrMap :: UMap c -> Map (Credential 'Staking c) (Set Ptr)

-- | Extract a stake pool delegations <a>Map</a> from a <a>UMap</a>
sPoolMap :: UMap c -> Map (Credential 'Staking c) (KeyHash 'StakePool c)

-- | Extract a delegated-representatives <a>Map</a> from a <a>UMap</a>
dRepMap :: UMap c -> Map (Credential 'Staking c) (DRep c)

-- | Extract a domain-restricted <a>Map</a> of a <a>UMap</a>. If `Set k` is
--   small this should be efficient.
domRestrictedMap :: Set k -> UView c k v -> Map k v
data CompactForm a :: Type
toCompact :: Compactible a => a -> Maybe (CompactForm a)
fromCompact :: Compactible a => CompactForm a -> a
addCompact :: CompactForm Coin -> CompactForm Coin -> CompactForm Coin
sumCompactCoin :: Foldable t => t (CompactForm Coin) -> CompactForm Coin
sumRewardsUView :: UView c k RDPair -> CompactForm Coin
sumDepositUView :: UView c k RDPair -> CompactForm Coin
compactCoinOrError :: HasCallStack => Coin -> CompactForm Coin

-- | Create a UMap from 4 separate maps. NOTE: For use in tests only.
unify :: Map (Credential 'Staking c) RDPair -> Map Ptr (Credential 'Staking c) -> Map (Credential 'Staking c) (KeyHash 'StakePool c) -> Map (Credential 'Staking c) (DRep c) -> UMap c

-- | Materialize a real <a>Map</a> from a <tt>View</tt> This is expensive,
--   use it wisely (like maybe once per epoch boundary to make a
--   <tt>SnapShot</tt>) See also domRestrictedMap, which domain-restricts
--   before computing a view.
unUnify :: UView c k v -> Map k v

-- | <a>null</a> for a <a>UView</a>, just like <a>null</a>
nullUView :: UView c k v -> Bool

-- | Membership check for a <a>UView</a>, just like <a>member</a>
--   
--   Spec: eval (k ∈ dom (rewards dState)) eval (k ∈ dom (rewards ds)))
--   eval (hk ∈ dom (rewards ds)) eval (hk ∉ dom (rewards ds))
member :: k -> UView c k v -> Bool

-- | Membership check for a <a>UView</a>, just like <a>member</a>
--   
--   Spec: eval (k ∈ dom (rewards dState)) eval (k ∈ dom (rewards ds)))
--   eval (hk ∈ dom (rewards ds)) eval (hk ∉ dom (rewards ds))
notMember :: k -> UView c k v -> Bool
delete :: k -> UView c k v -> UMap c

-- | Delete a key and its value from the map-like <a>UView</a>, returning a
--   version of the same <a>UView</a>.
--   
--   In the case of a <a>PtrUView</a> we maintain the <a>umInvariant</a>
--   and delete the pairs from both <a>umElems</a> as well as <a>umPtrs</a>
--   of the <a>UMap</a>.
delete' :: k -> UView c k v -> UView c k v
insertWith :: (v -> v -> v) -> k -> v -> UView c k v -> UMap c

-- | Insert with combination
--   
--   If <tt>k</tt> exists as a key in the (map-like) <a>UView</a>:
--   
--   <ol>
--   <li>to keep the old value &gt; insertWith' ( old new -&gt; old) k v
--   view</li>
--   <li>to replace the old value with the new value &gt; insertWith' ( old
--   new -&gt; new) k v view</li>
--   <li>to combine the old and new values with summation &gt; insertWith'
--   ( old new -&gt; old + new) k v view</li>
--   </ol>
--   
--   If <tt>k</tt> does not exist as a key in the <a>UView</a>, the
--   combining function is ignored, and the key <tt>k</tt> and the value
--   <tt>v</tt> are inserted into the map-like <a>UView</a> &gt;
--   insertWith' ignoredCombiningFunction k v view
insertWith' :: (v -> v -> v) -> k -> v -> UView c k v -> UView c k v
insert :: k -> v -> UView c k v -> UMap c
insert' :: k -> v -> UView c k v -> UView c k v

-- | Adjust a <a>UView</a>, just like <a>adjust</a>. This is implemented
--   only for reward-deposit pairs.
adjust :: (RDPair -> RDPair) -> k -> UView c k RDPair -> UMap c

-- | Lookup a <a>UView</a>, just like <a>lookup</a>.
lookup :: k -> UView c k v -> Maybe v

-- | Get the domain of the <a>Map</a>-like <a>UView</a>
domain :: UView c k v -> Set k

-- | Get the range of the <a>Map</a>-like <a>UView</a>
range :: UView c k v -> Set v

-- | Union with left preference. So if k, already exists, do nothing, if it
--   doesn't exist insert it.
--   
--   Spec: evalUnified (RewDepUView u1 ∪ singleton hk mempty) evalUnified
--   (Ptrs u2 ∪ singleton ptr hk)
(∪) :: UView c k v -> (k, v) -> UMap c

-- | Union with left preference. So if k, already exists, do nothing, if it
--   doesn't exist insert it.
--   
--   Spec: evalUnified (RewDepUView u1 ∪ singleton hk mempty) evalUnified
--   (Ptrs u2 ∪ singleton ptr hk)
unionL :: UView c k v -> (k, v) -> UMap c

-- | Union with right preference. So if k, already exists, then old v is
--   overwritten with the new v.
--   
--   Special rules apply for the <a>RewDepUView</a>, where only the
--   <a>rdReward</a> field of the <a>RDPair</a> is overwritten, and the old
--   <a>rdDeposit</a> value persists.
--   
--   Note: In this case it is an invariant that the domain of the
--   <a>Map</a> on the right side is a subset of the domain of the
--   RewDepUView. See the single case in module
--   Cardano.Ledger.Shelley.Rules.Delegs, in the dealing with Withdrawals's
--   where it is used at this type.
--   
--   Spec: evalUnified (delegations ds ⨃ singleton hk dpool) evalUnified
--   (rewards' ⨃ wdrls_')
(⨃) :: UView c k v -> Map k v -> UMap c

-- | Union with right preference. So if k, already exists, then old v is
--   overwritten with the new v.
--   
--   Special rules apply for the <a>RewDepUView</a>, where only the
--   <a>rdReward</a> field of the <a>RDPair</a> is overwritten, and the old
--   <a>rdDeposit</a> value persists.
--   
--   Note: In this case it is an invariant that the domain of the
--   <a>Map</a> on the right side is a subset of the domain of the
--   RewDepUView. See the single case in module
--   Cardano.Ledger.Shelley.Rules.Delegs, in the dealing with Withdrawals's
--   where it is used at this type.
--   
--   Spec: evalUnified (delegations ds ⨃ singleton hk dpool) evalUnified
--   (rewards' ⨃ wdrls_')
unionR :: UView c k v -> Map k v -> UMap c

-- | Add the reward from the <a>Map</a> on the right side to the reward in
--   the <a>UView</a> on the left. This is only implemented and is
--   applicable to <a>RewDepUView</a>s.
--   
--   We presume that the domain of the <a>Map</a> on the right, is a subset
--   of the domain of the <a>UView</a> on the left.
--   
--   Spec: evalUnified (rewards dState ∪+ registeredAggregated) evalUnified
--   (rewards' ∪+ update) evalUnified (RewDepUView u0 ∪+ refunds)
(∪+) :: UView c (Credential 'Staking c) RDPair -> Map (Credential 'Staking c) (CompactForm Coin) -> UMap c

-- | Add the reward from the <a>Map</a> on the right side to the reward in
--   the <a>UView</a> on the left. This is only implemented and is
--   applicable to <a>RewDepUView</a>s.
--   
--   We presume that the domain of the <a>Map</a> on the right, is a subset
--   of the domain of the <a>UView</a> on the left.
--   
--   Spec: evalUnified (rewards dState ∪+ registeredAggregated) evalUnified
--   (rewards' ∪+ update) evalUnified (RewDepUView u0 ∪+ refunds)
unionRewAgg :: UView c (Credential 'Staking c) RDPair -> Map (Credential 'Staking c) (CompactForm Coin) -> UMap c

-- | Add the deposit from the <a>Map</a> on the right side to the deposit
--   in the <a>UView</a> on the left. This is only implemented and is
--   applicable to <a>RewDepUView</a>s.
unionKeyDeposits :: UView c k RDPair -> Map k (CompactForm Coin) -> UMap c

-- | Delete all keys in the given <a>Set</a> from the domain of the given
--   map-like <a>UView</a>.
--   
--   Spec: evalUnified (setSingleton hk ⋪ RewDepUView u0) evalUnified
--   (setSingleton hk ⋪ SPoolUView u1)
(⋪) :: Set k -> UView c k v -> UMap c

-- | Delete all keys in the given <a>Set</a> from the domain of the given
--   map-like <a>UView</a>.
--   
--   Spec: evalUnified (setSingleton hk ⋪ RewDepUView u0) evalUnified
--   (setSingleton hk ⋪ SPoolUView u1)
domDelete :: Set k -> UView c k v -> UMap c

-- | Delete all elements in the given <a>Set</a> from the range of the
--   given map-like <a>UView</a>. This is slow for SPoolUView, RewDepUView,
--   and DReps UViews, better hope the sets are small
--   
--   Spec: evalUnified (Ptrs u2 ⋫ setSingleton hk) evalUnified (SPoolUView
--   u1 ⋫ retired)
(⋫) :: UView c k v -> Set v -> UMap c

-- | Delete all elements in the given <a>Set</a> from the range of the
--   given map-like <a>UView</a>. This is slow for SPoolUView, RewDepUView,
--   and DReps UViews, better hope the sets are small
--   
--   Spec: evalUnified (Ptrs u2 ⋫ setSingleton hk) evalUnified (SPoolUView
--   u1 ⋫ retired)
rngDelete :: UView c k v -> Set v -> UMap c

-- | Domain restriction.
--   
--   Spec: eval (dom rewards' ◁ iRReserves (_irwd ds) :: RewardAccounts
--   (Crypto era)) eval (dom rewards' ◁ iRTreasury (_irwd ds) ::
--   RewardAccounts (Crypto era))
(◁) :: UView c k v -> Map k u -> Map k u

-- | Domain restriction.
--   
--   Spec: eval (dom rewards' ◁ iRReserves (_irwd ds) :: RewardAccounts
--   (Crypto era)) eval (dom rewards' ◁ iRTreasury (_irwd ds) ::
--   RewardAccounts (Crypto era))
domRestrict :: UView c k v -> Map k u -> Map k u

-- | Find the value associated with a key from a <a>UView</a>, return the
--   default if the key is not there.
findWithDefault :: v -> k -> UView c k v -> v

-- | A <a>UView</a> is a view, so the size of the view is NOT the same as
--   the size of the underlying <a>UMElem</a> map.
size :: UView c k v -> Int

-- | Delete the stake credentials in the domain and all associated ranges
--   from the <a>UMap</a> This can be expensive when there are many
--   pointers associated with the credential.
domDeleteAll :: Set (Credential 'Staking c) -> UMap c -> UMap c
instance Control.DeepSeq.NFData Cardano.Ledger.UMap.RDPair
instance NoThunks.Class.NoThunks Cardano.Ledger.UMap.RDPair
instance GHC.Generics.Generic Cardano.Ledger.UMap.RDPair
instance GHC.Classes.Ord Cardano.Ledger.UMap.RDPair
instance GHC.Classes.Eq Cardano.Ledger.UMap.RDPair
instance GHC.Show.Show Cardano.Ledger.UMap.RDPair
instance Control.DeepSeq.NFData (Cardano.Ledger.UMap.UMElem c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.UMap.UMElem c)
instance GHC.Generics.Generic (Cardano.Ledger.UMap.UMElem c)
instance GHC.Classes.Ord (Cardano.Ledger.UMap.UMElem c)
instance GHC.Classes.Eq (Cardano.Ledger.UMap.UMElem c)
instance Control.DeepSeq.NFData (Cardano.Ledger.UMap.UMap c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.UMap.UMap c)
instance GHC.Generics.Generic (Cardano.Ledger.UMap.UMap c)
instance GHC.Classes.Eq (Cardano.Ledger.UMap.UMap c)
instance GHC.Show.Show (Cardano.Ledger.UMap.UMap c)
instance Control.DeepSeq.NFData (Cardano.Ledger.UMap.StakeCredentials c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.UMap.StakeCredentials c)
instance GHC.Generics.Generic (Cardano.Ledger.UMap.StakeCredentials c)
instance GHC.Classes.Eq (Cardano.Ledger.UMap.StakeCredentials c)
instance GHC.Show.Show (Cardano.Ledger.UMap.StakeCredentials c)
instance Data.Foldable.Foldable (Cardano.Ledger.UMap.UView c k)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.UMap.UMap c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.UMap.UMap c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.UMap.UMap c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.UMap.UMElem c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.UMap.UMElem c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.UMap.UMElem c)
instance GHC.Show.Show (Cardano.Ledger.UMap.UMElem c)
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.UMap.RDPair
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.UMap.RDPair


-- | This module defines a generalised notion of a "value" - that is,
--   something with which we may quantify a transaction output.
module Cardano.Ledger.Val
class (Compactible t, Inject Coin t, EncCBOR (CompactForm t), DecCBOR (CompactForm t), Abelian t, NoThunks t, EncCBOR t, DecCBOR t, ToJSON t, NFData t, Show t, Eq t) => Val t

-- | the value with nothing in it
zero :: Val t => t

-- | add two value
(<+>) :: Val t => t -> t -> t

-- | scale a value by an Integral constant
(<×>) :: (Val t, Integral i) => i -> t -> t

-- | subtract two values
(<->) :: Val t => t -> t -> t

-- | Is the argument zero?
isZero :: Val t => t -> Bool

-- | Get the ADA present in the value (since ADA is our "blessed" currency)
coin :: Val t => t -> Coin

-- | modify the blessed Coin part of t
modifyCoin :: Val t => (Coin -> Coin) -> t -> t
size :: Val t => t -> Integer

-- | used to compare values pointwise. Rather than using: (v1 &lt;= v2)
--   use: pointwise (&lt;=) v1 v2 | If a quantity is stored in only one of
--   <tt>v1</tt> or <tt>v2</tt>, we use 0 for the missing quantity.
pointwise :: Val t => (Integer -> Integer -> Bool) -> t -> t -> Bool

-- | Check if value contains only ADA. Must hold property:
--   
--   <pre>
--   inject (coin v) == v
--   </pre>
isAdaOnly :: Val t => t -> Bool
isAdaOnlyCompact :: Val t => CompactForm t -> Bool
coinCompact :: Val t => CompactForm t -> CompactForm Coin
injectCompact :: Val t => CompactForm Coin -> CompactForm t
modifyCompactCoin :: Val t => (CompactForm Coin -> CompactForm Coin) -> CompactForm t -> CompactForm t
infixl 6 <+>
infixl 7 <×>
infixl 6 <->
inject :: Inject t s => t -> s
scale :: (Val t, Integral i) => i -> t -> t
invert :: Val t => t -> t
sumVal :: (Foldable t, Val v) => t v -> v

-- | <i>Deprecated: In favor of <a>isAdaOnly</a></i>
adaOnly :: Val v => v -> Bool
instance Cardano.Ledger.Val.Val Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Val.Val Cardano.Ledger.Coin.DeltaCoin


-- | This module defines core type families which we know to vary from era
--   to era.
--   
--   Families in this module should be indexed on era.
--   
--   It is intended for qualified import: &gt; import qualified
--   Cardano.Ledger.Core as Core
module Cardano.Ledger.Core

-- | A transaction.
class (EraTxBody era, EraTxWits era, EraTxAuxData era, EraPParams era, NoThunks (Tx era), DecCBOR (Annotator (Tx era)), EncCBOR (Tx era), ToCBOR (Tx era), Show (Tx era), Eq (Tx era), EqRaw (Tx era)) => EraTx era where {
    type Tx era = (r :: Type) | r -> era;
    type TxUpgradeError era :: Type;
    type TxUpgradeError era = Void;
}
mkBasicTx :: EraTx era => TxBody era -> Tx era
bodyTxL :: EraTx era => Lens' (Tx era) (TxBody era)
witsTxL :: EraTx era => Lens' (Tx era) (TxWits era)
auxDataTxL :: EraTx era => Lens' (Tx era) (StrictMaybe (AuxiliaryData era))
sizeTxF :: EraTx era => SimpleGetter (Tx era) Integer

-- | Using information from the transaction validate the supplied native
--   script.
validateNativeScript :: EraTx era => Tx era -> NativeScript era -> Bool
getMinFeeTx :: EraTx era => PParams era -> Tx era -> Coin
upgradeTx :: (EraTx era, EraTx (PreviousEra era)) => Tx (PreviousEra era) -> Either (TxUpgradeError era) (Tx era)
txIdTx :: EraTx era => Tx era -> TxId (EraCrypto era)

-- | Abstract interface into specific fields of a <a>TxOut</a>
class (Val (Value era), ToJSON (TxOut era), DecCBOR (Value era), DecCBOR (CompactForm (Value era)), EncCBOR (Value era), ToCBOR (TxOut era), FromCBOR (TxOut era), EncCBOR (TxOut era), DecCBOR (TxOut era), DecShareCBOR (TxOut era), Share (TxOut era) ~ Interns (Credential 'Staking (EraCrypto era)), NoThunks (TxOut era), NFData (TxOut era), Show (TxOut era), Eq (TxOut era), EraPParams era) => EraTxOut era where {
    
    -- | The output of a UTxO for a particular era
    type TxOut era = (r :: Type) | r -> era;
}
mkBasicTxOut :: EraTxOut era => Addr (EraCrypto era) -> Value era -> TxOut era

-- | Every era, except Shelley, must be able to upgrade a <a>TxOut</a> from
--   a previous era.
upgradeTxOut :: (EraTxOut era, EraTxOut (PreviousEra era)) => TxOut (PreviousEra era) -> TxOut era
valueTxOutL :: EraTxOut era => Lens' (TxOut era) (Value era)
compactValueTxOutL :: (EraTxOut era, HasCallStack) => Lens' (TxOut era) (CompactForm (Value era))

-- | Lens for getting and setting in TxOut either an address or its compact
--   version by doing the least amount of work.
valueEitherTxOutL :: EraTxOut era => Lens' (TxOut era) (Either (Value era) (CompactForm (Value era)))
addrTxOutL :: EraTxOut era => Lens' (TxOut era) (Addr (EraCrypto era))
compactAddrTxOutL :: EraTxOut era => Lens' (TxOut era) (CompactAddr (EraCrypto era))

-- | Lens for getting and setting in TxOut either an address or its compact
--   version by doing the least amount of work.
--   
--   The utility of this function comes from the fact that TxOut usually
--   stores the address in either one of two forms: compacted or unpacked.
--   In order to avoid extroneous conversions in <tt>getTxOutAddr</tt> and
--   <tt>getTxOutCompactAddr</tt> we can define just this functionality.
--   Also sometimes it is crucial to know at the callsite which form of
--   address we have readily available without any conversions (eg.
--   searching millions of TxOuts for a particular address)
addrEitherTxOutL :: EraTxOut era => Lens' (TxOut era) (Either (Addr (EraCrypto era)) (CompactAddr (EraCrypto era)))

-- | Produce the minimum lovelace that a given transaction output must
--   contain. Information about the size of the TxOut is required in some
--   eras. Use <a>getMinCoinTxOut</a> if you don't have the size readily
--   available to you.
getMinCoinSizedTxOut :: EraTxOut era => PParams era -> Sized (TxOut era) -> Coin

-- | Same as <a>getMinCoinSizedTxOut</a>, except information about the size
--   of TxOut will be computed by serializing the TxOut. If the size turns
--   out to be not needed, then serialization will have no overhead, since
--   it is computed lazily.
getMinCoinTxOut :: EraTxOut era => PParams era -> TxOut era -> Coin
bootAddrTxOutF :: EraTxOut era => SimpleGetter (TxOut era) (Maybe (BootstrapAddress (EraCrypto era)))
coinTxOutL :: (HasCallStack, EraTxOut era) => Lens' (TxOut era) Coin
compactCoinTxOutL :: (HasCallStack, EraTxOut era) => Lens' (TxOut era) (CompactForm Coin)

-- | This is a getter that implements an efficient way to check whether
--   <a>TxOut</a> contains ADA only.
isAdaOnlyTxOutF :: EraTxOut era => SimpleGetter (TxOut era) Bool
class (EraTxOut era, EraTxCert era, EraPParams era, HashAnnotated (TxBody era) EraIndependentTxBody (EraCrypto era), DecCBOR (Annotator (TxBody era)), EncCBOR (TxBody era), ToCBOR (TxBody era), NoThunks (TxBody era), NFData (TxBody era), Show (TxBody era), Eq (TxBody era), EqRaw (TxBody era)) => EraTxBody era where {
    
    -- | The body of a transaction.
    type TxBody era = (r :: Type) | r -> era;
    type TxBodyUpgradeError era :: Type;
    type TxBodyUpgradeError era = Void;
}
mkBasicTxBody :: EraTxBody era => TxBody era
inputsTxBodyL :: EraTxBody era => Lens' (TxBody era) (Set (TxIn (EraCrypto era)))
outputsTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictSeq (TxOut era))
feeTxBodyL :: EraTxBody era => Lens' (TxBody era) Coin
withdrawalsTxBodyL :: EraTxBody era => Lens' (TxBody era) (Withdrawals (EraCrypto era))
auxDataHashTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictMaybe (AuxiliaryDataHash (EraCrypto era)))

-- | This getter will produce all inputs from the UTxO map that this
--   transaction might spend, which ones will depend on the validity of the
--   transaction itself. Starting in Alonzo this will include collateral
--   inputs.
spendableInputsTxBodyF :: EraTxBody era => SimpleGetter (TxBody era) (Set (TxIn (EraCrypto era)))

-- | This getter will produce all inputs from the UTxO map that this
--   transaction is referencing, even if some of them cannot be spent by
--   the transaction. For example starting with Babbage era it will also
--   include reference inputs.
allInputsTxBodyF :: EraTxBody era => SimpleGetter (TxBody era) (Set (TxIn (EraCrypto era)))
certsTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictSeq (TxCert era))

-- | Compute the total deposits from the certificates in a TxBody.
--   
--   This is the contribution of a TxBody towards the consumed amount by
--   the transaction
getTotalDepositsTxBody :: EraTxBody era => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> TxBody era -> Coin

-- | Compute the total refunds from the Certs of a TxBody.
--   
--   This is the contribution of a TxBody towards produced amount by the
--   transaction
getTotalRefundsTxBody :: EraTxBody era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> TxBody era -> Coin

-- | This function is not used in the ledger rules. It is only used by the
--   downstream tooling to figure out how many witnesses should be supplied
--   for Genesis keys.
getGenesisKeyHashCountTxBody :: EraTxBody era => TxBody era -> Int

-- | Upgrade the transaction body from the previous era.
--   
--   This can fail where elements of the transaction body are deprecated.
--   Compare this to <a>translateEraThroughCBOR</a>: - <a>upgradeTxBody</a>
--   will use the Haskell representation, but will not preserve the
--   serialised form. However, it will be suitable for iterated translation
--   through eras. - <a>translateEraThroughCBOR</a> will preserve the
--   binary representation, but is not guaranteed to work through multiple
--   eras - that is, the serialised representation from era n is guaranteed
--   valid in era n + 1, but not necessarily in era n + 2.
upgradeTxBody :: (EraTxBody era, EraTxBody (PreviousEra era)) => TxBody (PreviousEra era) -> Either (TxBodyUpgradeError era) (TxBody era)
txIdTxBody :: EraTxBody era => TxBody era -> TxId (EraCrypto era)

-- | TxAuxData which may be attached to a transaction
class (Era era, Eq (TxAuxData era), EqRaw (TxAuxData era), Show (TxAuxData era), NoThunks (TxAuxData era), ToCBOR (TxAuxData era), EncCBOR (TxAuxData era), DecCBOR (Annotator (TxAuxData era)), HashAnnotated (TxAuxData era) EraIndependentTxAuxData (EraCrypto era)) => EraTxAuxData era where {
    type TxAuxData era = (r :: Type) | r -> era;
}

-- | Every era, except Shelley, must be able to upgrade a <a>TxAuxData</a>
--   from a previous era.
--   
--   <i>Warning</i> - Important to note that any memoized binary
--   representation will not be preserved. If you need to retain underlying
--   bytes you can use <a>translateEraThroughCBOR</a>
upgradeTxAuxData :: (EraTxAuxData era, EraTxAuxData (PreviousEra era)) => TxAuxData (PreviousEra era) -> TxAuxData era
hashTxAuxData :: EraTxAuxData era => TxAuxData era -> AuxiliaryDataHash (EraCrypto era)
validateTxAuxData :: EraTxAuxData era => ProtVer -> TxAuxData era -> Bool

-- | A collection of witnesses in a Tx
class (EraScript era, Eq (TxWits era), EqRaw (TxWits era), Show (TxWits era), Monoid (TxWits era), NoThunks (TxWits era), ToCBOR (TxWits era), EncCBOR (TxWits era), DecCBOR (Annotator (TxWits era))) => EraTxWits era where {
    type TxWits era = (r :: Type) | r -> era;
}
mkBasicTxWits :: EraTxWits era => TxWits era
addrTxWitsL :: EraTxWits era => Lens' (TxWits era) (Set (WitVKey 'Witness (EraCrypto era)))
bootAddrTxWitsL :: EraTxWits era => Lens' (TxWits era) (Set (BootstrapWitness (EraCrypto era)))
scriptTxWitsL :: EraTxWits era => Lens' (TxWits era) (Map (ScriptHash (EraCrypto era)) (Script era))
upgradeTxWits :: (EraTxWits era, EraTxWits (PreviousEra era)) => TxWits (PreviousEra era) -> TxWits era

-- | Typeclass for script data types. Allows for script validation and
--   hashing. You must understand the role of SafeToHash and
--   scriptPrefixTag to make new instances. <a>scriptPrefixTag</a> is a
--   magic number representing the tag of the script language. For each new
--   script language defined, a new tag is chosen and the tag is included
--   in the script hash for a script. The safeToHash constraint ensures
--   that Scripts are never reserialised.
class (Era era, Show (Script era), Eq (Script era), EqRaw (Script era), ToCBOR (Script era), EncCBOR (Script era), DecCBOR (Annotator (Script era)), NoThunks (Script era), SafeToHash (Script era), Eq (NativeScript era), Show (NativeScript era), NFData (NativeScript era), NoThunks (NativeScript era), EncCBOR (NativeScript era), DecCBOR (Annotator (NativeScript era))) => EraScript era where {
    
    -- | Scripts which may lock transaction outputs in this era
    type Script era = (r :: Type) | r -> era;
    type NativeScript era = (r :: Type) | r -> era;
}

-- | Every era, except Shelley, must be able to upgrade a <a>Script</a>
--   from a previous era.
--   
--   <i>Warning</i> - Important to note that any memoized binary
--   representation will not be preserved, you need to retain underlying
--   bytes you can use <a>translateEraThroughCBOR</a>
upgradeScript :: (EraScript era, EraScript (PreviousEra era)) => Script (PreviousEra era) -> Script era
scriptPrefixTag :: EraScript era => Script era -> ByteString
hashScript :: EraScript era => Script era -> ScriptHash (EraCrypto era)
getNativeScript :: EraScript era => Script era -> Maybe (NativeScript era)
fromNativeScript :: EraScript era => NativeScript era -> Script era
isNativeScript :: EraScript era => Script era -> Bool

-- | This is a helper lens that will hash the scripts when adding as
--   witnesses.
hashScriptTxWitsL :: EraTxWits era => Lens (TxWits era) (TxWits era) (Map (ScriptHash (EraCrypto era)) (Script era)) [Script era]

-- | A value is something which quantifies a transaction output.
type family Value era :: Type
class (Era era, Eq (PParamsHKD Identity era), Ord (PParamsHKD Identity era), Show (PParamsHKD Identity era), NFData (PParamsHKD Identity era), EncCBOR (PParamsHKD Identity era), DecCBOR (PParamsHKD Identity era), ToCBOR (PParamsHKD Identity era), FromCBOR (PParamsHKD Identity era), NoThunks (PParamsHKD Identity era), ToJSON (PParamsHKD Identity era), FromJSON (PParamsHKD Identity era), Eq (PParamsHKD StrictMaybe era), Ord (PParamsHKD StrictMaybe era), Show (PParamsHKD StrictMaybe era), NFData (PParamsHKD StrictMaybe era), EncCBOR (PParamsHKD StrictMaybe era), DecCBOR (PParamsHKD StrictMaybe era), ToCBOR (PParamsHKD StrictMaybe era), FromCBOR (PParamsHKD StrictMaybe era), NoThunks (PParamsHKD StrictMaybe era), ToJSON (PParamsHKD StrictMaybe era)) => EraPParams era where {
    
    -- | Protocol parameters where the fields are represented with a HKD
    type PParamsHKD (f :: Type -> Type) era = (r :: Type) | r -> era;
    
    type UpgradePParams (f :: Type -> Type) era :: Type;
    type DowngradePParams (f :: Type -> Type) era :: Type;
}

-- | Applies a protocol parameters update
applyPPUpdates :: EraPParams era => PParams era -> PParamsUpdate era -> PParams era

-- | Applies a protocol parameters update
applyPPUpdates :: forall a u. (EraPParams era, Generic (PParamsHKD Identity era), Generic (PParamsHKD StrictMaybe era), Updatable (Rep (PParamsHKD Identity era) a) (Rep (PParamsHKD StrictMaybe era) u)) => PParams era -> PParamsUpdate era -> PParams era
emptyPParamsIdentity :: EraPParams era => PParamsHKD Identity era
emptyPParamsStrictMaybe :: EraPParams era => PParamsHKD StrictMaybe era

-- | Upgrade PParams from previous era to the current one
upgradePParamsHKD :: (EraPParams era, HKDFunctor f, EraPParams (PreviousEra era)) => UpgradePParams f era -> PParamsHKD f (PreviousEra era) -> PParamsHKD f era

-- | Downgrade PParams from the current era to the previous one
downgradePParamsHKD :: (EraPParams era, HKDFunctor f, EraPParams (PreviousEra era)) => DowngradePParams f era -> PParamsHKD f era -> PParamsHKD f (PreviousEra era)

-- | The linear factor for the minimum fee calculation
hkdMinFeeAL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | The constant factor for the minimum fee calculation
hkdMinFeeBL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Maximal block body size
hkdMaxBBSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word32)

-- | Maximal transaction size
hkdMaxTxSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word32)

-- | Maximal block header size
hkdMaxBHSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word16)

-- | The amount of a key registration deposit
hkdKeyDepositL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | The amount of a pool registration deposit
hkdPoolDepositL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | epoch bound on pool retirement
hkdEMaxL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f EpochInterval)

-- | Desired number of pools
hkdNOptL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Natural)

-- | Pool influence
hkdA0L :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f NonNegativeInterval)

-- | Monetary expansion
hkdRhoL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Treasury expansion
hkdTauL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Decentralization parameter
hkdDL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 6) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Decentralization parameter getter
ppDG :: EraPParams era => SimpleGetter (PParams era) UnitInterval

-- | Decentralization parameter getter
ppDG :: (EraPParams era, ProtVerAtMost era 6) => SimpleGetter (PParams era) UnitInterval

-- | Extra entropy
hkdExtraEntropyL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 6) => Lens' (PParamsHKD f era) (HKD f Nonce)

-- | Protocol version
hkdProtocolVersionL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 8) => Lens' (PParamsHKD f era) (HKD f ProtVer)
ppProtocolVersionL :: EraPParams era => Lens' (PParams era) ProtVer
ppProtocolVersionL :: (EraPParams era, ProtVerAtMost era 8) => Lens' (PParams era) ProtVer

-- | PParamsUpdate Protocol version
ppuProtocolVersionL :: (EraPParams era, ProtVerAtMost era 8) => Lens' (PParamsUpdate era) (StrictMaybe ProtVer)

-- | Minimum UTxO value
hkdMinUTxOValueL :: (EraPParams era, HKDFunctor f) => ProtVerAtMost era 4 => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Minimum Stake Pool Cost
hkdMinPoolCostL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Era STS map
type family EraRule (k :: Symbol) era :: Type
class (Crypto (EraCrypto era), Typeable era, KnownNat (ProtVerLow era), KnownNat (ProtVerHigh era), ProtVerLow era <= ProtVerHigh era, MinVersion <= ProtVerLow era, MinVersion <= ProtVerHigh era, CmpNat (ProtVerLow era) MaxVersion ~ 'LT, CmpNat (ProtVerHigh era) MaxVersion ~ 'LT, ProtVerLow era <= MaxVersion, ProtVerHigh era <= MaxVersion) => Era era where {
    type EraCrypto era :: Type;
    
    -- | Map an era to its predecessor.
    --   
    --   For example:
    --   
    --   <pre>
    --   type instance PreviousEra (AllegraEra c) = ShelleyEra c
    --   </pre>
    type PreviousEra era = (r :: Type) | r -> era;
    
    -- | Lowest major protocol version for this era
    type ProtVerLow era :: Nat;
    
    -- | Highest major protocol version for this era. By default se to
    --   <a>ProtVerLow</a>
    type ProtVerHigh era :: Nat;
    type ProtVerHigh era = ProtVerLow era;
}

-- | Textual name of the current era.
--   
--   Designed to be used with <tt>TypeApplications</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; eraName @(ByronEra StandardCrypto)
--   Byron
--   </pre>
eraName :: Era era => String

-- | Indicates that an era supports segregated witnessing.
--   
--   This class embodies an isomorphism between 'TxSeq era' and 'StrictSeq
--   (Tx era)', witnessed by <a>fromTxSeq</a> and <a>toTxSeq</a>.
class (EraTx era, Eq (TxSeq era), Show (TxSeq era), EncCBORGroup (TxSeq era), DecCBOR (Annotator (TxSeq era))) => EraSegWits era where {
    type TxSeq era = (r :: Type) | r -> era;
}
fromTxSeq :: EraSegWits era => TxSeq era -> StrictSeq (Tx era)
toTxSeq :: EraSegWits era => StrictSeq (Tx era) -> TxSeq era

-- | Get the block body hash from the TxSeq. Note that this is not a
--   regular "hash the stored bytes" function since the block body hash
--   forms a small Merkle tree.
hashTxSeq :: EraSegWits era => TxSeq era -> Hash (HASH (EraCrypto era)) EraIndependentBlockBody

-- | The number of segregated components
numSegComponents :: EraSegWits era => Word64
bBodySize :: forall era. EraSegWits era => ProtVer -> TxSeq era -> Int

-- | The staking rewards in Cardano are all either:
--   
--   <ul>
--   <li>member rewards - rewards given to a registered stake credential
--   which has delegated to a stake pool, or</li>
--   <li>leader rewards - rewards given to a registered stake pool (in
--   particular, given to the stake credential in the stake pool
--   registration certificate).</li>
--   </ul>
--   
--   See Figure 47, "Functions used in the Reward Splitting", of the
--   <a>formal specification</a> for more details.
data RewardType
MemberReward :: RewardType
LeaderReward :: RewardType

-- | The <a>Reward</a> type captures:
--   
--   <ul>
--   <li>if the reward is a member or leader reward</li>
--   <li>the stake pool ID associated with the reward</li>
--   <li>the number of Lovelace in the reward</li>
--   </ul>
data Reward c
Reward :: !RewardType -> !KeyHash 'StakePool c -> !Coin -> Reward c
[rewardType] :: Reward c -> !RewardType
[rewardPool] :: Reward c -> !KeyHash 'StakePool c
[rewardAmount] :: Reward c -> !Coin
class (Crypto (EraCrypto era), Typeable era, KnownNat (ProtVerLow era), KnownNat (ProtVerHigh era), ProtVerLow era <= ProtVerHigh era, MinVersion <= ProtVerLow era, MinVersion <= ProtVerHigh era, CmpNat (ProtVerLow era) MaxVersion ~ 'LT, CmpNat (ProtVerHigh era) MaxVersion ~ 'LT, ProtVerLow era <= MaxVersion, ProtVerHigh era <= MaxVersion) => Era era where {
    type EraCrypto era :: Type;
    
    -- | Map an era to its predecessor.
    --   
    --   For example:
    --   
    --   <pre>
    --   type instance PreviousEra (AllegraEra c) = ShelleyEra c
    --   </pre>
    type PreviousEra era = (r :: Type) | r -> era;
    
    -- | Lowest major protocol version for this era
    type ProtVerLow era :: Nat;
    
    -- | Highest major protocol version for this era. By default se to
    --   <a>ProtVerLow</a>
    type ProtVerHigh era :: Nat;
    type ProtVerHigh era = ProtVerLow era;
}

-- | Textual name of the current era.
--   
--   Designed to be used with <tt>TypeApplications</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; eraName @(ByronEra StandardCrypto)
--   Byron
--   </pre>
eraName :: Era era => String

-- | This is the era that preceded Shelley era. It cannot have any other
--   class instances, except for <a>Era</a> type class.
data ByronEra c

-- | Restrict the <tt>era</tt> to equal to <tt>eraName</tt> or come before
--   it.
type AtMostEra (eraName :: Type -> Type) era = ProtVerAtMost era (ProtVerHigh (eraName (EraCrypto era)))

-- | Restrict the <tt>era</tt> to equal to <tt>eraName</tt> or come after
--   it
type AtLeastEra (eraName :: Type -> Type) era = ProtVerAtLeast era (ProtVerLow (eraName (EraCrypto era)))

-- | Restrict an era to the specific era through the protocol version. This
--   is equivalent to <tt>(inEra (Crypto era) ~ era)</tt>
type ExactEra (inEra :: Type -> Type) era = ProtVerInBounds era (ProtVerLow (inEra (EraCrypto era))) (ProtVerHigh (inEra (EraCrypto era)))

-- | Requirement for the era's lowest protocol version to be lower or equal
--   to the supplied value
type family ProtVerAtMost era (h :: Nat) :: Constraint

-- | Requirement for the era's highest protocol version to be higher or
--   equal to the supplied value
type family ProtVerAtLeast era (l :: Nat) :: Constraint

-- | Restrict a lower and upper bounds of the protocol version for the
--   particular era
type ProtVerInBounds era l h = (ProtVerAtLeast era l, ProtVerAtMost era h)

-- | Enforce era to be at least the specified era at the type level. In
--   other words compiler will produce type error when applied to eras
--   prior to the specified era. This function should be used in order to
--   avoid redundant constraints warning.
--   
--   For example these will type check
--   
--   <pre>
--   &gt;&gt;&gt; atLeastEra @BabbageEra @(ConwayEra StandardCrypto)
--   
--   &gt;&gt;&gt; atLeastEra @BabbageEra @(BabbageEra StandardCrypto)
--   </pre>
--   
--   However this will result in a type error
--   
--   <pre>
--   &gt;&gt;&gt; atLeastEra @BabbageEra @(AlonzoEra StandardCrypto)
--   </pre>
atLeastEra :: AtLeastEra eraName era => ()

-- | Enforce era to be at most the specified era at the type level. In
--   other words compiler will produce type error when applied to eras
--   prior to the specified era. This function should be used in order to
--   avoid redundant constraints warning.
--   
--   For example these will type check
--   
--   <pre>
--   &gt;&gt;&gt; atMostEra @BabbageEra @(ShelleyEra StandardCrypto)
--   
--   &gt;&gt;&gt; atMostEra @AlonzoEra @(MaryEra StandardCrypto)
--   </pre>
--   
--   However this will result in a type error
--   
--   <pre>
--   &gt;&gt;&gt; atMostEra @BabbageEra @(ConwayEra StandardCrypto)
--   </pre>
atMostEra :: AtMostEra eraName era => ()
notSupportedInThisEra :: HasCallStack => a
notSupportedInThisEraL :: HasCallStack => Lens' a b

-- | Get the value level <a>Version</a> of the lowest major protocol
--   version for the supplied <tt>era</tt>.
eraProtVerLow :: forall era. Era era => Version

-- | Get the value level <a>Version</a> of the highest major protocol
--   version for the supplied <tt>era</tt>.
eraProtVerHigh :: forall era. Era era => Version

-- | Convert a type that implements <a>EncCBOR</a> to plain <a>Encoding</a>
--   using the lowest protocol version for the supplied <tt>era</tt>
toEraCBOR :: forall era t. (Era era, EncCBOR t) => t -> Encoding

-- | Convert a type that implements <a>DecCBOR</a> to plain <a>Decoder</a>
--   using the lowest protocol version for the supplied <tt>era</tt>
fromEraCBOR :: forall era t s. (Era era, DecCBOR t) => Decoder s t

-- | Convert a type that implements <a>DecShareCBOR</a> to plain
--   <a>Decoder</a> using the lowest protocol version for the supplied
--   <tt>era</tt>
fromEraShareCBOR :: forall era t s. (Era era, DecShareCBOR t) => Decoder s t

-- | Convert a versioned <a>Decoder</a> to plain a <a>Decoder</a> using the
--   lowest protocol version for the supplied <tt>era</tt>
eraDecoder :: forall era t s. Era era => Decoder s t -> Decoder s t
class (Era era, ToJSON (TxCert era), DecCBOR (TxCert era), EncCBOR (TxCert era), ToCBOR (TxCert era), FromCBOR (TxCert era), NoThunks (TxCert era), NFData (TxCert era), Show (TxCert era), Eq (TxCert era)) => EraTxCert era where {
    type TxCert era = (r :: Type) | r -> era;
    type TxCertUpgradeError era :: Type;
    type TxCertUpgradeError era = Void;
}

-- | Every era, except Shelley, must be able to upgrade a <a>TxCert</a>
--   from a previous era. However, not all certificates can be upgraded,
--   because some eras lose some of the certificates, thus return type is
--   an <a>Either</a>. Eg. from Babbage to Conway: MIR and Genesis
--   certificates were removed.
upgradeTxCert :: (EraTxCert era, EraTxCert (PreviousEra era)) => TxCert (PreviousEra era) -> Either (TxCertUpgradeError era) (TxCert era)

-- | Return a witness key whenever a certificate requires one
getVKeyWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (KeyHash 'Witness (EraCrypto era))

-- | Return a ScriptHash for certificate types that require a witness
getScriptWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (ScriptHash (EraCrypto era))
mkRegPoolTxCert :: EraTxCert era => PoolParams (EraCrypto era) -> TxCert era
getRegPoolTxCert :: EraTxCert era => TxCert era -> Maybe (PoolParams (EraCrypto era))
mkRetirePoolTxCert :: EraTxCert era => KeyHash 'StakePool (EraCrypto era) -> EpochNo -> TxCert era
getRetirePoolTxCert :: EraTxCert era => TxCert era -> Maybe (KeyHash 'StakePool (EraCrypto era), EpochNo)

-- | Extract staking credential from any certificate that can register such
--   credential
lookupRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))

-- | Extract staking credential from any certificate that can unregister
--   such credential
lookupUnRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))

-- | Compute the total deposits from a list of certificates.
getTotalDepositsTxCerts :: (EraTxCert era, Foldable f) => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> f (TxCert era) -> Coin

-- | Compute the total refunds from a list of certificates.
getTotalRefundsTxCerts :: (EraTxCert era, Foldable f) => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> f (TxCert era) -> Coin
pattern RegPoolTxCert :: EraTxCert era => PoolParams (EraCrypto era) -> TxCert era
pattern RetirePoolTxCert :: EraTxCert era => KeyHash 'StakePool (EraCrypto era) -> EpochNo -> TxCert era

-- | The delegation of one stake key to another.

-- | <i>Deprecated: No longer used</i>
data Delegation c

-- | <i>Deprecated: No longer used</i>
Delegation :: !StakeCredential c -> !KeyHash 'StakePool c -> Delegation c
[dDelegator] :: Delegation c -> !StakeCredential c
[dDelegatee] :: Delegation c -> !KeyHash 'StakePool c
data PoolCert c

-- | A stake pool registration certificate.
RegPool :: !PoolParams c -> PoolCert c

-- | A stake pool retirement certificate.
RetirePool :: !KeyHash 'StakePool c -> !EpochNo -> PoolCert c
getPoolCertTxCert :: EraTxCert era => TxCert era -> Maybe (PoolCert (EraCrypto era))

-- | <i>Deprecated: As useless. PoolIds have nothing to do with
--   credentials</i>
poolCWitness :: PoolCert c -> Credential 'StakePool c
poolCertKeyHashWitness :: PoolCert c -> KeyHash 'Witness c

-- | Check if supplied TxCert is a stake registering certificate
isRegStakeTxCert :: EraTxCert era => TxCert era -> Bool

-- | Check if supplied TxCert is a stake un-registering certificate
isUnRegStakeTxCert :: EraTxCert era => TxCert era -> Bool
class (Era era, Eq (PParamsHKD Identity era), Ord (PParamsHKD Identity era), Show (PParamsHKD Identity era), NFData (PParamsHKD Identity era), EncCBOR (PParamsHKD Identity era), DecCBOR (PParamsHKD Identity era), ToCBOR (PParamsHKD Identity era), FromCBOR (PParamsHKD Identity era), NoThunks (PParamsHKD Identity era), ToJSON (PParamsHKD Identity era), FromJSON (PParamsHKD Identity era), Eq (PParamsHKD StrictMaybe era), Ord (PParamsHKD StrictMaybe era), Show (PParamsHKD StrictMaybe era), NFData (PParamsHKD StrictMaybe era), EncCBOR (PParamsHKD StrictMaybe era), DecCBOR (PParamsHKD StrictMaybe era), ToCBOR (PParamsHKD StrictMaybe era), FromCBOR (PParamsHKD StrictMaybe era), NoThunks (PParamsHKD StrictMaybe era), ToJSON (PParamsHKD StrictMaybe era)) => EraPParams era where {
    
    -- | Protocol parameters where the fields are represented with a HKD
    type PParamsHKD (f :: Type -> Type) era = (r :: Type) | r -> era;
    
    type UpgradePParams (f :: Type -> Type) era :: Type;
    type DowngradePParams (f :: Type -> Type) era :: Type;
}

-- | Applies a protocol parameters update
applyPPUpdates :: EraPParams era => PParams era -> PParamsUpdate era -> PParams era

-- | Applies a protocol parameters update
applyPPUpdates :: forall a u. (EraPParams era, Generic (PParamsHKD Identity era), Generic (PParamsHKD StrictMaybe era), Updatable (Rep (PParamsHKD Identity era) a) (Rep (PParamsHKD StrictMaybe era) u)) => PParams era -> PParamsUpdate era -> PParams era
emptyPParamsIdentity :: EraPParams era => PParamsHKD Identity era
emptyPParamsStrictMaybe :: EraPParams era => PParamsHKD StrictMaybe era

-- | Upgrade PParams from previous era to the current one
upgradePParamsHKD :: (EraPParams era, HKDFunctor f, EraPParams (PreviousEra era)) => UpgradePParams f era -> PParamsHKD f (PreviousEra era) -> PParamsHKD f era

-- | Downgrade PParams from the current era to the previous one
downgradePParamsHKD :: (EraPParams era, HKDFunctor f, EraPParams (PreviousEra era)) => DowngradePParams f era -> PParamsHKD f era -> PParamsHKD f (PreviousEra era)

-- | The linear factor for the minimum fee calculation
hkdMinFeeAL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | The constant factor for the minimum fee calculation
hkdMinFeeBL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Maximal block body size
hkdMaxBBSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word32)

-- | Maximal transaction size
hkdMaxTxSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word32)

-- | Maximal block header size
hkdMaxBHSizeL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Word16)

-- | The amount of a key registration deposit
hkdKeyDepositL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | The amount of a pool registration deposit
hkdPoolDepositL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | epoch bound on pool retirement
hkdEMaxL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f EpochInterval)

-- | Desired number of pools
hkdNOptL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Natural)

-- | Pool influence
hkdA0L :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f NonNegativeInterval)

-- | Monetary expansion
hkdRhoL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Treasury expansion
hkdTauL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Decentralization parameter
hkdDL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 6) => Lens' (PParamsHKD f era) (HKD f UnitInterval)

-- | Decentralization parameter getter
ppDG :: EraPParams era => SimpleGetter (PParams era) UnitInterval

-- | Decentralization parameter getter
ppDG :: (EraPParams era, ProtVerAtMost era 6) => SimpleGetter (PParams era) UnitInterval

-- | Extra entropy
hkdExtraEntropyL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 6) => Lens' (PParamsHKD f era) (HKD f Nonce)

-- | Protocol version
hkdProtocolVersionL :: (EraPParams era, HKDFunctor f, ProtVerAtMost era 8) => Lens' (PParamsHKD f era) (HKD f ProtVer)
ppProtocolVersionL :: EraPParams era => Lens' (PParams era) ProtVer
ppProtocolVersionL :: (EraPParams era, ProtVerAtMost era 8) => Lens' (PParams era) ProtVer

-- | PParamsUpdate Protocol version
ppuProtocolVersionL :: (EraPParams era, ProtVerAtMost era 8) => Lens' (PParamsUpdate era) (StrictMaybe ProtVer)

-- | Minimum UTxO value
hkdMinUTxOValueL :: (EraPParams era, HKDFunctor f) => ProtVerAtMost era 4 => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Minimum Stake Pool Cost
hkdMinPoolCostL :: (EraPParams era, HKDFunctor f) => Lens' (PParamsHKD f era) (HKD f Coin)

-- | Protocol parameters
newtype PParams era
PParams :: PParamsHKD Identity era -> PParams era
emptyPParams :: EraPParams era => PParams era

-- | The type of updates to Protocol parameters
newtype PParamsUpdate era
PParamsUpdate :: PParamsHKD StrictMaybe era -> PParamsUpdate era
emptyPParamsUpdate :: EraPParams era => PParamsUpdate era
genericApplyPPUpdates :: forall era a u. (Generic (PParamsHKD Identity era), Generic (PParamsHKD StrictMaybe era), Updatable (Rep (PParamsHKD Identity era) a) (Rep (PParamsHKD StrictMaybe era) u)) => PParams era -> PParamsUpdate era -> PParams era

-- | The linear factor for the minimum fee calculation
ppMinFeeAL :: forall era. EraPParams era => Lens' (PParams era) Coin

-- | The constant factor for the minimum fee calculation
ppMinFeeBL :: forall era. EraPParams era => Lens' (PParams era) Coin

-- | Maximal block body size
ppMaxBBSizeL :: forall era. EraPParams era => Lens' (PParams era) Word32

-- | Maximal transaction size
ppMaxTxSizeL :: forall era. EraPParams era => Lens' (PParams era) Word32

-- | Maximal block header size
ppMaxBHSizeL :: forall era. EraPParams era => Lens' (PParams era) Word16

-- | The amount of a key registration deposit
ppKeyDepositL :: forall era. EraPParams era => Lens' (PParams era) Coin

-- | The amount of a pool registration deposit
ppPoolDepositL :: forall era. EraPParams era => Lens' (PParams era) Coin

-- | epoch bound on pool retirement
ppEMaxL :: forall era. EraPParams era => Lens' (PParams era) EpochInterval

-- | Desired number of pools
ppNOptL :: forall era. EraPParams era => Lens' (PParams era) Natural

-- | Pool influence
ppA0L :: forall era. EraPParams era => Lens' (PParams era) NonNegativeInterval

-- | Monetary expansion
ppRhoL :: forall era. EraPParams era => Lens' (PParams era) UnitInterval

-- | Treasury expansion
ppTauL :: forall era. EraPParams era => Lens' (PParams era) UnitInterval

-- | Decentralization parameter
ppDL :: forall era. (EraPParams era, ProtVerAtMost era 6) => Lens' (PParams era) UnitInterval

-- | Extra entropy
ppExtraEntropyL :: forall era. (EraPParams era, ProtVerAtMost era 6) => Lens' (PParams era) Nonce

-- | Minimum UTxO value
ppMinUTxOValueL :: forall era. (EraPParams era, ProtVerAtMost era 4) => Lens' (PParams era) Coin

-- | Minimum Stake Pool Cost
ppMinPoolCostL :: forall era. EraPParams era => Lens' (PParams era) Coin

-- | The linear factor for the minimum fee calculation
ppuMinFeeAL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)

-- | The constant factor for the minimum fee calculation
ppuMinFeeBL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)

-- | Maximal block body size
ppuMaxBBSizeL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Word32)

-- | Maximal transaction size
ppuMaxTxSizeL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Word32)

-- | Maximal block header size
ppuMaxBHSizeL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Word16)

-- | The amount of a key registration deposit
ppuKeyDepositL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)

-- | The amount of a pool registration deposit
ppuPoolDepositL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)

-- | epoch bound on pool retirement
ppuEMaxL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe EpochInterval)

-- | Desired number of pools
ppuNOptL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)

-- | Pool influence
ppuA0L :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe NonNegativeInterval)

-- | Monetary expansion
ppuRhoL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)

-- | Treasury expansion
ppuTauL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)

-- | Decentralization parameter
ppuDL :: forall era. (EraPParams era, ProtVerAtMost era 6) => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)

-- | Extra entropy
ppuExtraEntropyL :: forall era. (EraPParams era, ProtVerAtMost era 6) => Lens' (PParamsUpdate era) (StrictMaybe Nonce)

-- | Minimum UTxO value
ppuMinUTxOValueL :: forall era. (EraPParams era, ProtVerAtMost era 4) => Lens' (PParamsUpdate era) (StrictMaybe Coin)

-- | Minimum Stake Pool Cost
ppuMinPoolCostL :: forall era. EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppLens :: Lens' (PParams era) (PParamsHKD Identity era)
ppuLens :: Lens' (PParamsUpdate era) (PParamsHKD StrictMaybe era)
mapPParams :: (PParamsHKD Identity era1 -> PParamsHKD Identity era2) -> PParams era1 -> PParams era2
mapPParamsUpdate :: (PParamsHKD StrictMaybe era1 -> PParamsHKD StrictMaybe era2) -> PParamsUpdate era1 -> PParamsUpdate era2
upgradePParams :: (EraPParams era, EraPParams (PreviousEra era)) => UpgradePParams Identity era -> PParams (PreviousEra era) -> PParams era
downgradePParams :: (EraPParams era, EraPParams (PreviousEra era)) => DowngradePParams Identity era -> PParams era -> PParams (PreviousEra era)
upgradePParamsUpdate :: (EraPParams era, EraPParams (PreviousEra era)) => UpgradePParams StrictMaybe era -> PParamsUpdate (PreviousEra era) -> PParamsUpdate era
downgradePParamsUpdate :: (EraPParams era, EraPParams (PreviousEra era)) => DowngradePParams StrictMaybe era -> PParamsUpdate era -> PParamsUpdate (PreviousEra era)

-- | Pair the tag, and exisitenially hide the type of the lens for the
--   field with that Lens'
data PParam era
[PParam] :: ToPlutusData t => Word -> Lens' (PParamsUpdate era) (StrictMaybe t) -> PParam era

-- | Turn a list into a Map, this assures we have no duplicates.
makePParamMap :: [PParam era] -> Map Word (PParam era)

-- | Map an era to its predecessor.
--   
--   For example:
--   
--   <pre>
--   type instance PreviousEra (AllegraEra c) = ShelleyEra c
--   </pre>
type PreviousEra era = (r :: Type) | r -> era

-- | Per-era context used for <a>TranslateEra</a>.
--   
--   This context will be passed to the translation instances of <i>all</i>
--   types of that particular era. In practice, most instances won't need
--   the context, but this approach makes the translation composable (as
--   opposed to having a separate context per type).
type family TranslationContext era :: Type

-- | Most translations should be infallible (default instance), but we
--   leave the door open for partial translations.
--   
--   For a partial translation, override the default type to be <tt>()</tt>
--   or a concrete error type.
type TranslationError era f :: Type

-- | Translation of types between eras, e.g., from Shelley to Allegra.
--   
--   When <tt>era</tt> is just a phantom type parameter, an empty
--   standalone deriving can be used:
--   
--   <pre>
--   newtype Foo era = Foo Int
--   
--   instance TranslateEra (Allegra c) Foo
--   </pre>
--   
--   Note that one could use <tt>DerivingAnyClass</tt> (<tt>deriving
--   (TranslateEra (Allegra c))</tt>), but this would introduce an
--   undesired coupling between the era-parametric type and (a) particular
--   era(s). The intention is to have a module with orphan instances per
--   era.
--   
--   In most cases, the <tt>era</tt> parameter won't be phantom, and a
--   manual instance will have to be written:
--   
--   <pre>
--   newtype Bar era = Bar (TxBody era)
--   
--   instance CC.Crypto c =&gt; TranslateEra (Allegra c) Bar where
--       translateEra ctxt = Bar &lt;$&gt; translateEra ctxt
--   
--   -- With the following instance being in scope:
--   instance CC.Crypto c =&gt; TranslatEra (Allegra c) TxBody
--   </pre>
--   
--   Note: we use <a>PreviousEra</a> instead of <tt>NextEra</tt> as an era
--   definitely knows its predecessor, but not necessarily its successor.
--   Moreover, one could argue that it makes more sense to define the
--   translation from era A to era B where era B is defined, than where era
--   A is defined.
class (Era era, Era (PreviousEra era)) => TranslateEra era f

-- | Translate a type <tt>f</tt> parameterised by the era from an era to
--   the era after it.
--   
--   The translation is a given the translation context of <tt>era</tt>.
--   
--   A default instance is provided for when the two types are
--   <a>Coercible</a>.
translateEra :: TranslateEra era f => TranslationContext era -> f (PreviousEra era) -> Except (TranslationError era f) (f era)

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <tt>()</tt>, converting the result to a <a>Maybe</a>.
translateEraMaybe :: (TranslateEra era f, TranslationError era f ~ ()) => TranslationContext era -> f (PreviousEra era) -> Maybe (f era)

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <a>Void</a> and the translation thus cannot fail.
translateEra' :: (TranslateEra era f, TranslationError era f ~ Void) => TranslationContext era -> f (PreviousEra era) -> f era

-- | Translate a type through its binary representation from previous era
--   to the current one.
translateEraThroughCBOR :: forall era ti to. (Era era, ToCBOR (ti (PreviousEra era)), DecCBOR (Annotator (to era))) => Text -> ti (PreviousEra era) -> Except DecoderError (to era)

-- | <i>Deprecated: Use <a>hashTxAuxData</a> instead</i>
hashAuxiliaryData :: EraTxAuxData era => TxAuxData era -> AuxiliaryDataHash (EraCrypto era)

-- | <i>Deprecated: Use <a>validateTxAuxData</a> instead</i>
validateAuxiliaryData :: EraTxAuxData era => ProtVer -> TxAuxData era -> Bool

module Cardano.Ledger.Plutus.Data

-- | This is a wrapper with a phantom era for PV1.Data, since we need
--   something with kind (* -&gt; *) for MemoBytes
newtype PlutusData era
PlutusData :: Data -> PlutusData era
data Data era
pattern Data :: Era era => Data -> Data era
unData :: Data era -> Data
type DataHash c = SafeHash c EraIndependentData

-- | Upgrade <a>Data</a> from one era to another. While the underlying data
--   will remain the same, the memoised serialisation may change to reflect
--   the versioned serialisation of the new era.
upgradeData :: (Era era1, Era era2) => Data era1 -> Data era2
hashData :: Era era => Data era -> DataHash (EraCrypto era)
getPlutusData :: Data era -> Data
dataHashSize :: StrictMaybe (DataHash c) -> Integer

-- | Inlined data must be stored in the most compact form because it
--   contributes to the memory overhead of the ledger state. Constructor is
--   intentionally not exported, in order to prevent invalid creation of
--   data from arbitrary binary data. Use <a>makeBinaryData</a> for smart
--   construction.
data BinaryData era
hashBinaryData :: Era era => BinaryData era -> DataHash (EraCrypto era)

-- | Construct <a>BinaryData</a> from a buffer of bytes, while ensuring
--   that it can be later safely converted to <a>Data</a> with
--   <a>binaryDataToData</a>
makeBinaryData :: Era era => ShortByteString -> Either String (BinaryData era)

-- | It is safe to convert <a>BinaryData</a> to <a>Data</a> because the
--   only way to construct <a>BinaryData</a> is through the smart
--   constructor <a>makeBinaryData</a> that takes care of validation.
binaryDataToData :: Era era => BinaryData era -> Data era
dataToBinaryData :: Era era => Data era -> BinaryData era

-- | Datum can be described by a either a data hash or binary data, but not
--   both. It can also be neither one of them.
data Datum era
NoDatum :: Datum era
DatumHash :: !DataHash (EraCrypto era) -> Datum era
Datum :: !BinaryData era -> Datum era

-- | Get the Hash of the datum.
datumDataHash :: Era era => Datum era -> StrictMaybe (DataHash (EraCrypto era))
translateDatum :: EraCrypto era1 ~ EraCrypto era2 => Datum era1 -> Datum era2
instance Codec.Serialise.Class.Serialise (Cardano.Ledger.Plutus.Data.PlutusData era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Data.PlutusData era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Plutus.Data.PlutusData era)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Data.PlutusData era)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Data.PlutusData era)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Data.PlutusData era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Plutus.Data.Data era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Plutus.Data.Data era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Plutus.Data.Data era)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Data.Data era)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Data.Data era)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Data.BinaryData era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Plutus.Data.BinaryData era)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Data.BinaryData era)
instance GHC.Classes.Ord (Cardano.Ledger.Plutus.Data.BinaryData era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Data.BinaryData era)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Data.BinaryData era)
instance GHC.Show.Show (Cardano.Ledger.Plutus.Data.Datum era)
instance GHC.Classes.Ord (Cardano.Ledger.Plutus.Data.Datum era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Data.Datum era)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.Data.Datum era)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.Data.Datum era)
instance Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Core.Era.EraCrypto era)) => GHC.Show.Show (Cardano.Ledger.Plutus.Data.Data era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Plutus.Data.Data era))
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Data.Datum era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.Data.Datum era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Plutus.Data.Datum era)
instance (Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Plutus.Data.BinaryData era) Cardano.Ledger.Hashes.EraIndependentData c
instance Data.Typeable.Internal.Typeable era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Data.BinaryData era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.Data.BinaryData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Data.Data era)
instance Cardano.Ledger.MemoBytes.Memoized Cardano.Ledger.Plutus.Data.Data
instance (Cardano.Ledger.Core.Era.EraCrypto era GHC.Types.~ c) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Plutus.Data.Data era) Cardano.Ledger.Hashes.EraIndependentData c
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.Data.Data era)
instance Data.Typeable.Internal.Typeable era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.Data.PlutusData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Plutus.Data.PlutusData era))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.HeapWords.HeapWords (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Hashes.DataHash c))

module Cardano.Ledger.Plutus.TxInfo

-- | A transaction output can be translated because it is a newly created
--   output, or because it is the output which is connected to a
--   transaction input being spent.
data TxOutSource c
TxOutFromInput :: !TxIn c -> TxOutSource c
TxOutFromOutput :: !TxIx -> TxOutSource c
txOutSourceToText :: TxOutSource c -> Text

-- | Translate an address. <a>NetworkId</a> is discarded and Byron
--   Addresses will result in Nothing.
transAddr :: Addr c -> Maybe Address

-- | Translate reward account by discarding <tt>NetowrkId</tt> and only
--   translating the staking credential.
--   
--   <i>Note</i> - This function is the right one to use starting with
--   PlutusV3, prior to that an extra <a>StakingHash</a> wrapper is needed.
transRewardAccount :: RewardAcnt c -> Credential
transDataHash :: DataHash c -> DatumHash
transKeyHash :: KeyHash d c -> PubKeyHash
transSafeHash :: SafeHash c i -> BuiltinByteString
transScriptHash :: ScriptHash c -> ScriptHash
transTxId :: TxId c -> TxId
transStakeReference :: StakeReference c -> Maybe StakingCredential
transCred :: Credential kr c -> Credential
slotToPOSIXTime :: EpochInfo (Either Text) -> SystemStart -> SlotNo -> Either Text POSIXTime
transTxIn :: TxIn c -> TxOutRef
transCoinToValue :: Coin -> Value
transCoinToLovelace :: Coin -> Lovelace
transDataPair :: (DataHash c, Data era) -> (DatumHash, Datum)
transExUnits :: ExUnits -> ExBudget
exBudgetToExUnits :: ExBudget -> Maybe ExUnits
transBoundedRational :: BoundedRational r => r -> Rational
transEpochNo :: EpochNo -> Integer
transEpochInterval :: EpochInterval -> Integer
instance NoThunks.Class.NoThunks (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance GHC.Generics.Generic (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance GHC.Show.Show (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance GHC.Classes.Eq (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Plutus.TxInfo.TxOutSource era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Plutus.TxInfo.TxOutSource c)

module Cardano.Ledger.Plutus.Evaluate

-- | This type contains all that is necessary from Ledger to evaluate a
--   plutus script.
data PlutusWithContext
[PlutusWithContext] :: PlutusLanguage l => !Version -> !Either (Plutus l) (PlutusRunnable l) -> !PlutusDatums -> !ExUnits -> !CostModel -> PlutusWithContext
data ScriptFailure
ScriptFailure :: Text -> PlutusWithContext -> ScriptFailure
[scriptFailureMessage] :: ScriptFailure -> Text
[scriptFailurePlutus] :: ScriptFailure -> PlutusWithContext
data ScriptResult
Passes :: [PlutusWithContext] -> ScriptResult
Fails :: [PlutusWithContext] -> NonEmpty ScriptFailure -> ScriptResult
scriptPass :: PlutusWithContext -> ScriptResult
scriptFail :: ScriptFailure -> ScriptResult
newtype PlutusDatums
PlutusDatums :: [Data] -> PlutusDatums
[unPlutusDatums] :: PlutusDatums -> [Data]
data PlutusDebugInfo
DebugBadHex :: String -> PlutusDebugInfo
DebugCannotDecode :: String -> PlutusDebugInfo
DebugSuccess :: [Text] -> ExBudget -> PlutusDebugInfo
DebugFailure :: [Text] -> EvaluationError -> PlutusWithContext -> PlutusDebugInfo
debugPlutus :: String -> PlutusDebugInfo
runPlutusScript :: PlutusWithContext -> ScriptResult
runPlutusScriptWithLogs :: PlutusWithContext -> ([Text], ScriptResult)
evaluatePlutusWithContext :: VerboseMode -> PlutusWithContext -> ([Text], Either EvaluationError ExBudget)

-- | Explain why a script might fail. Scripts come in two flavors:
--   
--   <ol>
--   <li>with 3 data arguments [data,redeemer,context]</li>
--   <li>with 2 data arguments [redeemer,context].</li>
--   </ol>
--   
--   It pays to decode the context data into a real context because that
--   provides way more information. But there is no guarantee the context
--   data really can be decoded.
explainPlutusEvaluationError :: PlutusWithContext -> EvaluationError -> ScriptResult
instance GHC.Show.Show Cardano.Ledger.Plutus.Evaluate.PlutusDatums
instance GHC.Classes.Eq Cardano.Ledger.Plutus.Evaluate.PlutusDatums
instance GHC.Generics.Generic Cardano.Ledger.Plutus.Evaluate.ScriptFailure
instance GHC.Show.Show Cardano.Ledger.Plutus.Evaluate.ScriptFailure
instance GHC.Generics.Generic Cardano.Ledger.Plutus.Evaluate.ScriptResult
instance GHC.Show.Show Cardano.Ledger.Plutus.Evaluate.PlutusDebugInfo
instance GHC.Show.Show Cardano.Ledger.Plutus.Evaluate.PlutusWithContext
instance GHC.Base.Semigroup Cardano.Ledger.Plutus.Evaluate.ScriptResult
instance GHC.Base.Monoid Cardano.Ledger.Plutus.Evaluate.ScriptResult
instance GHC.Classes.Eq Cardano.Ledger.Plutus.Evaluate.PlutusWithContext
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Plutus.Evaluate.PlutusWithContext
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Plutus.Evaluate.PlutusWithContext
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Plutus.Evaluate.PlutusDatums
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Plutus.Evaluate.PlutusDatums

module Cardano.Ledger.Plutus


-- | Support for multiple (Shelley-based) eras in the ledger.
module Cardano.Ledger.Era
class (Crypto (EraCrypto era), Typeable era, KnownNat (ProtVerLow era), KnownNat (ProtVerHigh era), ProtVerLow era <= ProtVerHigh era, MinVersion <= ProtVerLow era, MinVersion <= ProtVerHigh era, CmpNat (ProtVerLow era) MaxVersion ~ 'LT, CmpNat (ProtVerHigh era) MaxVersion ~ 'LT, ProtVerLow era <= MaxVersion, ProtVerHigh era <= MaxVersion) => Era era where {
    type EraCrypto era :: Type;
    
    -- | Map an era to its predecessor.
    --   
    --   For example:
    --   
    --   <pre>
    --   type instance PreviousEra (AllegraEra c) = ShelleyEra c
    --   </pre>
    type PreviousEra era = (r :: Type) | r -> era;
    
    -- | Lowest major protocol version for this era
    type ProtVerLow era :: Nat;
    
    -- | Highest major protocol version for this era. By default se to
    --   <a>ProtVerLow</a>
    type ProtVerHigh era :: Nat;
    type ProtVerHigh era = ProtVerLow era;
}

-- | Textual name of the current era.
--   
--   Designed to be used with <tt>TypeApplications</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; eraName @(ByronEra StandardCrypto)
--   Byron
--   </pre>
eraName :: Era era => String

-- | <i>Deprecated: In favor of <a>addrTxOutL</a></i>
getTxOutAddr :: EraTxOut era => TxOut era -> Addr (EraCrypto era)

-- | <i>Deprecated: In favor of <a>compactAddrTxOutL</a></i>
getTxOutCompactAddr :: EraTxOut era => TxOut era -> CompactAddr (EraCrypto era)

-- | <i>Deprecated: In favor of <a>addrEitherTxOutL</a></i>
getTxOutEitherAddr :: EraTxOut era => TxOut era -> Either (Addr (EraCrypto era)) (CompactAddr (EraCrypto era))

-- | Get the Bootsrap address from the TxOut. Returns <a>Nothing</a> if it
--   is a Shelley address or newer

-- | <i>Deprecated: In favor of <a>bootAddrTxOutF</a></i>
getTxOutBootstrapAddress :: EraTxOut era => TxOut era -> Maybe (BootstrapAddress (EraCrypto era))

-- | The validity of any individual block depends only on a subset of the
--   UTxO stored in the ledger state. The consensus layer makes use of this
--   fact, and uses the function below to to retrieve the needed UTxO from
--   disk and present only those to the ledger. It is therefore neccessary
--   that this function account for all the different types of inputs
--   inside a transaction.
getAllTxInputs :: EraTxBody era => TxBody era -> Set (TxIn (EraCrypto era))

-- | Per-era context used for <a>TranslateEra</a>.
--   
--   This context will be passed to the translation instances of <i>all</i>
--   types of that particular era. In practice, most instances won't need
--   the context, but this approach makes the translation composable (as
--   opposed to having a separate context per type).
type family TranslationContext era :: Type

-- | Translation of types between eras, e.g., from Shelley to Allegra.
--   
--   When <tt>era</tt> is just a phantom type parameter, an empty
--   standalone deriving can be used:
--   
--   <pre>
--   newtype Foo era = Foo Int
--   
--   instance TranslateEra (Allegra c) Foo
--   </pre>
--   
--   Note that one could use <tt>DerivingAnyClass</tt> (<tt>deriving
--   (TranslateEra (Allegra c))</tt>), but this would introduce an
--   undesired coupling between the era-parametric type and (a) particular
--   era(s). The intention is to have a module with orphan instances per
--   era.
--   
--   In most cases, the <tt>era</tt> parameter won't be phantom, and a
--   manual instance will have to be written:
--   
--   <pre>
--   newtype Bar era = Bar (TxBody era)
--   
--   instance CC.Crypto c =&gt; TranslateEra (Allegra c) Bar where
--       translateEra ctxt = Bar &lt;$&gt; translateEra ctxt
--   
--   -- With the following instance being in scope:
--   instance CC.Crypto c =&gt; TranslatEra (Allegra c) TxBody
--   </pre>
--   
--   Note: we use <a>PreviousEra</a> instead of <tt>NextEra</tt> as an era
--   definitely knows its predecessor, but not necessarily its successor.
--   Moreover, one could argue that it makes more sense to define the
--   translation from era A to era B where era B is defined, than where era
--   A is defined.
class (Era era, Era (PreviousEra era)) => TranslateEra era f where {
    
    -- | Most translations should be infallible (default instance), but we
    --   leave the door open for partial translations.
    --   
    --   For a partial translation, override the default type to be <tt>()</tt>
    --   or a concrete error type.
    type TranslationError era f :: Type;
    type TranslationError era f = Void;
}

-- | Translate a type <tt>f</tt> parameterised by the era from an era to
--   the era after it.
--   
--   The translation is a given the translation context of <tt>era</tt>.
--   
--   A default instance is provided for when the two types are
--   <a>Coercible</a>.
translateEra :: TranslateEra era f => TranslationContext era -> f (PreviousEra era) -> Except (TranslationError era f) (f era)

-- | Translate a type <tt>f</tt> parameterised by the era from an era to
--   the era after it.
--   
--   The translation is a given the translation context of <tt>era</tt>.
--   
--   A default instance is provided for when the two types are
--   <a>Coercible</a>.
translateEra :: (TranslateEra era f, Coercible (f (PreviousEra era)) (f era), TranslationContext era ~ ()) => TranslationContext era -> f (PreviousEra era) -> Except (TranslationError era f) (f era)

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <a>Void</a> and the translation thus cannot fail.
translateEra' :: (TranslateEra era f, TranslationError era f ~ Void) => TranslationContext era -> f (PreviousEra era) -> f era

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <tt>()</tt>, converting the result to a <a>Maybe</a>.
translateEraMaybe :: (TranslateEra era f, TranslationError era f ~ ()) => TranslationContext era -> f (PreviousEra era) -> Maybe (f era)

-- | Indicates that an era supports segregated witnessing.
--   
--   This class embodies an isomorphism between 'TxSeq era' and 'StrictSeq
--   (Tx era)', witnessed by <a>fromTxSeq</a> and <a>toTxSeq</a>.
class (EraTx era, Eq (TxSeq era), Show (TxSeq era), EncCBORGroup (TxSeq era), DecCBOR (Annotator (TxSeq era))) => EraSegWits era where {
    type TxSeq era = (r :: Type) | r -> era;
}
fromTxSeq :: EraSegWits era => TxSeq era -> StrictSeq (Tx era)
toTxSeq :: EraSegWits era => StrictSeq (Tx era) -> TxSeq era

-- | Get the block body hash from the TxSeq. Note that this is not a
--   regular "hash the stored bytes" function since the block body hash
--   forms a small Merkle tree.
hashTxSeq :: EraSegWits era => TxSeq era -> Hash (HASH (EraCrypto era)) EraIndependentBlockBody

-- | The number of segregated components
numSegComponents :: EraSegWits era => Word64


-- | This modules implements the necessary functions for the changes that
--   can happen at epoch boundaries.
module Cardano.Ledger.EpochBoundary

-- | Type of stake as map from hash key to coins associated.
newtype Stake c
Stake :: VMap VB VP (Credential 'Staking c) (CompactForm Coin) -> Stake c
[$sel:unStake:Stake] :: Stake c -> VMap VB VP (Credential 'Staking c) (CompactForm Coin)
sumAllStake :: Stake c -> Coin
sumStakePerPool :: VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> Stake c -> Map (KeyHash 'StakePool c) Coin

-- | Snapshot of the stake distribution.
data SnapShot c
SnapShot :: !Stake c -> !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> !VMap VB VB (KeyHash 'StakePool c) (PoolParams c) -> SnapShot c
[$sel:ssStake:SnapShot] :: SnapShot c -> !Stake c
[$sel:ssDelegations:SnapShot] :: SnapShot c -> !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c)
[$sel:ssPoolParams:SnapShot] :: SnapShot c -> !VMap VB VB (KeyHash 'StakePool c) (PoolParams c)

-- | Snapshots of the stake distribution.
--   
--   Note that ssStakeMark and ssStakeMarkPoolDistr are lazy on purpose
--   since we only want to force the thunk after one stability window when
--   we know that they are stable (so that we do not compute them if we do
--   not have to). See more info in the <a>Optimize TICKF ADR</a>
data SnapShots c
SnapShots :: SnapShot c -> PoolDistr c -> !SnapShot c -> !SnapShot c -> !Coin -> SnapShots c
[$sel:ssStakeMark:SnapShots] :: SnapShots c -> SnapShot c
[$sel:ssStakeMarkPoolDistr:SnapShots] :: SnapShots c -> PoolDistr c
[$sel:ssStakeSet:SnapShots] :: SnapShots c -> !SnapShot c
[$sel:ssStakeGo:SnapShots] :: SnapShots c -> !SnapShot c
[$sel:ssFee:SnapShots] :: SnapShots c -> !Coin
emptySnapShot :: SnapShot c
emptySnapShots :: SnapShots c

-- | Get stake of one pool
poolStake :: KeyHash 'StakePool c -> VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> Stake c -> Stake c

-- | Version of <a>maxPool'</a> that extracts <a>ppA0L</a> and
--   <a>ppNOptL</a> from a <a>PParams</a>
maxPool :: EraPParams era => PParams era -> Coin -> Rational -> Rational -> Coin

-- | Calculate maximal pool reward
maxPool' :: NonNegativeInterval -> Natural -> Coin -> Rational -> Rational -> Coin
calculatePoolDistr :: SnapShot c -> PoolDistr c
calculatePoolDistr' :: forall c. (KeyHash 'StakePool c -> Bool) -> SnapShot c -> PoolDistr c

-- | Sum up the Coin (as CompactForm Coin = Word64) for each StakePool
calculatePoolStake :: (KeyHash 'StakePool c -> Bool) -> VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> Stake c -> Map (KeyHash 'StakePool c) Word64
ssStakeMarkL :: Lens' (SnapShots c) (SnapShot c)
ssStakeMarkPoolDistrL :: Lens' (SnapShots c) (PoolDistr c)
ssStakeSetL :: Lens' (SnapShots c) (SnapShot c)
ssStakeGoL :: Lens' (SnapShots c) (SnapShot c)
ssFeeL :: Lens' (SnapShots c) Coin
ssStakeL :: Lens' (SnapShot c) (Stake c)
ssStakeDistrL :: Lens' (SnapShot c) (VMap VB VP (Credential 'Staking c) (CompactForm Coin))
ssDelegationsL :: Lens' (SnapShot c) (VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c))
ssPoolParamsL :: Lens' (SnapShot c) (VMap VB VB (KeyHash 'StakePool c) (PoolParams c))
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.EpochBoundary.Stake c)
instance GHC.Generics.Generic (Cardano.Ledger.EpochBoundary.Stake c)
instance Control.DeepSeq.NFData (Cardano.Ledger.EpochBoundary.Stake c)
instance GHC.Classes.Eq (Cardano.Ledger.EpochBoundary.Stake c)
instance GHC.Show.Show (Cardano.Ledger.EpochBoundary.Stake c)
instance GHC.Generics.Generic (Cardano.Ledger.EpochBoundary.SnapShot c)
instance GHC.Classes.Eq (Cardano.Ledger.EpochBoundary.SnapShot c)
instance GHC.Show.Show (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.EpochBoundary.SnapShots c)
instance GHC.Generics.Generic (Cardano.Ledger.EpochBoundary.SnapShots c)
instance GHC.Classes.Eq (Cardano.Ledger.EpochBoundary.SnapShots c)
instance GHC.Show.Show (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.EpochBoundary.Stake c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.EpochBoundary.Stake c)
instance Control.DeepSeq.NFData (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Data.Default.Class.Default (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.EpochBoundary.SnapShots c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Control.DeepSeq.NFData (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.EpochBoundary.SnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.EpochBoundary.Stake c)

module Cardano.Ledger.CertState

-- | The state associated with the DELPL rule, which combines the DELEG
--   rule and the POOL rule.
data CertState era
CertState :: !VState era -> !PState era -> !DState era -> CertState era
[certVState] :: CertState era -> !VState era
[certPState] :: CertState era -> !PState era
[certDState] :: CertState era -> !DState era

-- | The state used by the DELEG rule, which roughly tracks stake
--   delegation and some governance features.
data DState era
DState :: !UMap (EraCrypto era) -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)) -> !GenDelegs (EraCrypto era) -> !InstantaneousRewards (EraCrypto era) -> DState era

-- | Unified Reward Maps. This contains the reward map (which is the source
--   of truth regarding the registered stake credentials, the deposit map,
--   the delegation map, and the stake credential pointer map.
[dsUnified] :: DState era -> !UMap (EraCrypto era)

-- | Future genesis key delegations
[dsFutureGenDelegs] :: DState era -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era))

-- | Genesis key delegations
[dsGenDelegs] :: DState era -> !GenDelegs (EraCrypto era)

-- | Instantaneous Rewards
[dsIRewards] :: DState era -> !InstantaneousRewards (EraCrypto era)

-- | The state used by the POOL rule, which tracks stake pool information.
data PState era
PState :: !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin -> PState era

-- | The stake pool parameters.
[psStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))

-- | The future stake pool parameters. Changes to existing stake pool
--   parameters are staged in order to give delegators time to react to
--   changes. See section 11.2, "Example Illustration of the Reward Cycle",
--   of the Shelley Ledger Specification for a sequence diagram.
[psFutureStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))

-- | A map of retiring stake pools to the epoch when they retire.
[psRetiring] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo

-- | A map of the deposits for each pool
[psDeposits] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin

-- | The state that tracks the voting entities (DReps and Constitutional
--   Committee members)
data VState era
VState :: !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)) -> !CommitteeState era -> EpochNo -> VState era
[vsDReps] :: VState era -> !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era))
[vsCommitteeState] :: VState era -> !CommitteeState era

-- | Number of contiguous epochs in which there are exactly zero active
--   governance proposals to vote on. It is incremented in every EPOCH rule
--   if the number of active governance proposals to vote on continues to
--   be zero. It is reset to zero when a new governance action is
--   successfully proposed. We need this counter in order to bump DRep
--   expiries through dormant periods when DReps do not have an opportunity
--   to vote on anything.
[vsNumDormantEpochs] :: VState era -> EpochNo

-- | InstantaneousRewards captures the pending changes to the ledger state
--   caused by MIR certificates. It consists of two mappings, the rewards
--   which will be paid out from the reserves and the rewards which will be
--   paid out from the treasury. It also consists of two coin values which
--   represent the transfer of coins from one pot to the other pot. NOTE
--   that the following property should always hold: deltaReserves +
--   deltaTreasury = 0
data InstantaneousRewards c
InstantaneousRewards :: !Map (Credential 'Staking c) Coin -> !Map (Credential 'Staking c) Coin -> !DeltaCoin -> !DeltaCoin -> InstantaneousRewards c
[iRReserves] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[iRTreasury] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[deltaReserves] :: InstantaneousRewards c -> !DeltaCoin
[deltaTreasury] :: InstantaneousRewards c -> !DeltaCoin
data FutureGenDeleg c
FutureGenDeleg :: !SlotNo -> !KeyHash 'Genesis c -> FutureGenDeleg c
[fGenDelegSlot] :: FutureGenDeleg c -> !SlotNo
[fGenDelegGenKeyHash] :: FutureGenDeleg c -> !KeyHash 'Genesis c
data Anchor c
Anchor :: !Url -> !SafeHash c AnchorData -> Anchor c
[anchorUrl] :: Anchor c -> !Url
[anchorDataHash] :: Anchor c -> !SafeHash c AnchorData
data DRepState c
DRepState :: !EpochNo -> !StrictMaybe (Anchor c) -> !Coin -> DRepState c
[drepExpiry] :: DRepState c -> !EpochNo
[drepAnchor] :: DRepState c -> !StrictMaybe (Anchor c)
[drepDeposit] :: DRepState c -> !Coin
data DRep c
DRepAlwaysAbstain :: DRep c
DRepAlwaysNoConfidence :: DRep c
pattern DRepCredential :: Credential 'DRepRole c -> DRep c
newtype CommitteeState era
CommitteeState :: Map (Credential 'ColdCommitteeRole (EraCrypto era)) (Maybe (Credential 'HotCommitteeRole (EraCrypto era))) -> CommitteeState era

-- | <a>Nothing</a> to indicate "resigned".
[csCommitteeCreds] :: CommitteeState era -> Map (Credential 'ColdCommitteeRole (EraCrypto era)) (Maybe (Credential 'HotCommitteeRole (EraCrypto era)))
data AnchorData

-- | Function that looks up the deposit for currently delegated staking
--   credential
lookupDepositDState :: DState era -> StakeCredential (EraCrypto era) -> Maybe Coin

-- | Function that looks up curret reward for the delegated staking
--   credential.
lookupRewardDState :: DState era -> StakeCredential (EraCrypto era) -> Maybe Coin
rewards :: DState era -> UView (EraCrypto era) (Credential 'Staking (EraCrypto era)) RDPair
delegations :: DState era -> UView (EraCrypto era) (Credential 'Staking (EraCrypto era)) (KeyHash 'StakePool (EraCrypto era))

-- | get the actual ptrs map, we don't need a view
ptrsMap :: DState era -> Map Ptr (Credential 'Staking (EraCrypto era))

-- | One only pays a deposit on the initial pool registration. So return
--   the the Deposits unchanged if the keyhash already exists. There are
--   legal situations where a pool may be registered multiple times.
payPoolDeposit :: EraPParams era => KeyHash 'StakePool (EraCrypto era) -> PParams era -> PState era -> PState era
refundPoolDeposit :: KeyHash 'StakePool (EraCrypto era) -> PState era -> (Coin, PState era)

-- | Calculate total possible refunds in the system that are related to
--   certificates
--   
--   There is an invariant that the sum of all the fields should be the
--   same as the utxosDeposited field of the UTxOState. Note that this does
--   not depend upon the current values of the Key and Pool deposits of the
--   PParams.
obligationCertState :: CertState era -> Obligations

-- | A composite of all the Deposits the system is obligated to eventually
--   pay back.
data Obligations
Obligations :: !Coin -> !Coin -> !Coin -> !Coin -> Obligations
[oblStake] :: Obligations -> !Coin
[oblPool] :: Obligations -> !Coin
[oblDRep] :: Obligations -> !Coin
[oblProposal] :: Obligations -> !Coin
sumObligation :: Obligations -> Coin

-- | Compute the total deposits from the Certs of a TxBody.
--   
--   This is the contribution of a TxBody towards the deposit pot
--   (utxosDeposit field of the UTxOState) of the system
certsTotalDepositsTxBody :: EraTxBody era => PParams era -> CertState era -> TxBody era -> Coin

-- | Compute the total refunds from the Certs of a TxBody.
--   
--   This is the contribution of a TxBody towards the total
--   <a>Obligations</a> of the system See <a>Obligations</a> and
--   <a>obligationCertState</a> for more information.
certsTotalRefundsTxBody :: EraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
certDStateL :: Lens' (CertState era) (DState era)
certPStateL :: Lens' (CertState era) (PState era)
certVStateL :: Lens' (CertState era) (VState era)
dsUnifiedL :: Lens' (DState era) (UMap (EraCrypto era))
dsGenDelegsL :: Lens' (DState era) (GenDelegs (EraCrypto era))
dsIRewardsL :: Lens' (DState era) (InstantaneousRewards (EraCrypto era))
dsFutureGenDelegsL :: Lens' (DState era) (Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)))
psStakePoolParamsL :: Lens' (PState era) (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)))
psFutureStakePoolParamsL :: Lens' (PState era) (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)))
psRetiringL :: Lens' (PState era) (Map (KeyHash 'StakePool (EraCrypto era)) EpochNo)
psDepositsL :: Lens' (PState era) (Map (KeyHash 'StakePool (EraCrypto era)) Coin)
vsDRepsL :: Lens' (VState era) (Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)))
vsCommitteeStateL :: Lens' (VState era) (CommitteeState era)
vsNumDormantEpochsL :: Lens' (VState era) EpochNo
csCommitteeCredsL :: Lens' (CommitteeState era) (Map (Credential 'ColdCommitteeRole (EraCrypto era)) (Maybe (Credential 'HotCommitteeRole (EraCrypto era))))

-- | Function that looks up the deposit for currently registered DRep
lookupDepositVState :: VState era -> Credential 'DRepRole (EraCrypto era) -> Maybe Coin
instance GHC.Generics.Generic (Cardano.Ledger.CertState.FutureGenDeleg c)
instance GHC.Classes.Ord (Cardano.Ledger.CertState.FutureGenDeleg c)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.FutureGenDeleg c)
instance GHC.Show.Show (Cardano.Ledger.CertState.FutureGenDeleg c)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.InstantaneousRewards c)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.InstantaneousRewards c)
instance GHC.Show.Show (Cardano.Ledger.CertState.InstantaneousRewards c)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.DState era)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.DState era)
instance GHC.Show.Show (Cardano.Ledger.CertState.DState era)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.PState era)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.PState era)
instance GHC.Show.Show (Cardano.Ledger.CertState.PState era)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.CommitteeState era)
instance Control.DeepSeq.NFData (Cardano.Ledger.CertState.CommitteeState era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Show.Show (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Classes.Ord (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.VState era)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.VState era)
instance GHC.Show.Show (Cardano.Ledger.CertState.VState era)
instance GHC.Generics.Generic (Cardano.Ledger.CertState.CertState era)
instance GHC.Classes.Eq (Cardano.Ledger.CertState.CertState era)
instance GHC.Show.Show (Cardano.Ledger.CertState.CertState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.CommitteeState era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.CommitteeState era)
instance GHC.Base.Semigroup Cardano.Ledger.CertState.Obligations
instance GHC.Base.Monoid Cardano.Ledger.CertState.Obligations
instance GHC.Show.Show Cardano.Ledger.CertState.Obligations
instance Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Era.EraCrypto era) => NoThunks.Class.NoThunks (Cardano.Ledger.CertState.CertState era)
instance Cardano.Ledger.Core.Era.Era era => Control.DeepSeq.NFData (Cardano.Ledger.CertState.CertState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.CertState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.CertState era)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.CertState era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.CertState era)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.VState era)
instance Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Era.EraCrypto era) => NoThunks.Class.NoThunks (Cardano.Ledger.CertState.VState era)
instance Cardano.Ledger.Core.Era.Era era => Control.DeepSeq.NFData (Cardano.Ledger.CertState.VState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.VState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.CertState.VState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.VState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.CommitteeState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.CertState.CommitteeState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.CertState.CommitteeState era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.CertState.PState era)
instance Control.DeepSeq.NFData (Cardano.Ledger.CertState.PState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.PState era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.PState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.PState era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.CertState.PState era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.PState era)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.PState c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.CertState.DState era)
instance Control.DeepSeq.NFData (Cardano.Ledger.CertState.DState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.InstantaneousRewards (Cardano.Ledger.Core.Era.EraCrypto era))) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.DState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.InstantaneousRewards (Cardano.Ledger.Core.Era.EraCrypto era))) => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.DState era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.DState era)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.DState era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.CertState.InstantaneousRewards c)
instance Control.DeepSeq.NFData (Cardano.Ledger.CertState.InstantaneousRewards c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.InstantaneousRewards c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.InstantaneousRewards c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.CertState.InstantaneousRewards c)
instance Data.Default.Class.Default (Cardano.Ledger.CertState.InstantaneousRewards c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.CertState.FutureGenDeleg c)
instance Control.DeepSeq.NFData (Cardano.Ledger.CertState.FutureGenDeleg c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.CertState.FutureGenDeleg c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.CertState.FutureGenDeleg c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.CertState.FutureGenDeleg c)

module Cardano.Ledger.UTxO

-- | The unspent transaction outputs.
newtype UTxO era
UTxO :: Map (TxIn (EraCrypto era)) (TxOut era) -> UTxO era
[unUTxO] :: UTxO era -> Map (TxIn (EraCrypto era)) (TxOut era)
class EraTx era => EraUTxO era where {
    
    -- | A customizable type on per era basis for the information required to
    --   find all scripts needed for the transaction.
    type ScriptsNeeded era = (r :: Type) | r -> era;
}

-- | Calculate all the value that is being consumed by the transaction.
getConsumedValue :: EraUTxO era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> UTxO era -> TxBody era -> Value era
getProducedValue :: EraUTxO era => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> TxBody era -> Value era

-- | Initial eras will look into witness set to find all of the available
--   scripts, but starting with Babbage we can look for available scripts
--   in the UTxO using reference inputs.
getScriptsProvided :: EraUTxO era => UTxO era -> Tx era -> ScriptsProvided era

-- | Produce all the information required for figuring out which scripts
--   are required for the transaction to be valid, once those scripts are
--   evaluated
getScriptsNeeded :: EraUTxO era => UTxO era -> TxBody era -> ScriptsNeeded era

-- | Extract the set of all script hashes that are needed for script
--   validation.
getScriptsHashesNeeded :: EraUTxO era => ScriptsNeeded era -> Set (ScriptHash (EraCrypto era))

-- | Extract all of the KeyHash witnesses that are required for validating
--   the transaction
getWitsVKeyNeeded :: EraUTxO era => CertState era -> UTxO era -> TxBody era -> Set (KeyHash 'Witness (EraCrypto era))

-- | The only reason it is a newtype instead of just a Map is becuase for
--   later eras is expensive to compute the actual map, so we want to use
--   the type safety guidance to avoid redundant work.
newtype ScriptsProvided era
ScriptsProvided :: Map (ScriptHash (EraCrypto era)) (Script era) -> ScriptsProvided era
[unScriptsProvided] :: ScriptsProvided era -> Map (ScriptHash (EraCrypto era)) (Script era)

-- | Compute the UTxO inputs of a transaction. txins has the same problems
--   as txouts, see notes below.
txins :: EraTxBody era => TxBody era -> Set (TxIn (EraCrypto era))

-- | Lookup a txin for a given UTxO collection
txinLookup :: TxIn (EraCrypto era) -> UTxO era -> Maybe (TxOut era)

-- | Filter out TxIn's from the <a>UTxO</a> map
txInsFilter :: UTxO era -> Set (TxIn (EraCrypto era)) -> UTxO era

-- | Compute the transaction outputs of a transaction.
txouts :: forall era. EraTxBody era => TxBody era -> UTxO era

-- | Determine the total balance contained in the UTxO.
balance :: EraTxOut era => UTxO era -> Value era

-- | Determine the total Ada only balance contained in the UTxO. This is
--   equivalent to `coin . balance`, but it will be more efficient
coinBalance :: EraTxOut era => UTxO era -> Coin

-- | Sum all the value in any Foldable with <a>TxOut</a>s
sumAllValue :: (EraTxOut era, Foldable f) => f (TxOut era) -> Value era

-- | Sum all the <a>Coin</a>s in any Foldable with with <a>TxOut</a>s. Care
--   should be taken since it is susceptible to integer overflow, therefore
--   make sure this function is not applied to unvalidated <a>TxOut</a>s
sumAllCoin :: (EraTxOut era, Foldable f) => f (TxOut era) -> Coin

-- | Check whether any of the supplied <a>TxOut</a>s contain any
--   MultiAssets. Returns True if non of them do.
areAllAdaOnly :: (EraTxOut era, Foldable f) => f (TxOut era) -> Bool

-- | Verify a transaction body witness
verifyWitVKey :: (Typeable kr, Crypto c, DSignable c (Hash c EraIndependentTxBody)) => Hash c EraIndependentTxBody -> WitVKey kr c -> Bool

-- | Extract script hash from value address with script.
getScriptHash :: Addr c -> Maybe (ScriptHash c)
instance GHC.Base.Semigroup (Cardano.Ledger.UTxO.UTxO era)
instance GHC.Generics.Generic (Cardano.Ledger.UTxO.UTxO era)
instance Data.Default.Class.Default (Cardano.Ledger.UTxO.UTxO era)
instance GHC.Generics.Generic (Cardano.Ledger.UTxO.ScriptsProvided era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era) => NoThunks.Class.NoThunks (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era)) => Control.DeepSeq.NFData (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era)) => GHC.Classes.Eq (Cardano.Ledger.UTxO.UTxO era)
instance Cardano.Ledger.Core.Era.Era era => GHC.Base.Monoid (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxOut era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxOut era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.UTxO.UTxO era)
instance (GHC.Show.Show (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era)) => GHC.Show.Show (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxOut era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.Script era)) => GHC.Classes.Eq (Cardano.Ledger.UTxO.ScriptsProvided era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Ord (Cardano.Ledger.Core.Script era)) => GHC.Classes.Ord (Cardano.Ledger.UTxO.ScriptsProvided era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.UTxO.ScriptsProvided era)
instance (Cardano.Ledger.Core.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era)) => Control.DeepSeq.NFData (Cardano.Ledger.UTxO.ScriptsProvided era)
instance (Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Core.Era.Era era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Core.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.UTxO.UTxO era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Core.Era.EraCrypto era), Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Binary.Decoding.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Cardano.Ledger.Binary.Decoding.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Internal.Staking (Cardano.Ledger.Core.Era.EraCrypto era))) => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.UTxO.UTxO era)


-- | This is a module that contains functionality that is not necessary for
--   ledger operation, but is useful for testing as well as for downstream
--   users of ledger
module Cardano.Ledger.Tools

-- | Calculate and update the fee in the transaction until it has the
--   smallest possible value according to the settings in the protocol
--   parameters.
--   
--   This function potentially changes the <a>feeTxBodyL</a> field of the
--   <a>TxBody</a>, as such it affects the hash of the body, which
--   consequently invalidates all of the signature in the attached
--   witnesses.
setMinFeeTx :: EraTx era => PParams era -> Tx era -> Tx era

-- | This is a more accurate version <a>estimateMinFeeTx</a> that looks
--   into transaction and figures out how many and what kind of key
--   witnesses this transaction needs. It requires access to the portion of
--   the <a>UTxO</a> that is relevant for this transaction. The only type
--   of witnesses that it cannot figure out reliably is the witnesses
--   needed for satisfying native scripts included in the transaction. For
--   this reason number of witnesses needed for native scripts must be
--   supplied as an extra argument.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let relevantUtxo = txInsFilter utxo (tx ^. bodyTxL . allInputsTxBodyF)
--   
--   &gt;&gt;&gt; calcMinFeeTx relevantUtxo pp tx 5
--   </pre>
calcMinFeeTx :: forall era. EraUTxO era => UTxO era -> PParams era -> Tx era -> Int -> Coin

-- | Same as <a>calcMinFeeTx</a>, except this function allows to specify
--   hashes of key witnesses that will be supplied, instead of their count.
--   That is only useful whenever there is a chance of some of the required
--   witnesses being the same as the witnesses that will be supplied for
--   native scripts.
calcMinFeeTxNativeScriptWits :: forall era. EraUTxO era => UTxO era -> PParams era -> Tx era -> Set (KeyHash 'Witness (EraCrypto era)) -> Coin

-- | Estimate a minimum transaction fee for a transaction that does not yet
--   have all of the <a>VKey</a> witnesses. This calculation is not very
--   accurate in estimating Byron witnesses, but it should work for the
--   most part. If you have access to UTxO necessary for the transaction
--   that it is better and easier to use <a>calcMinFeeTx</a> instead.
estimateMinFeeTx :: forall era. EraTx era => PParams era -> Tx era -> Int -> Int -> Coin

-- | Create dummy witnesses and add them to the transaction
addDummyWitsTx :: forall era. EraTx era => PParams era -> Tx era -> Int -> [Attributes AddrAttributes] -> Tx era
integralToByteStringN :: (Integral i, Bits i) => Int -> i -> ByteString

module Cardano.Ledger.Block
data Block h era
Block' :: !h -> !TxSeq era -> ByteString -> Block h era
pattern Block :: forall era h. (Era era, EncCBORGroup (TxSeq era), EncCBOR h) => h -> TxSeq era -> Block h era

-- | Access a block without its serialised bytes. This is often useful when
--   we're using a <tt>BHeaderView</tt> in place of the concrete header.
pattern UnserialisedBlock :: h -> TxSeq era -> Block h era

-- | Unsafely construct a block without the ability to serialise its bytes.
--   
--   Anyone calling this pattern must ensure that the resulting block is
--   never serialised. Any uses of this pattern outside of testing code
--   should be regarded with suspicion.
pattern UnsafeUnserialisedBlock :: h -> TxSeq era -> Block h era
bheader :: Block h era -> h
bbody :: Block h era -> TxSeq era

-- | The validity of any individual block depends only on a subset of the
--   UTxO stored in the ledger state. This function returns the transaction
--   inputs corresponding to the required UTxO for a given Block.
--   
--   This function will be used by the consensus layer to enable storing
--   the UTxO on disk. In particular, given a block, the consensus layer
--   will use <a>neededTxInsForBlock</a> to retrieve the needed UTxO from
--   disk and present only those to the ledger.
neededTxInsForBlock :: forall h era. EraSegWits era => Block h era -> Set (TxIn (EraCrypto era))

-- | Compute the id of a transaction.

-- | <i>Deprecated: In favor of <a>txIdTxBody</a> or <a>txIdTx</a></i>
txid :: EraTxBody era => TxBody era -> TxId (EraCrypto era)
instance GHC.Generics.Generic (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.TxSeq era), GHC.Show.Show h) => GHC.Show.Show (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxSeq era), GHC.Classes.Eq h) => GHC.Classes.Eq (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxSeq era), NoThunks.Class.NoThunks h) => NoThunks.Class.NoThunks (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.EraTx era, Data.Typeable.Internal.Typeable h) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.EraTx era, Data.Typeable.Internal.Typeable h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Core.EraSegWits era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator h), Data.Typeable.Internal.Typeable h) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Block.Block h era))
